(function(){"use strict";var n={8785:function(n,e,r){var t=r(9242),a=r(3396);const i={id:"app"};function s(n,e,r,t,s,l){const o=(0,a.up)("CLI");return(0,a.wg)(),(0,a.iD)("div",i,[(0,a.Wm)(o,{ref:"cli"},null,512)])}var l=r(7139);const o=n=>((0,a.dD)("data-v-7a0a4bcf"),n=n(),(0,a.Cn)(),n),d={class:"cli-main"},_=o((()=>(0,a._)("span",{class:"cli-head"},"stonesaw.github.io ",-1))),c={class:"cli-dir"},p=o((()=>(0,a._)("span",{class:"cli-head"}," $ ",-1))),m={class:"cli-input-history"},u=["innerHTML"],f=o((()=>(0,a._)("span",{class:"cli-head"},"stonesaw.github.io ",-1))),h={class:"cli-dir"},g=o((()=>(0,a._)("span",{class:"cli-head"}," $ ",-1)));function w(n,e,r,t,i,s){const o=(0,a.up)("CLIStart"),w=(0,a.up)("CLIInput");return(0,a.wg)(),(0,a.iD)("div",d,[(0,a.Wm)(o),((0,a.wg)(!0),(0,a.iD)(a.HY,null,(0,a.Ko)(n.histories,((n,e)=>((0,a.wg)(),(0,a.iD)("div",{key:e,class:"cli-history"},[_,(0,a._)("span",c,(0,l.zw)(n.dir.join("/")),1),p,(0,a._)("span",m,(0,l.zw)(n.input),1),((0,a.wg)(!0),(0,a.iD)(a.HY,null,(0,a.Ko)(n.result_ary,((n,e)=>((0,a.wg)(),(0,a.iD)("div",{key:e},[(0,a._)("span",{class:"cli-result",innerHTML:n},null,8,u)])))),128))])))),128)),(0,a._)("div",null,[f,(0,a._)("span",h,(0,l.zw)(n.working_dir.join("/")),1),g,(0,a.Wm)(w,{ref:"input",onExecCmd:n.inputEnter,onComplementDir:n.inputTab},null,8,["onExecCmd","onComplementDir"])])])}r(7658);const b={class:"cli-start"},y=(0,a._)("div",null,[(0,a._)("div",null,"Â _Â Â Â Â Â Â Â __Â Â Â Â Â __Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â __Â Â Â Â Â Â Â Â Â Â Â ________Â Â Â Â ____Â Â Â __"),(0,a._)("div",null,"|Â |Â Â Â Â Â /Â /__Â Â /Â /________Â Â ____Â ___Â Â ___Â Â Â Â Â /Â /_____Â Â Â Â Â /Â ____/Â /Â Â Â /Â Â _/Â Â /Â /"),(0,a._)("div",null,"|Â |Â /|Â /Â /Â _Â \\/Â /Â ___/Â __Â \\/Â __Â `__Â \\/Â _Â \\Â Â Â /Â __/Â __Â \\Â Â Â /Â /Â Â Â /Â /Â Â Â Â /Â /Â Â Â /Â /Â "),(0,a._)("div",null,"|Â |/Â |/Â /Â Â __/Â /Â /__/Â /_/Â /Â /Â /Â /Â /Â /Â Â __/Â Â /Â /_/Â /_/Â /Â Â /Â /___/Â /____/Â /Â Â Â /_/Â Â "),(0,a._)("div",null,"|__/|__/\\___/_/\\___/\\____/_/Â /_/Â /_/\\___/Â Â Â \\__/\\____/Â Â Â \\____/_____/___/Â Â (_)Â Â Â ")],-1),v=(0,a._)("div",null,"Welcome to cli",-1),x=[y,v];function k(n,e){return(0,a.wg)(),(0,a.iD)("div",b,x)}var S=r(89);const W={},I=(0,S.Z)(W,[["render",k]]);var E=I;function P(n,e,r,i,s,l){return(0,a.wg)(),(0,a.iD)("span",{class:"cli-input",onKeydown:[e[2]||(e[2]=(0,t.D2)(((...e)=>n.pressKeyUp&&n.pressKeyUp(...e)),["up"])),e[3]||(e[3]=(0,t.D2)(((...e)=>n.pressKeyDown&&n.pressKeyDown(...e)),["down"])),e[4]||(e[4]=(0,t.D2)(((...e)=>n.pressKeyTab&&n.pressKeyTab(...e)),["tab"]))]},[(0,a.wy)((0,a._)("input",{ref:"input","onUpdate:modelValue":e[0]||(e[0]=e=>n.inputText=e),type:"text",autofocus:"",maxlength:"50",onKeydown:e[1]||(e[1]=(0,t.D2)(((...e)=>n.pressKeyEnter&&n.pressKeyEnter(...e)),["enter"]))},null,544),[[t.nr,n.inputText]])],32)}var j=(0,a.aZ)({emits:["exec-cmd","complement-dir"],data(){return{inputText:"",history:[],historyIndex:null,inputCurrent:""}},mounted(){this.loadHistory()},methods:{refs(){return this.$refs},focus(){this.refs().input.focus()},loadHistory(){if(localStorage.getItem("history"))try{this.history=JSON.parse(localStorage.getItem("history"))}catch(n){localStorage.removeItem("history")}},saveHistory(){const n=JSON.stringify(this.history);localStorage.setItem("history",n)},clearHistory(){this.history=[]},pressKeyEnter(){this.$emit("exec-cmd",this.inputText),""!==this.inputText&&this.history[this.history.length-1]!==this.inputText&&(this.history.push(this.inputText),this.historyIndex=null,this.saveHistory()),this.inputText="",this.inputCurrent=""},pressKeyTab(n){n.preventDefault(),this.$emit("complement-dir",this.inputText)},pressKeyUp(n){n.preventDefault(),this.history.length>0&&(null===this.historyIndex&&(this.historyIndex=this.history.length,this.inputCurrent=this.inputText),this.historyIndex=Math.max(this.historyIndex-1,0),this.inputText=this.history[this.historyIndex])},pressKeyDown(n){n.preventDefault(),this.history.length>0&&null!==this.historyIndex&&(this.historyIndex===this.history.length-1?(this.historyIndex=null,this.inputText=this.inputCurrent):(this.historyIndex=Math.min(this.historyIndex+1,this.history.length-1),this.inputText=this.history[this.historyIndex]))}}});const C=(0,S.Z)(j,[["render",P],["__scopeId","data-v-38317d10"]]);var A=C;function D(n){return null!==n&&void 0!==n||Array.isArray(n)&&T(n)}function T(n){return!(n.length>0)}function M(n,e){const r=Object.prototype.toString.call(e).slice(8,-1);return void 0!==e&&null!==e&&r===n}function $(n){return M("Object",n)}var O=r(2482);const B=r(790),z=r(8566),H={en:B,ja:z};class L{static isAllowedLocale(n){return"en"===n||"ja"===n}static setLocale(n){if(!this.isAllowedLocale(n))throw new Error(`don't know locale '${n}'`);this.locale=n}static t(n,e){let r=this._searchMessage(n);Array.isArray(r)&&(r=r.join("\n"));for(const[t,a]of Object.entries(e||{})){if(!RegExp(`{${t}}`).test(r))throw new Error(`i18n.t() unknown format '${t}'\n  local: ${this.locale}`);r=r.replace(`{${t}}`,a||"")}return r}static _searchMessage(n){if(this.locale in H){const e=H[this.locale],r=n.split(".").filter((n=>""!==n));let t=e;for(let a=0;a<r.length;a++){const e=t[r[a]];if("string"===typeof e||Array.isArray(e)){if(a<r.length-1)throw new Error(`i18n.t() key '${n}' at '${r[a+1]}' is not found!.\n  local: ${this.locale}`);return e}t=e}throw new Error(`i18n.t() key '${n}' is not found!\n  local: ${this.locale}`)}throw new Error(`i18n.t() local '${this.locale}' is not found!`)}}(0,O.Z)(L,"locale","en");var K=L;const R=r(7832);function F(n){return void 0!==n.childDir}function q(n){return void 0!==n?.content}function N(n,e){for(const[r,t]of Object.entries(n))if(Array.isArray(t)){let n={path:`${e.path}/${r}`,name:r,type:t[0],content:t[1]||"",parentDir:e};e.childDir.push(n)}else{if(!$(t))throw`can't generate directory ( key:${r}, value:${t} )`;{let t={path:`${e.path}/${r}`,name:r,childDir:[],parentDir:e};e.childDir.push(t),N(n[`${r}`],t)}}}let G={path:"~",name:"~",childDir:[],parentDir:null};function U(n){let e="";for(let r=0;r<n.length;r++){const t=n[r];F(t)?e+=`${t.name}/   `:e+=`${t.name}    `}return e}function V(n,e=/.*/){return n.childDir.filter((n=>e.test(n.name)))}function J(n,e){const r=e.split("/").filter((n=>""!==n&&"."!==n));return"~"===r[0]?r:n.concat(r)}function Z(n,e="./"){const r=J(n,e);"~"===r[0]&&r.shift();let t=G;for(let a=0;a<r.length;a++){const n=r[a];if(q(t))return{error:K.t("errors.no_such_dirs"),info:t};if("."===n);else if(".."===n)null===t.parentDir||(t=t.parentDir);else{let e=!1;for(let r=0;r<t.childDir.length;r++)if(t.childDir[r].name===n){t=t.childDir[r],e=!0;break}if(!e)return{error:K.t("errors.no_such_dirs"),info:t}}}return t}function X(n,e="./"){const r=e.split("/").filter((n=>""!==n&&"."!==n)),t=Z(n,e);if(!q(t)){let n;switch(n=F(t)?t.childDir:F(t.info)?V(t.info,RegExp(`^${r[r.length-1]||""}.*`)):[],n.length){case 0:return null;case 1:let e;return F(t)?e=r.concat([n[0].name]).join("/"):(r[r.length-1]=n[0].name,e=r.join("/")),{dir:e+(F(n[0])?"/":"")};default:return U(n)}}return null}function Y(n,e){const r=Z(n,e[0]||"~");return q(r)?{error:K.t("errors.is_not_dir",{dir_name:e[0]})}:F(r)?{dir:r.path.split("/")}:{error:r.error}}function Q(n,e){const r=Z(n,e[0]);return q(r)?[K.t("errors.is_not_dir",{dir_name:e[0]}),null]:F(r)?[U(r.childDir),null]:[r.error,null]}function nn(n,e){if(!D(e[0])||"-h"===e[0]||"--help"===e[0])return["cat help",null];const r=Z(n,e[0]);return F(r)||q(r)?F(r)||"txt"!==r.type?[K.t("errors.is_not_text",{dir_name:e[0]}),null]:[r.content,null]:[r.error,null]}function en(n){if(n.includes("-clear"))return localStorage.removeItem("history"),[K.t("messages.clear_history"),null];let e=[];if(!localStorage.getItem("history"))return[K.t("messages.no_history"),null];try{e=JSON.parse(localStorage.getItem("history"))}catch(a){localStorage.removeItem("history")}const r=Math.log10(e.length)+1;let t="";return e.forEach(((n,e)=>{t+=` ${e.toString().padStart(r," ")}  ${n}\n`})),[t.replace(/\n$/,""),null]}function rn(n,e){if(!D(e[0])||"-h"===e[0]||"--help"===e[0])return{msg:"open help"};const r=Z(n,e[0]);return F(r)||q(r)?F(r)||"link"!==r.type?{error:K.t("errors.is_not_link",{dir_name:e[0]})}:{data:r.content}:{error:r.error}}N(R["~"],G);var tn=(0,a.aZ)({name:"CLI",components:{CLIStart:E,CLIInput:A},data(){return{working_dir:["~","cli"],histories:[],commands:[{name:"cd",args:"[dir]"},{name:"ls",args:"[dir]"},{name:"cat",args:"[file]"},{name:"history",args:"[-clear]"},{name:"lang",args:"[en|ja]"},{name:"open",args:"[link_file]"},{name:"share",args:"[-tw]"}],afterInputActions:[]}},methods:{refs(){return this.$refs},focus(){this.refs().input.focus()},inputEnter(n){const e=this.execCommand(n);var r;null===e[0]?r=[""]:"html"===e[1]?r=e[0].split("\n"):(r=this.textToHtml(e[0]).split("\n"),r=r.map((n=>""===n?"&nbsp;":n))),this.histories.push({input:n,dir:this.working_dir,result_ary:r}),this.afterInputActions.forEach((n=>{n(this)})),this.afterInputActions=[]},inputTab(n){const e=n.split(" ").filter((n=>""!==n));if(0===e.length||!["cd","ls","cat","open"].includes(e[0]))return null;const r=X(this.working_dir,e[1]);if("string"===typeof r){let e=this.textToHtml(r).split("\n");this.histories.push({input:n,dir:this.working_dir,result_ary:e})}else{if(!r?.dir)return null;this.refs().input.inputText=`${e[0]} ${r.dir}`}},execCommand(n){const e=n.split(" ").filter((n=>""!==n));if(0===e.length)return[null,null];switch(e[0]){case"help":{let n=0,e="Command list\n";return this.commands.forEach((e=>{n=Math.max(n,e.name.length+e.args.length)})),this.commands.forEach((r=>{let t=r.name.length+r.args.length;e+=` * ${r.name} ${r.args}${" ".repeat(n-t+4)}:${K.t(`help.summary.${r.name}`)}\n`})),[e.trim(),null]}case"cd":{let n=Y(this.working_dir,e.splice(1));return void 0==n.error&&this.afterInputActions.push((function(e){e.working_dir=n.dir})),[n.error||null,null]}case"ls":return Q(this.working_dir,e.splice(1));case"cat":return nn(this.working_dir,e.splice(1));case"history":return"-clear"===e[1]&&this.refs().input.clearHistory(),en(e.splice(1));case"lang":if(!e[1]||""===e[1])return[`current lang is ${K.locale}`,null];try{return K.setLocale(e[1]),[`lang: set language '${e[1]}'`,null]}catch(r){return[`lang: can't set language '${e[1]}'`,null]}case"open":{let n=rn(this.working_dir,e.splice(1));return n.error?[n.error,null]:n.msg?[n.msg,null]:(window.open(n.data),[`open: ${n.data}`,null])}case"share":return"-tw"===e[1]?(window.open("http://twitter.com/share?text=%F0%9F%AB%A1%20Hello,%20web-cli%0Acheck%20it%20...%20&url=https://stonesaw.github.io/cli/%0A&hashtags=indiedev,webdev,opensource&related=sou_0x0v"),['<a href="http://twitter.com/share?text=%F0%9F%AB%A1%20Hello,%20web-cli%0Acheck%20it%20...%20&url=https://stonesaw.github.io/cli/%0A&hashtags=indiedev,webdev,opensource&related=sou_0x0v" target="_blank">Share on Twitter</a>',"html"]):["<u>https://stonesaw.github.io/cli/</u>","html"];default:return[`Command '${e[0]}' is not found! Use 'help' to see the command list.`,null]}},textToHtml(n){return n.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll(" ","&nbsp;")}}});const an=(0,S.Z)(tn,[["render",w],["__scopeId","data-v-7a0a4bcf"]]);var sn=an,ln=(0,a.aZ)({components:{CLI:sn},mounted(){document.addEventListener("keydown",this.onKeyDown)},onUnmounted(){document.removeEventListener("keydown",this.onKeyDown)},methods:{refs(){return this.$refs},onKeyDown(){this.refs().cli.focus();let n=document.documentElement,e=n.scrollHeight-n.clientHeight;window.scroll(0,e)}}});const on=(0,S.Z)(ln,[["render",s]]);var dn=on;(0,t.ri)(dn).mount("#app")},7832:function(n){n.exports=JSON.parse('{"~":{"cli":{"README.md":["txt","# ğŸˆ [cli](https://stonesaw.github.io/cli)\\nhttps://stonesaw.github.io/cli  \\n[ ğŸ”¨ Building now ...]  \\nImplement the cli interface on the web  \\n\\n\\n## âœ¨ Features\\n```bash\\nstonesaaw.github.io> cd portfolio\\n                     # => Redirecting to portfolio/\\n\\nstonesaaw.github.io> ls\\n                     # => portfolio/\\n                     # => blog/\\n                     # => ...\\n```\\n"],"repo.link":["link","https://github.com/stonesaw/cli"],"src":{"assets":{"logo.png":["img"]}}},"portfolio":{".github":{"workflows":{"cd.yml":["txt","name: cd\\r\\n\\r\\non: [push, pull_request]\\r\\n\\r\\njobs:\\r\\n  cd:\\r\\n    runs-on: ${{ matrix.os }}\\r\\n\\r\\n    strategy:\\r\\n      matrix:\\r\\n        os: [ubuntu-latest]\\r\\n        node: [14]\\r\\n\\r\\n    steps:\\r\\n      - name: Checkout\\r\\n        uses: actions/checkout@master\\r\\n\\r\\n      - name: Setup node env\\r\\n        uses: actions/setup-node@v2.1.2\\r\\n        with:\\r\\n          node-version: ${{ matrix.node }}\\r\\n\\r\\n      - name: Install dependencies\\r\\n        run: yarn\\r\\n\\r\\n      - name: Generate\\r\\n        run: yarn run build\\r\\n\\r\\n      - name: Deploy\\r\\n        uses: peaceiris/actions-gh-pages@v3\\r\\n        with:\\r\\n          github_token: ${{ secrets.GITHUB_TOKEN }}\\r\\n          publish_dir: ./dist\\r\\n"]}},".gitignore":["txt",".DS_Store\\nnode_modules\\ndist/\\n\\n# local env files\\n.env.local\\n.env.*.local\\n\\n# Log files\\nnpm-debug.log*\\nyarn-debug.log*\\nyarn-error.log*\\npnpm-debug.log*\\n\\n# Editor directories and files\\n.idea\\n.vscode\\n*.suo\\n*.ntvs*\\n*.njsproj\\n*.sln\\n*.sw?\\n"],".rubocop.yml":["txt","inherit_from:\\r\\n  - .rubocop_todo.yml\\r\\n  - .rubocop_airbnb.yml\\r\\n\\r\\nRails:\\r\\n  Enabled: false\\r\\n\\r\\n# {} ã¯ 1 è¡Œã§æ›¸ãã¨ãã«ä¸»ã«ä½¿ã‚ã‚Œã‚‹ã®ã§ã€ã‚¹ãƒšãƒ¼ã‚¹ã‚ˆã‚Šã‚‚\\r\\n# æ¨ªã«é•·ããªã‚‰ãªã„æ–¹ãŒå¬‰ã—ã•ãŒå¤šã„ã€‚\\r\\n# ãã‚‚ãã‚‚ {| ã®ã‚¹ã‚¿ã‚¤ãƒ«ã®æ–¹ãŒä¸€èˆ¬çš„ã ã£ãŸã¨èªè­˜ã—ã¦ã„ã‚‹ã€‚\\r\\nLayout/SpaceInsideBlockBraces:\\r\\n  SpaceBeforeBlockParameters: false\\r\\n\\r\\n# 2è¡Œä»¥ä¸Šã®ç©ºè¡Œã‚’è¨±å¯ã™ã‚‹\\r\\nLayout/EmptyLines:\\r\\n  Enabled: false\\r\\n\\r\\n# è¡Œã®é•·ã•ã®æœ€å¤§å€¤ã‚’110ã«\\r\\nMetrics/LineLength:\\r\\n  Max: 110\\r\\n"],".rubocop_airbnb.yml":["txt","require:\\r\\n  - rubocop-airbnb\\r\\n"],".rubocop_todo.yml":["txt","# This configuration was generated by\\r\\n# `rubocop --auto-gen-config`\\r\\n# on 2021-02-25 07:49:09 +0900 using RuboCop version 0.76.0.\\r\\n# The point is for the user to remove these configuration records\\r\\n# one by one as the offenses are removed from the code base.\\r\\n# Note that changes in the inspected code, or installation of new\\r\\n# versions of RuboCop, may require this file to be generated again.\\r\\n\\r\\n# Offense count: 2\\r\\nSecurity/Eval:\\r\\n  Exclude:\\r\\n    - \'lib/utils/scrollable_page.rb\'\\r\\n    - \'lib/utils/text_box.rb\'\\r\\n"],"CODE_OF_CONDUCT.md":["txt","# Contributor Covenant Code of Conduct\\n\\n## Our Pledge\\n\\nIn the interest of fostering an open and welcoming environment, we as\\ncontributors and maintainers pledge to making participation in our project and\\nour community a harassment-free experience for everyone, regardless of age, body\\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\\nlevel of experience, education, socio-economic status, nationality, personal\\nappearance, race, religion, or sexual identity and orientation.\\n\\n## Our Standards\\n\\nExamples of behavior that contributes to creating a positive environment\\ninclude:\\n\\n* Using welcoming and inclusive language\\n* Being respectful of differing viewpoints and experiences\\n* Gracefully accepting constructive criticism\\n* Focusing on what is best for the community\\n* Showing empathy towards other community members\\n\\nExamples of unacceptable behavior by participants include:\\n\\n* The use of sexualized language or imagery and unwelcome sexual attention or\\n advances\\n* Trolling, insulting/derogatory comments, and personal or political attacks\\n* Public or private harassment\\n* Publishing others\' private information, such as a physical or electronic\\n address, without explicit permission\\n* Other conduct which could reasonably be considered inappropriate in a\\n professional setting\\n\\n## Our Responsibilities\\n\\nProject maintainers are responsible for clarifying the standards of acceptable\\nbehavior and are expected to take appropriate and fair corrective action in\\nresponse to any instances of unacceptable behavior.\\n\\nProject maintainers have the right and responsibility to remove, edit, or\\nreject comments, commits, code, wiki edits, issues, and other contributions\\nthat are not aligned to this Code of Conduct, or to ban temporarily or\\npermanently any contributor for other behaviors that they deem inappropriate,\\nthreatening, offensive, or harmful.\\n\\n## Scope\\n\\nThis Code of Conduct applies both within project spaces and in public spaces\\nwhen an individual is representing the project or its community. Examples of\\nrepresenting a project or community include using an official project e-mail\\naddress, posting via an official social media account, or acting as an appointed\\nrepresentative at an online or offline event. Representation of a project may be\\nfurther defined and clarified by project maintainers.\\n\\n## Enforcement\\n\\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\\nreported by contacting the project team at mail.sou.dev@gmail.com. All\\ncomplaints will be reviewed and investigated and will result in a response that\\nis deemed necessary and appropriate to the circumstances. The project team is\\nobligated to maintain confidentiality with regard to the reporter of an incident.\\nFurther details of specific enforcement policies may be posted separately.\\n\\nProject maintainers who do not follow or enforce the Code of Conduct in good\\nfaith may face temporary or permanent repercussions as determined by other\\nmembers of the project\'s leadership.\\n\\n## Attribution\\n\\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\\n\\n[homepage]: https://www.contributor-covenant.org\\n\\nFor answers to common questions about this code of conduct, see\\nhttps://www.contributor-covenant.org/faq\\n"],"README.md":["txt","<img src=\\"./logo.png\\" width=\\"30%\\" align=\\"right\\" />\\r\\n\\r\\n# Spell Out\\r\\n- ãƒã‚¦ã‚¹æ“ä½œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°\\r\\n- 5ã¤ã®å±æ€§(ğŸ”¥ğŸ’§ğŸŒ¬âšœğŸ’€)ã¨å±æ€§ã”ã¨ã®æ”»æ’ƒãƒ»ã‚¹ã‚­ãƒ«\\r\\n- å±æ€§ã®ç›¸æ€§ã«ã‚ˆã£ã¦ãƒ€ãƒ¡ãƒ¼ã‚¸é‡ãŒå¤‰åŒ–\\r\\n- å…¨6 ã‚¹ãƒ†ãƒ¼ã‚¸\\r\\n- (ã¿ã‹ã‚ã—) *todo*  \\r\\nè©³ã—ã„æ“ä½œæ–¹æ³•ãªã©ã¯ã€[how-to.md](how-to.md) ã‚’è¦‹ã¦ã­  \\r\\n\\r\\n\\r\\n## GitHub\\r\\nhttps://github.com/stonesaw/Spell-Out\\r\\n\\r\\n## ä½¿ç”¨ã‚¢ã‚»ãƒƒãƒˆ\\r\\n- ãƒ©ã‚¤ãƒ–ãƒ©ãƒª : [DXRuby](http://dxruby.osdn.jp/)\\r\\n- éŸ³æº  \\r\\n    [é­”ç‹é­‚æ§˜](https://maoudamashii.jokersounds.com/)  \\r\\n    [Tallbeard Studiosæ§˜](https://tallbeard.itch.io/music-loop-bundle)\\r\\n- ç”»åƒ  \\r\\n    [ãƒŒãƒ¼æ§˜](http://damagedgold.wp.xdomain.jp/2016/03/25/link/)  \\r\\n    [å°¾ç¾½ã®å°å±‹æ§˜](http://obane.tuzikaze.com/)\\r\\n- ãƒ•ã‚©ãƒ³ãƒˆ  \\r\\n    [jetiæ§˜](https://fontmeme.com/jfont/poco-font/)\\r\\n    \\r\\n\\r\\n## é–‹ç™ºãƒ„ãƒ¼ãƒ« & ãƒªãƒ³ã‚¯é›†\\r\\n- vscode ext  \\r\\n  Ruby Solargraph (https://marketplace.visualstudio.com/items?itemName=castwide.solargraph)  \\r\\n  endwise (https://marketplace.visualstudio.com/items?itemName=kaiwood.endwise)  \\r\\n- DXRuby API Reference (http://mirichi.github.io/dxruby-doc/api/index.html)  \\r\\n"],"babel.config.js":["txt","module.exports = {\\n  presets: [\\n    \\"@vue/cli-plugin-babel/preset\\"\\n  ]\\n}\\n"],"assets":{"font":{},"image":{},"sound":{}},"jsconfig.json":["txt","{\\n  \\"compilerOptions\\": {\\n    \\"target\\": \\"es5\\",\\n    \\"module\\": \\"esnext\\",\\n    \\"baseUrl\\": \\"./\\",\\n    \\"moduleResolution\\": \\"node\\",\\n    \\"paths\\": {\\n      \\"@/*\\": [\\n        \\"src/*\\"\\n      ]\\n    },\\n    \\"lib\\": [\\n      \\"esnext\\",\\n      \\"dom\\",\\n      \\"dom.iterable\\",\\n      \\"scripthost\\"\\n    ]\\n  }\\n}\\n"],"package-lock.json":["txt","too longer."],"package.json":["txt","{\\n  \\"name\\": \\"portfolio\\",\\n  \\"version\\": \\"0.1.0\\",\\n  \\"private\\": true,\\n  \\"scripts\\": {\\n    \\"serve\\": \\"vue-cli-service serve\\",\\n    \\"build\\": \\"vue-cli-service build\\",\\n    \\"lint\\": \\"vue-cli-service lint\\"\\n  },\\n  \\"dependencies\\": {\\n    \\"core-js\\": \\"^3.8.3\\",\\n    \\"vue\\": \\"^2.6.14\\",\\n    \\"vuetify\\": \\"^2.6.0\\"\\n  },\\n  \\"devDependencies\\": {\\n    \\"@babel/core\\": \\"^7.12.16\\",\\n    \\"@babel/eslint-parser\\": \\"^7.12.16\\",\\n    \\"@vue/cli-plugin-babel\\": \\"~5.0.0\\",\\n    \\"@vue/cli-plugin-eslint\\": \\"~5.0.0\\",\\n    \\"@vue/cli-service\\": \\"~5.0.0\\",\\n    \\"eslint\\": \\"^7.32.0\\",\\n    \\"eslint-plugin-vue\\": \\"^8.0.3\\",\\n    \\"sass\\": \\"~1.32.0\\",\\n    \\"sass-loader\\": \\"^10.0.0\\",\\n    \\"vue-cli-plugin-vuetify\\": \\"~2.5.2\\",\\n    \\"vue-template-compiler\\": \\"^2.6.14\\",\\n    \\"vuetify-loader\\": \\"^1.7.0\\"\\n  },\\n  \\"eslintConfig\\": {\\n    \\"root\\": true,\\n    \\"env\\": {\\n      \\"node\\": true\\n    },\\n    \\"extends\\": [\\n      \\"plugin:vue/essential\\",\\n      \\"eslint:recommended\\"\\n    ],\\n    \\"parserOptions\\": {\\n      \\"parser\\": \\"@babel/eslint-parser\\"\\n    },\\n    \\"rules\\": {}\\n  },\\n  \\"browserslist\\": [\\n    \\"> 1%\\",\\n    \\"last 2 versions\\",\\n    \\"not dead\\"\\n  ]\\n}\\n"],"public":{"index.html":["txt","<!DOCTYPE html>\\n<html lang=\\"ja\\">\\n  <head prefix=\\"og:http://ogp.me/ns#\\">\\n    <meta charset=\\"utf-8\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"IE=edge\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width,initial-scale=1.0\\">\\n    <link rel=\\"icon\\" href=\\"./favicon.ico\\">\\n    <title>Sou\'s Portfolio on GitHub Pages</title>\\n    <meta name=\\"description\\" content=\\"Souã®ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã‚µã‚¤ãƒˆã€‚æˆæœç‰©ã‚„ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¨ã—ã¦ã®ã‚¹ã‚­ãƒ«ãªã©ãªã©... Vue.jsã¨Vuetifyã‚’ä½¿ç”¨ã—é–‹ç™ºã—ã¾ã—ãŸã€‚\\">\\n    <meta name=\\"keywords\\" content=\\"ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ª,ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°,ãƒ‡ã‚¶ã‚¤ãƒ³,Vue.js,GitHub\\">\\n\\n    \x3c!-- OGP --\x3e\\n    <meta property=\\"og:title\\" content=\\"Sou\'s Portfolio\\">\\n    <meta property=\\"og:description\\" content=\\"Souã®ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã‚µã‚¤ãƒˆã€‚æˆæœç‰©ã‚„ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¨ã—ã¦ã®ã‚¹ã‚­ãƒ«ãªã©ãªã©... Vue.jsã¨Vuetifyã‚’ä½¿ç”¨ã—é–‹ç™ºã—ã¾ã—ãŸã€‚\\">\\n    <meta property=\\"og:url\\" content=\\"https://stonesaw.github.io/portfolio/\\">\\n    <meta property=\\"og:image\\" content=\\"https://stonesaw.github.io/portfolio/screen-shot.jpg\\">\\n    <meta property=\\"og:type\\" content=\\"website\\">\\n    <meta property=\\"og:site_name\\" content=\\"Portfolio on GitHub Pages\\">\\n    <meta name=\\"twitter:card\\" content=\\"summary_large_image\\" />\\n    <meta name=\\"twitter:site\\" content=\\"@sou_0x0v\\" />\\n\\n    \x3c!-- CSS --\x3e\\n    <link rel=\\"preload\\" href=\\"https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900\\" as=\\"style\\">\\n    <link rel=\\"stylesheet\\" href=\\"https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900\\" media=\\"print\\" onload=\\"this.media=\'all\'\\">\\n    <link rel=\\"preload\\" href=\\"https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css\\" as=\\"style\\">\\n    <link rel=\\"stylesheet\\" href=\\"https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css\\" media=\\"print\\" onload=\\"this.media=\'all\'\\">\\n  </head>\\n  <body>\\n    <noscript>\\n      <strong>We\'re sorry but Sou\'s Portfolio doesn\'t work properly without JavaScript enabled. Please enable it to continue.</strong>\\n    </noscript>\\n    <div id=\\"app\\"></div>\\n    \x3c!-- built files will be auto injected --\x3e\\n  </body>\\n</html>\\n"]},"src":{"App.vue":["txt","<template>\\n  <v-app id=\\"inspire\\">\\n    <v-navigation-drawer\\n      app\\n      expand-on-hover\\n      width=\\"56\\"\\n    >\\n      <v-list shaped>\\n        <v-list-item\\n          v-for=\\"item in items\\"\\n          :key=\\"item.title\\"\\n          @click=\\"$vuetify.goTo(item.link, {duration: 500})\\"\\n          link\\n        >\\n          <v-list-item-icon>\\n            <v-icon>{{ item.icon }}</v-icon>\\n          </v-list-item-icon>\\n          <v-list-item-content>\\n            <v-list-item-title>{{ item.title }}</v-list-item-title>\\n          </v-list-item-content>\\n        </v-list-item>\\n      </v-list>\\n    </v-navigation-drawer>\\n\\n    <v-main>\\n      <AppAbout/>\\n      <AppSkills/>\\n      <AppWorks/>\\n      <AppContests/>\\n      <AppFooter/>\\n    </v-main>\\n  </v-app>\\n</template>\\n\\n<script>\\nimport AppAbout from \\"./components/AppAbout\\";\\nimport AppSkills from \\"./components/AppSkills\\";\\nimport AppWorks from \\"./components/AppWorks\\";\\nimport AppContests from \\"./components/AppContests\\";\\nimport AppFooter from \\"./components/AppFooter\\";\\n\\nexport default {\\n  name: \\"App\\",\\n\\n  components: {\\n    AppAbout,\\n    AppSkills,\\n    AppWorks,\\n    AppContests,\\n    AppFooter\\n  },\\n\\n  data () {\\n    return {\\n      drawer: false,\\n      items: [\\n        { title: \\"About\\", icon: \\"mdi-console\\" },\\n        { title: \\"Skills\\", icon: \\"mdi-xml\\" },\\n        { title: \\"Works\\", icon: \\"mdi-hexagon-multiple\\" },\\n        { title: \\"Contests\\", icon: \\"mdi-medal-outline\\" },\\n      ],\\n    }\\n  },\\n\\n  created() {\\n    this.items.forEach(item => {\\n      item.link = `#${item.title.toLowerCase()}`;\\n    });\\n  },\\n}\\n<\/script>\\n"],"assets":{},"components":{"AppAbout.vue":["txt","<template>\\r\\n  <v-container id=\\"about\\">\\r\\n    <v-row class=\\"text-center\\">\\r\\n      <v-col cols=\\"12\\">\\r\\n        <v-img\\r\\n          :aspect-ratio=\\"1/1\\"\\r\\n          :src=\\"icon_image\\"\\r\\n          :lazy-src=\\"icon_image_lazy\\"\\r\\n          class=\\"rounded-circle\\"\\r\\n          width=\\"500px\\"\\r\\n          style=\\"display: block; margin: auto;\\"\\r\\n        />\\r\\n      </v-col>\\r\\n\\r\\n      <v-col class=\\"mb-3\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold mb-2\\">\\r\\n          Sou Ishihara\\r\\n        </h1>\\r\\n\\r\\n        <p class=\\"subheading font-weight-regular\\">\\r\\n          ã‚²ãƒ¼ãƒ ã‚„Webã‚¢ãƒ—ãƒªã‚’ä½œã£ã¦ã„ã¾ã™\\r\\n          <br>ã‚ˆãå¯ã¾ã™\\r\\n        </p>\\r\\n      </v-col>\\r\\n\\r\\n      \x3c!-- outlines --\x3e\\r\\n\\r\\n      \x3c!-- æœ€å¾Œã®è¦ç´ ã ã‘ last-item ã‚¯ãƒ©ã‚¹ã‚’ä»˜ã‘ã‚‹  --\x3e\\r\\n      <v-col\\r\\n        cols=\\"12\\"\\r\\n        v-for=\\"(outline, index) in outlines\\"\\r\\n        :key=\\"outline.title\\"\\r\\n        :class=\\"{ \'last-item\': index == outlines.length - 1 }\\"\\r\\n      >\\r\\n        <h2 class=\\"headline font-weight-bold mb-3\\">\\r\\n          {{ outline.title }}\\r\\n        </h2>\\r\\n        <v-row justify=\\"center\\">\\r\\n          <p class=\\"subheading font-weight-regular\\">\\r\\n            <label\\r\\n              v-for=\\"item in outline.items\\"\\r\\n              :key=\\"item\\"\\r\\n              class=\\"mx-3\\"\\r\\n            >\\r\\n              {{ item }}\\r\\n            </label>\\r\\n          </p>\\r\\n        </v-row>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n    <v-divider></v-divider>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nimport isWebpSupported from \\"./isWebpSupported\\"\\r\\n\\r\\nexport default {\\r\\n  name: \\"AppAbout\\",\\r\\n\\r\\n  computed: {\\r\\n    format () {\\r\\n      return isWebpSupported ? \\"webp\\" : \\"jpg\\"\\r\\n    }\\r\\n  },\\r\\n\\r\\n  created() {\\r\\n    this.icon_image = require(`@/assets/icon-high.${this.format}`);\\r\\n    this.icon_image_lazy = require(`@/assets/icon.${this.format}`);\\r\\n  },\\r\\n\\r\\n  data: () => ({\\r\\n    icon_image: null,\\r\\n    icon_image_lazy: null,\\r\\n    outlines: [\\r\\n      { title: \\"School\\", items: [\\"æ¾æ±Ÿå·¥æ¥­é«˜ç­‰å°‚é–€å­¦æ ¡ (ä¼‘å­¦ä¸­)\\"] },\\r\\n      { title: \\"Company\\", items: [\\"(æ ª)ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å¿œç”¨é€šä¿¡ç ”ç©¶æ‰€\\"] },\\r\\n      { title: \\"Editor\\", items: [\\"vscode\\"] },\\r\\n      { title: \\"Hobby / Likes\\", items: [\\"programming\\", \\"music (i/o)\\", \\"pixel art\\"] },\\r\\n    ]\\r\\n  }),\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n<style>\\r\\n  .last-item {\\r\\n    margin-bottom: 3rem;\\r\\n  }\\r\\n</style>"],"AppContests.vue":["txt","<template>\\r\\n  <v-container\\r\\n    id=\\"contests\\"\\r\\n    class=\\"text-center\\"\\r\\n  >\\r\\n    <v-row>\\r\\n      <v-col cols=\\"12\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold my-3\\">\\r\\n          <v-icon class=\\"display-2 pb-3\\">mdi-medal-outline</v-icon>\\r\\n          Contests\\r\\n        </h1>\\r\\n\\r\\n      </v-col>\\r\\n        <v-col\\r\\n          cols=\\"12\\"\\r\\n          v-for=\\"content in contents\\"\\r\\n          :key=\\"content.name\\"\\r\\n          class=\\"mb-3 \\"\\r\\n        >\\r\\n          <p\\r\\n            class=\\"text-subtitle-1 text-md-h6 text-lg-h6 text-xl-h4\\"\\r\\n            style=\\"margin: 0;\\"\\r\\n          >\\r\\n            {{ content.name }}\\r\\n          </p>\\r\\n          <p\\r\\n            v-if=\\"content.result\\"\\r\\n            class=\\"text-caption text-md-subtitle-1 text-lg-subtitle-1 text-xl-h6\\"\\r\\n            style=\\"margin-bottom: 0.5rem;\\"\\r\\n          >\\r\\n            {{ content.result }}\\r\\n          </p>\\r\\n          <p>\\r\\n            <a target=\\"_blank\\" :href=\\"content.link\\">\\r\\n              {{ content.link }}\\r\\n            </a>\\r\\n          </p>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nexport default {\\r\\n  name: \\"AppContests\\",\\r\\n\\r\\n  data() {\\r\\n    return {\\r\\n      contents: [\\r\\n        {\\r\\n          name: \\"ç¬¬30å› é«˜å°‚ãƒ—ãƒ­ã‚³ãƒ³ (2019)\\",\\r\\n          result: \\"ã‚µãƒ–ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦å‚åŠ \\",\\r\\n          link: \\"https://www.procon.gr.jp/?cat=1661\\"\\r\\n        },\\r\\n        {\\r\\n          name: \\"ä¸­é«˜ç”Ÿå›½éš›Rubyãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚³ãƒ³ãƒ†ã‚¹ãƒˆ 2020\\",\\r\\n          result: \\"ã‚²ãƒ¼ãƒ éƒ¨é–€ æœ€å„ªç§€è³\\",\\r\\n          link: \\"https://www.ruby-procon.net/\\"\\r\\n        },\\r\\n        {\\r\\n          name: \\"ç¬¬32å› é«˜å°‚ãƒ—ãƒ­ã‚³ãƒ³ (2020)\\",\\r\\n          result: \\"ç‰¹åˆ¥è³ / ã‚µãƒ–ãƒ¡ãƒ³ãƒãƒ¼ã¨ã—ã¦å‚åŠ \\",\\r\\n          link: \\"https://www.procon.gr.jp/?cat=1680\\"\\r\\n        },\\r\\n        {\\r\\n          name: \\"æŠ€è‚²å±•2021 ç™»å£‡\\",\\r\\n          link: \\"https://talent.supporterz.jp/geekten/2021/\\"\\r\\n        },\\r\\n      ]\\r\\n    }\\r\\n  },\\r\\n}\\r\\n<\/script>\\r\\n"],"AppFooter.vue":["txt","<template>\\r\\n  <v-footer padless>\\r\\n    <v-card\\r\\n      width=\\"100%\\"\\r\\n      class=\\"text-center\\"\\r\\n      color=\\"blue-grey darken-1\\"\\r\\n      flat\\r\\n      tile\\r\\n    >\\r\\n      <v-card-text>\\r\\n        <v-btn\\r\\n          v-for=\\"account in accounts\\"\\r\\n          :key=\\"account.title\\"\\r\\n          :href=\\"account.link\\"\\r\\n          class=\\"mx-4\\"\\r\\n          icon\\r\\n        >\\r\\n          <v-icon\\r\\n            size=\\"36px\\"\\r\\n            color=\\"white\\"\\r\\n          >\\r\\n            {{ account.icon }}\\r\\n          </v-icon>\\r\\n        </v-btn>\\r\\n      </v-card-text>\\r\\n\\r\\n      <v-card-text>\\r\\n        <span class=\\"white--text\\">\\r\\n          Copyright &copy; 2022 Sou Ishihara\\r\\n        </span>\\r\\n      </v-card-text>\\r\\n    </v-card>\\r\\n  </v-footer>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nexport default {\\r\\n  name: \\"AppFooter\\",\\r\\n\\r\\n  data () {\\r\\n    return {\\r\\n      accounts: [\\r\\n        { title: \\"twitter\\", icon: \\"mdi-twitter\\", link: \\"https://twitter.com/sou_0x0v\\" },\\r\\n        { title: \\"github\\", icon: \\"mdi-github\\", link: \\"https://github.com/stonesaw\\" },\\r\\n        { title: \\"mail\\", icon: \\"mdi-email\\", link: \\"mailto:mail.sou.dev@gmail.com\\" },\\r\\n      ]\\r\\n    }\\r\\n  }\\r\\n}\\r\\n<\/script>"],"AppSkills.vue":["txt","<template>\\r\\n  <v-container id=\\"skills\\">\\r\\n    <v-row class=\\"text-center\\">\\r\\n      <v-col cols=\\"12\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold my-3\\">\\r\\n          <v-icon class=\\"display-2 pb-3\\">mdi-xml</v-icon>\\r\\n          Skills\\r\\n        </h1>\\r\\n\\r\\n        <v-container class=\\"mb-5\\">\\r\\n          <v-row>\\r\\n            <v-col\\r\\n              cols=\\"12\\" sm=\\"6\\" md=\\"6\\" lg=\\"4\\" xl=\\"4\\"\\r\\n              v-for=\\"language in languages\\"\\r\\n              :key=\\"language.name\\"\\r\\n            >\\r\\n              <SkillsCard\\r\\n                :name=\\"language.name\\"\\r\\n                :icon=\\"language.icon\\"\\r\\n                :color=\\"language.color\\"\\r\\n                :libs=\\"language.libs\\"\\r\\n              />\\r\\n            </v-col>\\r\\n          </v-row>\\r\\n        </v-container>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n    <v-divider></v-divider>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nimport SkillsCard from \\"./SkillsCard\\"\\r\\n\\r\\nexport default {\\r\\n  name: \\"AppSkills\\",\\r\\n\\r\\n  components: {\\r\\n    SkillsCard\\r\\n  },\\r\\n\\r\\n  data: () => ({\\r\\n    languages: [\\r\\n      {\\r\\n        name: \\"Ruby\\",\\r\\n        icon: \\"mdi-language-ruby\\",\\r\\n        // color usage\\r\\n        // ref https://vuetifyjs.com/ja/styles/colors/#section-30de30c630ea30a230eb30ab30e930fc\\r\\n        color: \\"red accent-1\\",\\r\\n        libs: [\\r\\n          \\"Rails\\", \\"RSpec\\", \\"Minitest\\", \\"DXRuby\\", \\"CLI\\", \\"RuboCop\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"HTML/CSS\\",\\r\\n        icon: \\"mdi-language-html5\\",\\r\\n        color: \\"orange darken-2\\",\\r\\n        libs: [\\r\\n          \\"HTML5\\", \\"CSS3\\", \\"Tailwind\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"JavaScript\\",\\r\\n        icon: \\"mdi-language-javascript\\",\\r\\n        color: \\"amber lighten-2\\",\\r\\n        libs: [\\r\\n          \\"Vue.js\\", \\"Vuetify\\", \\"npm\\", \\"yarn\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"TypeScript\\",\\r\\n        icon: \\"mdi-language-typescript\\",\\r\\n        color: \\"blue darken-2\\",\\r\\n        libs: [\\r\\n          \\"MIDI\\", \\"Next.js\\", \\"Chakra UI\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"Python\\",\\r\\n        color: \\"blue lighten-2\\",\\r\\n        icon: \\"mdi-language-python\\",\\r\\n        libs: [\\r\\n          \\"Pillow\\", \\"Discord.py\\", \\"Pygame\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"C++\\",\\r\\n        color: \\"indigo lighten-2\\",\\r\\n        icon: \\"mdi-language-cpp\\",\\r\\n        libs: [\\r\\n          \\"AtCoder\\", \\"DxLib\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"Git\\",\\r\\n        icon: \\"mdi-git\\",\\r\\n        color: \\"deep-orange accent-2\\",\\r\\n        libs: [\\r\\n          \\"Basic\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"GitHub\\",\\r\\n        icon: \\"mdi-github\\",\\r\\n        color: \\"grey darken-4\\",\\r\\n        libs: [\\r\\n          \\"Actions\\"\\r\\n        ]\\r\\n      },\\r\\n    ]\\r\\n  }),\\r\\n}\\r\\n<\/script>\\r\\n"],"AppWorks.vue":["txt","<template>\\r\\n  <v-container id=\\"works\\">\\r\\n    <v-row>\\r\\n      <v-col cols=\\"12\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold text-center my-3\\">\\r\\n          <v-icon class=\\"display-2 pb-3\\">mdi-hexagon-multiple</v-icon>\\r\\n          Works\\r\\n        </h1>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n\\r\\n    <v-row style=\\"padding: 0 7% 3rem 7%\\">\\r\\n      <v-col\\r\\n        cols=\\"12\\" xs=\\"12\\" sm=\\"6\\" md=\\"6\\" lg=\\"4\\" xl=\\"3\\"\\r\\n        v-for=\\"work in works\\"\\r\\n        :key=\\"work.title\\"\\r\\n      >\\r\\n        <v-hover v-slot=\\"{ hover }\\">\\r\\n          <v-card height=\\"100%\\">\\r\\n            <v-img\\r\\n              :src=\\"work.thumbnail || default_thumbnail\\"\\r\\n              :lazy-src=\\"work.thumbnail_lazy || default_thumbnail_lazy\\"\\r\\n              width=\\"100%\\"\\r\\n              :aspect-ratio=\\"16/9\\"\\r\\n            ></v-img>\\r\\n\\r\\n            <v-card-title class=\\"pt-3\\">\\r\\n              {{ work.title }}\\r\\n            </v-card-title>\\r\\n            <v-card-subtitle class=\\"pb-0\\">\\r\\n              {{ work.subtitle }}\\r\\n            </v-card-subtitle>\\r\\n\\r\\n            <v-chip-group column style=\\"padding: 3px 10px\\">\\r\\n              <v-chip\\r\\n                v-for=\\"lib in work.libs\\"\\r\\n                :key=\\"lib\\"\\r\\n                outlined\\r\\n                :ripple=\\"false\\"\\r\\n              >\\r\\n                {{ lib }}\\r\\n              </v-chip>\\r\\n            </v-chip-group>\\r\\n\\r\\n            <v-fade-transition>\\r\\n              <v-overlay v-if=\\"hover\\" absolute color=\\"#555\\">\\r\\n                <v-btn :href=\\"work.github\\" target=\\"_blank\\">\\r\\n                  <v-icon left>mdi-github</v-icon>\\r\\n                  github\\r\\n                </v-btn>\\r\\n              </v-overlay>\\r\\n            </v-fade-transition>\\r\\n          </v-card>\\r\\n        </v-hover>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n\\r\\n    <v-divider></v-divider>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nimport isWebpSupported from \\"./isWebpSupported\\"\\r\\n\\r\\nexport default {\\r\\n  name: \\"AppWorks\\",\\r\\n\\r\\n  computed: {\\r\\n    format () {\\r\\n      return isWebpSupported ? \\"webp\\" : \\"jpg\\"\\r\\n    }\\r\\n  },\\r\\n\\r\\n  methods: {\\r\\n    format_file_name (file_name) {\\r\\n      if (isWebpSupported) {\\r\\n        return file_name.replace(/\\\\.jpg$/, \\".webp\\");\\r\\n      } else {\\r\\n        return file_name;\\r\\n      }\\r\\n    }\\r\\n  },\\r\\n\\r\\n  created() {\\r\\n    this.default_thumbnail = require(`@/assets/icon-high.${this.format}`);\\r\\n    this.default_thumbnail_lazy = require(`@/assets/icon.${this.format}`);\\r\\n\\r\\n    this.works.forEach(work => {\\r\\n      if (work.thumbnail) {\\r\\n        work.thumbnail = require(\\"../assets/\\" + this.format_file_name(work.thumbnail));\\r\\n      }\\r\\n      if (work.thumbnail_lazy) {\\r\\n        work.thumbnail_lazy = require(\\"../assets/\\" + this.format_file_name(work.thumbnail_lazy));\\r\\n      }\\r\\n    });\\r\\n  },\\r\\n\\r\\n  data: () => ({\\r\\n    default_thumbnail: null,\\r\\n    default_thumbnail_lazy: null,\\r\\n\\r\\n    works: [\\r\\n      {\\r\\n        title: \\"Portfolio\\",\\r\\n        subtitle: \\"ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã‚µã‚¤ãƒˆã€‚Vue.js ã¨ Vuetify ã‚’ä½¿ç”¨\\",\\r\\n        thumbnail: \\"portfolio.jpg\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Vue.js\\", \\"Vuetify\\"],\\r\\n        github: \\"https://github.com/stonesaw/portfolio\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"Spell Out\\",\\r\\n        subtitle: \\"åŸºæœ¬ãƒã‚¦ã‚¹ã®ã¿ã® ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã€‚Rubyã§ã‚¼ãƒ­ã‹ã‚‰é–‹ç™º\\",\\r\\n        thumbnail: \\"spell-out.jpg\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Ruby\\", \\"DXRuby\\", \\"RuboCop\\"],\\r\\n        github: \\"https://github.com/stonesaw/Spell-Out\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"cli\\",\\r\\n        subtitle: \\"ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³é¢¨ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ª\\",\\r\\n        thumbnail: \\"cli.png\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Vue.js\\", \\"TypeScript\\", \\"Jest\\"],\\r\\n        github: \\"https://github.com/stonesaw/cli\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"Jumping Ichiyo\\",\\r\\n        subtitle: \\"ichiyoã‚’æ•°å¼ã§å‹•ã‹ã™ãƒœãƒƒãƒˆ from é™ç•Œé–‹ç™ºé¯– (ãƒã‚¿)\\",\\r\\n        thumbnail: \\"jump-resize.gif\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Python\\", \\"Discord.py\\", \\"Pillow\\"],\\r\\n        github: \\"https://github.com/stonesaw/jumping-ichiyo\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"Ruby CUI Game\\",\\r\\n        subtitle: \\"å­¦æ ¡ã®æ˜¥ä¼‘ã¿èª²é¡Œã§ä½œã£ãŸã‚‚ã®ã€‚CUIç”¨ã®ã‚²ãƒ¼ãƒ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰ä½œã£ãŸ\\",\\r\\n        thumbnail: \\"cli-mario.png\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Ruby\\", \\"CLI\\"],\\r\\n        github: \\"https://github.com/stonesaw/Ruby-CUI-game\\",\\r\\n      },\\r\\n    ],\\r\\n  }),\\r\\n};\\r\\n<\/script>\\r\\n"],"SkillsCard.vue":["txt","<template>\\r\\n  <v-container>\\r\\n    <v-hover v-slot=\\"{ hover }\\">\\r\\n      <v-row>\\r\\n        <v-col cols=\\"5\\">\\r\\n          <div v-if=\\"hover\\">\\r\\n            <v-icon\\r\\n              :color=\\"color\\"\\r\\n              size=\\"64\\"\\r\\n            >{{ icon }}</v-icon>\\r\\n            <p\\r\\n              class=\\"text-overline\\"\\r\\n              :class=\\"color_text\\"\\r\\n              style=\\"margin: 0;\\"\\r\\n            >{{ name }}</p>\\r\\n          </div>\\r\\n          <div v-else>\\r\\n            <v-icon\\r\\n              size=\\"64\\"\\r\\n            >{{icon}}</v-icon>\\r\\n            <p\\r\\n              class=\\"text-overline\\"\\r\\n              style=\\"margin: 0;\\"\\r\\n            >{{ name }}</p>\\r\\n          </div>\\r\\n        </v-col>\\r\\n        <v-col cols=\\"7\\">\\r\\n          <v-chip-group column>\\r\\n            <v-chip\\r\\n              v-for=\\"lib in libs\\"\\r\\n              :key=\\"lib\\"\\r\\n              outlined\\r\\n              :ripple=\\"false\\"\\r\\n            >\\r\\n              {{ lib }}\\r\\n            </v-chip>\\r\\n          </v-chip-group>\\r\\n        </v-col>\\r\\n      </v-row>\\r\\n    </v-hover>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nexport default {\\r\\n  name: \\"SkillsCard\\",\\r\\n\\r\\n  props: {\\r\\n    name: String,\\r\\n    icon: String,\\r\\n    color: String,\\r\\n    libs: Array,\\r\\n  },\\r\\n\\r\\n  created() {\\r\\n    const ary = this.color.split(\\" \\");\\r\\n    if (ary.length >= 3) {\\r\\n      console.error(\\"wrong languages.color format!\\");\\r\\n      return;\\r\\n    }\\r\\n    if (ary[0]) { this.color_text = `${ary[0]}--text`; }\\r\\n    if (ary[1]) { this.color_text += ` text--${ary[1]}`; }\\r\\n  }\\r\\n}\\r\\n<\/script>\\r\\n"],"isWebpSupported.js":["txt","const canUseWebP = () => {\\r\\n    const elem = document.createElement(\\"canvas\\")\\r\\n    if (elem.getContext && elem.getContext(\\"2d\\")) {\\r\\n        // Canvasã‹ã‚‰WebPã‚’å‡ºåŠ›ã—ã¦ã€çµæœãŒdata:image/webpã§å§‹ã¾ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\\r\\n        return elem.toDataURL(\\"image/webp\\").indexOf(\\"data:image/webp\\") === 0\\r\\n    }\\r\\n    // Canvasè‡ªä½“ãŒä½¿ãˆãªã‘ã‚Œã°éå¯¾å¿œæ‰±ã„ã«ã™ã‚‹\\r\\n    return false\\r\\n}\\r\\n\\r\\n// æœ€åˆã«ä¸€åº¦ã ã‘åˆ¤å®šã—ã¦çµæœã‚’export\\r\\nexport default canUseWebP()\\r\\n"]},"main.js":["txt","import Vue from \\"vue\\"\\r\\nimport App from \\"./App.vue\\"\\r\\nimport vuetify from \\"./plugins/vuetify\\"\\r\\n\\r\\nVue.config.productionTip = false\\r\\n\\r\\nnew Vue({\\r\\n  vuetify,\\r\\n  render: h => h(App)\\r\\n}).$mount(\\"#app\\")\\r\\n"],"plugins":{"vuetify.js":["txt","import Vue from \'vue\';\\nimport Vuetify from \'vuetify/lib/framework\';\\n\\nVue.use(Vuetify);\\n\\nexport default new Vuetify({\\n});\\n"]}},"vue.config.js":["txt","const { defineConfig } = require(\\"@vue/cli-service\\")\\nmodule.exports = defineConfig({\\n  transpileDependencies: [\\n    \\"vuetify\\"\\n  ],\\n  publicPath: \\"./\\"\\n})\\n"],"repo.link":["link","https://github.com/stonesaw/portfolio"]},"Spell-Out":{"assets":{},"sound":{},"how-to.md":["txt","## å®Ÿè¡Œ\\r\\n```\\r\\ngem install dxruby\\r\\nruby main.rb\\r\\n``` \\r\\n\\r\\n\\r\\n## ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢\\r\\n- [Play] ã‚’ ã‚¯ãƒªãƒƒã‚¯ ã¾ãŸã¯ æ–¹å‘ã‚­ãƒ¼ã¨ã‚¨ãƒ³ã‚¿ãƒ¼ã‚­ãƒ¼ ã§é¸æŠã™ã‚‹ã¨ãƒ—ãƒ¬ã‚¤ç”»é¢ã«ç§»å‹•ã—ã¾ã™\\r\\n- [Credit] ã¯ä½œã£ã¦ã„ã¾ã›ã‚“ ( [Play]ã¨åŒã˜å‹•ä½œã«ãªã‚Šã¾ã™ )\\r\\n- [Exit] ã‚’é¸æŠã™ã‚‹ã¨ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¾ã™\\r\\n\\r\\n\\r\\n## ãƒ—ãƒ¬ã‚¤ç”»é¢\\r\\n### æ“ä½œæ–¹æ³•\\r\\n- ãƒã‚¦ã‚¹ãƒã‚¤ãƒ³ã‚¿ã®æ–¹å‘ã«ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒç§»å‹•ã—ã¾ã™\\r\\n- å¼¾ã¯è‡ªå‹•ã§ç™ºå°„ã•ã‚Œã¾ã™\\r\\n- [ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ« or Z/X] ã§ Spell(å±æ€§) ãŒå¤‰ã‚ã‚Šã¾ã™\\r\\n- [å³ã‚¯ãƒªãƒƒã‚¯é•·æŠ¼ã—] ã§ã€ãƒãƒ£ãƒ¼ã‚¸æ”»æ’ƒãŒå‡ºæ¥ã¾ã™\\r\\n- (ãƒãƒ£ãƒ¼ã‚¸æ™‚é–“ã¯ Spell ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™)\\r\\n\\r\\n- [Tab] ã‚’æŠ¼ã™ã¨ ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ ã«é£›ã³ã¾ã™\\r\\n\\r\\n\\r\\n## ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢\\r\\n- æ“ä½œæ–¹æ³•ã®ç¢ºèªã¨éŸ³é‡èª¿ç¯€ãŒã§ãã¾ã™\\r\\n- éŸ³é‡ã¯ BGMãƒ»SE ã¨ã‚‚ã«ã‚·ãƒ¼ã‚¯ãƒãƒ¼ã‹ã‚‰å¤‰æ›´ã§ãã¾ã™\\r\\n- [Tab] ã‚’æŠ¼ã™ã“ã¨ã§ ãƒ—ãƒ¬ã‚¤ç”»é¢ ã«æˆ»ã‚Šã¾ã™\\r\\n\\r\\n\\r\\n## ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆç”»é¢\\r\\n- æœ€åˆã®ã‚¹ãƒ†ãƒ¼ã‚¸ (1-1) ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹ã¨ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆç”»é¢ã«ç§»å‹•ã—ã¾ã™ \\r\\n- ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã§ã¯ã€\\r\\n\\r\\n\\r\\n## ãƒªã‚¶ãƒ«ãƒˆç”»é¢\\r\\n- ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’æœ€å¾Œ (1-6) ã¾ã§ã‚¯ãƒªã‚¢ã™ã‚‹ or ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ©ã‚¤ãƒ•ãŒ0ã«ãªã‚‹ã¨ ãƒªã‚¶ãƒ«ãƒˆç”»é¢ã¸ç§»å‹•ã—ã¾ã™\\r\\n- ãƒªã‚¶ãƒ«ãƒˆç”»é¢ã§ã¯ã€åå‰ã‚’å…¥åŠ›ã™ã‚‹ã“ã¨ã§ã‚¹ã‚³ã‚¢ã‚’è¨˜éŒ²ã§ãã¾ã™\\r\\n- (å€‹äººçš„ã«ã¯ç„¡åŠ¹ãªåå‰ã‚’å…¥åŠ›ã—ãŸã¨ãã«å‡ºã‚‹ã‚¨ãƒ©ãƒ¼ã®æ„Ÿã˜ãŒãŠæ°—ã«å…¥ã‚Š)\\r\\n\\r\\n\\r\\n## ãƒ©ãƒ³ã‚­ãƒ³ã‚°\\r\\n- ãƒªã‚¶ãƒ«ãƒˆç”»é¢ã§å…¥åŠ›ã—ãŸåå‰ ã‚¹ã‚³ã‚¢ ã‚¯ãƒªã‚¢ã—ãŸæ—¥ä»˜ ãŒè¡¨ç¤ºã•ã‚Œã¾ã™\\r\\n- [Enter] ã§ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ ã¸æˆ»ã‚Šã¾ã™\\r\\n\\r\\n\\r\\n## ãŠã¾ã‘\\r\\n- é–‹ç™ºç”¨ã« ãƒ—ãƒ¬ã‚¤ç”»é¢ã§ [F12] ã‚’æŠ¼ã™ã¨å¼·åˆ¶çš„ã«ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢å‡ºæ¥ã¾ã™\\r\\n- ãƒ—ãƒ¬ã‚¤ç”»é¢ã§ [F5] ã‚’æŠ¼ã™ã¨ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ãŒ ON ã«ãªã‚Šã€ãƒ‡ãƒãƒƒã‚°ã®å‡ºåŠ›ã‚’è¦‹ã‚Œã¾ã™\\r\\n- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã§ [ã‚¯ãƒªãƒƒã‚¯ or ã‚¹ãƒšãƒ¼ã‚¹] ã§ã‚¿ã‚¤ãƒˆãƒ«ã®è‰²ãŒå¤‰ã‚ã‚Šã¾ã™\\r\\n\\r\\n## exeåŒ–\\r\\n```\\r\\ngem install ocra\\r\\nocra --windows main.rb assets\\r\\nren main.exe \\"Spell-Out.exe\\"\\r\\n```\\r\\n\\r\\nhttp://mirichi.github.io/dxruby-doc/tips/ocra.html\\r\\n"],"lib":{"bullet.rb":["txt","class Bullet < Sprite\\r\\n  attr_accessor :spell, :attack, :anime, :is_anime, :_anime_cnt, :direction\\r\\n  attr_reader :data, :spawn_tick\\r\\n\\r\\n  def initialize(data, x, y)\\r\\n    @data = data.clone\\r\\n    @data.var = JSON.parse(data.var.to_json)\\r\\n    super(x, y, @data.image)\\r\\n    @direction = Play.player.direction\\r\\n    @anime = @data.anime\\r\\n    @spell = @data.spell\\r\\n    @attack = @data.attack\\r\\n    @_anime_cnt = 0\\r\\n    @spawn_tick = Play.tick\\r\\n\\r\\n    @data.spawned(self)\\r\\n    self.class.list << self\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def _anime_next\\r\\n    @_anime_cnt = (@_anime_cnt + 1) % @anime.length\\r\\n    @image = @anime[@_anime_cnt]\\r\\n    self.image = @image\\r\\n  end\\r\\n\\r\\n\\r\\n  @list = []\\r\\n  class << self\\r\\n    attr_reader :list\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @list.each do |bullet|\\r\\n      bullet.data.lived(bullet)\\r\\n\\r\\n      if !((-500..Window.width + 500).include?(bullet.x) &&\\r\\n           (-500..Window.height + 500).include?(bullet.y))\\r\\n        bullet.vanish\\r\\n      end\\r\\n    end\\r\\n    Sprite.clean(@list)\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @list.each do |bullet|\\r\\n      bullet.draw unless bullet.data.is_draw_after\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw_after\\r\\n    @list.each do |bullet|\\r\\n      bullet.draw if bullet.data.is_draw_after\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.reset\\r\\n    @list = []\\r\\n  end\\r\\n\\r\\n  def self._spell_color\\r\\n    {\\r\\n      fire: [255, 0, 0],\\r\\n      water: [55, 183, 230],\\r\\n      wind: [23, 255, 123],\\r\\n      holy: [249, 250, 212],\\r\\n      dark: [121, 73, 173],\\r\\n    }\\r\\n  end\\r\\nend\\r\\n"],"data":{"bullet_data.rb":["txt","# BulletDataã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹\\r\\nclass IBulletData < ISpriteData\\r\\n  attr_accessor :attack\\r\\n  attr_reader :is_draw_after\\r\\n\\r\\n  def initialize(spell, attack, image, anime: [], is_draw_after: false)\\r\\n    super(spell, image, anime)\\r\\n    @is_draw_after = is_draw_after\\r\\n    @attack = attack\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    super()\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    super()\\r\\n  end\\r\\nend\\r\\n\\r\\n# ãŸã‚æ”»æ’ƒã®ãƒ‡ãƒ¼ã‚¿\\r\\nclass BulletData\\r\\n  @list = {}\\r\\n  @charge_tick = {\\r\\n    fire: 60,\\r\\n    water: 60,\\r\\n    wind: 200,\\r\\n    holy: 80,\\r\\n    dark: 80,\\r\\n  }\\r\\n\\r\\n  class << self\\r\\n    attr_reader :list, :charge_tick\\r\\n  end\\r\\n\\r\\n  def self.load\\r\\n    _list_add_level1_bullet\\r\\n    @list[:level2_fire] = BulletFileLevel2.new\\r\\n    @list[:level2_water] = BulletWaterLevel2.new\\r\\n    @list[:level2_wind] = BulletWindLevel2.new\\r\\n    @list[:level2_holy] = BulletHolyLevel2.new\\r\\n    @list[:level2_dark] = @list[:level1_dark]\\r\\n  end\\r\\n\\r\\n  def self.spell_and_color\\r\\n    {\\r\\n      fire: [255, 0, 0],\\r\\n      water: [55, 183, 230],\\r\\n      wind: [23, 255, 123],\\r\\n      holy: [249, 250, 212],\\r\\n      dark: [121, 73, 173],\\r\\n    }\\r\\n  end\\r\\n\\r\\n  def self._list_add_level1_bullet\\r\\n    spell_and_color.each_pair do |spell, color|\\r\\n      list[:\\"level1_#{spell}\\"] = BulletLevel1.new(spell, color)\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_list_add_level1_bullet\\r\\nend\\r\\n\\r\\n\\r\\n# ãƒ¬ãƒ™ãƒ«1 å…¨å±æ€§\\r\\nclass BulletLevel1 < IBulletData\\r\\n  def self.new(spell, color)\\r\\n    super(spell, 10, Image.new(10, 10, color))\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.data.var[:speed] = 12\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    if self_.data.var[:next_vanish]\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:next_vanish] = false\\r\\n    end\\r\\n\\r\\n    if self_.data.var[:vanish_passed].nil?\\r\\n      self_.x += dx = self_.data.var[:speed] * Math.cos(self_.direction * Math::PI / 180.0)\\r\\n      self_.y += dy = self_.data.var[:speed] * Math.sin(self_.direction * Math::PI / 180.0)\\r\\n\\r\\n      is_hit_obj = (self_ === Play.stage.objects)\\r\\n      is_hit_enemies = (self_ === Enemy.list)\\r\\n      if is_hit_obj || is_hit_enemies\\r\\n        if is_hit_obj\\r\\n          self_.collision_enable = false\\r\\n        elsif is_hit_enemies\\r\\n          self_.data.var[:next_vanish] = true\\r\\n        end\\r\\n        self_.x -= dx * 0.5\\r\\n        self_.y -= dy * 0.5\\r\\n        self_.data.var[:vanish_passed] = 0\\r\\n        self_.image = Image.new(20, 20)\\r\\n      end\\r\\n    else\\r\\n      self_.data.var[:vanish_passed] += 1\\r\\n      count = self_.data.var[:vanish_passed]\\r\\n      self_.image = Image.new(10 + count, 10 + count, C_WHITE)\\r\\n      self_.x -= 0.5\\r\\n      self_.y -= 0.5\\r\\n      self_.alpha -= 15\\r\\n      self_.vanish if self_.alpha <= 15\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\n\\r\\n# ãƒ¬ãƒ™ãƒ«2 ãƒ•ã‚¡ã‚¤ã‚¢\\r\\nclass BulletFileLevel2 < IBulletData\\r\\n  def self.new\\r\\n    @images ||= (0..1).map do |i|\\r\\n      Image.load(\\"#{$PATH}/assets/image/fire#{i}.png\\").set_color_key(C_WHITE)\\r\\n    end\\r\\n    super(:fire, 50, @images[0], anime: @images)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.center_x = 64\\r\\n    self_.center_y = 128\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    player = Play.player\\r\\n    self_.x = player.x - 30 + player.image.width  * 0.4  * Math.cos(player.direction * Math::PI / 180.0)\\r\\n    self_.y = player.y - 50 + player.image.height * 0.35 * Math.sin(player.direction * Math::PI / 180.0)\\r\\n    self_.angle = player.direction + 90\\r\\n    self_.alpha -= 10 if passed_tick >= 80 - 25\\r\\n\\r\\n    self_._anime_next if passed_tick % 16 == 0\\r\\n\\r\\n    if self_.data.var[:hit_flag].nil?\\r\\n      unless self_.check(Enemy.list).empty?\\r\\n        self_.data.var[:hit_flag] = true\\r\\n      end\\r\\n    elsif self_.data.var[:hit_flag] == true\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:hit_flag] = false\\r\\n      self_.data.var[:cool_time] = 40\\r\\n    elsif self_.data.var[:hit_flag] == false\\r\\n      self_.data.var[:cool_time] -= 1\\r\\n      if self_.data.var[:cool_time] <= 0\\r\\n        self_.data.var[:hit_flag] = nil\\r\\n        self_.collision_enable = true\\r\\n      end\\r\\n    end\\r\\n\\r\\n    self_.vanish if passed_tick >= 80\\r\\n  end\\r\\nend\\r\\n\\r\\n# ãƒ¬ãƒ™ãƒ«2 æ°´\\r\\nclass BulletWaterLevel2 < IBulletData\\r\\n  def self.new\\r\\n    super(:water, 30, Image.new(32, 64, C_CYAN))\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.x = Play.player.x\\r\\n    self_.y = Play.player.y\\r\\n    self_.angle = Play.player.direction - 90\\r\\n    self_.data.var[:speed] = 12\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    if self_.data.var[:next_vanish]\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:next_vanish] = false\\r\\n    end\\r\\n\\r\\n    if self_.data.var[:vanish_passed].nil?\\r\\n      self_.x += dx = self_.data.var[:speed] * Math.cos(self_.direction * Math::PI / 180.0)\\r\\n      self_.y += dy = self_.data.var[:speed] * Math.sin(self_.direction * Math::PI / 180.0)\\r\\n\\r\\n      is_hit_obj = (self_ === Play.stage.objects)\\r\\n      is_hit_enemies = (self_ === Enemy.list)\\r\\n      if is_hit_obj || is_hit_enemies\\r\\n        if is_hit_obj\\r\\n          self_.collision_enable = false\\r\\n        elsif is_hit_enemies\\r\\n          self_.data.var[:next_vanish] = true\\r\\n        end\\r\\n        self_.x -= dx * 0.5\\r\\n        self_.y -= dy * 0.5\\r\\n        self_.data.var[:vanish_passed] = 0\\r\\n        self_.image = Image.new(20, 20)\\r\\n      end\\r\\n    else\\r\\n      self_.data.var[:vanish_passed] += 1\\r\\n      count = self_.data.var[:vanish_passed]\\r\\n      self_.image = Image.new(10 + count, 10 + count, C_WHITE)\\r\\n      self_.x -= 0.5\\r\\n      self_.y -= 0.5\\r\\n      self_.alpha -= 15\\r\\n      self_.vanish if self_.alpha <= 15\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\n\\r\\n# ãƒ¬ãƒ™ãƒ«2 é¢¨\\r\\nclass BulletWindLevel2 < IBulletData\\r\\n  def self.new\\r\\n    @images ||= [0].map do |i|\\r\\n      Image.load(\\"#{$PATH}/assets/image/recovery#{i}.png\\").set_color_key(C_WHITE)\\r\\n    end\\r\\n    super(:wind, 0, @images[0], anime: @images, is_draw_after: true)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    Play.player.life = [Play.player.life + 10, Play.player.max_life].min\\r\\n    self_.collision_enable = false # å½“ãŸã‚Šåˆ¤å®šã‚’ãªãã™\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    self_.x = Play.player.x + 10\\r\\n    self_.y = Play.player.y + 50\\r\\n\\r\\n    if (0..3).include?(passed_tick % 10)\\r\\n      self_.alpha = 0\\r\\n    else\\r\\n      self_.alpha = 200\\r\\n    end\\r\\n\\r\\n    self_._anime_next if passed_tick % 16 == 0\\r\\n\\r\\n    self_.vanish if passed_tick >= 80\\r\\n  end\\r\\nend\\r\\n\\r\\n\\r\\n# ãƒ¬ãƒ™ãƒ«2 å…‰\\r\\nclass BulletHolyLevel2 < IBulletData\\r\\n  def self.new\\r\\n    super(:holy, 0, Image.new(1, 1))\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.collision_enable = false\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n    if passed_tick % 10 == 0 && (0..50).include?(passed_tick)\\r\\n      Bullet.new(BulletHolyLevel2Child.new, Play.player.x, Play.player.y)\\r\\n    elsif passed_tick > 50\\r\\n      self_.vanish\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nclass BulletHolyLevel2Child < IBulletData\\r\\n  def self.new\\r\\n    @images ||= [Image.load(\\"#{$PATH}/assets/image/_holy0.png\\")]\\r\\n    super(:holy, 10, @images[0])\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.data.var[:speed] = 14\\r\\n\\r\\n    # TODO ã‚¹ãƒãƒ¼ãƒ³ã™ã‚‹ä½ç½®ã®èª¿æ•´\\r\\n    self_.angle = Play.player.direction + 90\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    self_.vanish if self_.data.var[:vanish]\\r\\n\\r\\n    self_.x += self_.data.var[:speed] * Math.cos(self_.direction * Math::PI / 180.0)\\r\\n    self_.y += self_.data.var[:speed] * Math.sin(self_.direction * Math::PI / 180.0)\\r\\n\\r\\n    if self_ === Enemy.list\\r\\n      self_.data.var[:vanish] = true\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"enemies_data.rb":["txt","class IEnemyData < ISpriteData\\r\\n  attr_accessor :name, :hp, :max_hp, :score, :direction, :exp\\r\\n\\r\\n  def initialize(name, spell, hp, score, exp, image, anime: [])\\r\\n    super(spell, image, anime)\\r\\n    @name   = name.to_s\\r\\n    @hp     = hp.to_i\\r\\n    @max_hp = hp.to_i\\r\\n    @score  = score.to_i\\r\\n    @exp    = exp.to_i\\r\\n    @direction = 0\\r\\n  end\\r\\n\\r\\n  def dead(self_)\\r\\n  end\\r\\nend\\r\\n\\r\\n# ã‚¹ãƒ©ã‚¤ãƒ \\r\\nclass Slime < IEnemyData\\r\\n  def initialize(name, spell, image, anime: [])\\r\\n    super(name, spell, 100, 10, 10, image, anime: anime)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.add_hp_bar(x: 0.7, y: 0.7)\\r\\n    self_.collision = [64, 100, 27]\\r\\n    self_.data.var[:speed] = 2\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    distance_x = self_.x - Play.player.x\\r\\n    distance_y = self_.y - Play.player.y\\r\\n    self_.data.direction = Math.atan2(distance_y, distance_x) * 180.0 / Math::PI\\r\\n    self_.data.direction = 360 + self_.data.direction if self_.data.direction < 0\\r\\n\\r\\n    obj = Play.stage.objects\\r\\n    self_.x -= dx = self_.data.var[:speed] * Math.cos(self_.data.direction * Math::PI / 180.0)\\r\\n    self_.x += dx * 2 unless self_.check(obj).empty?\\r\\n\\r\\n    self_.y -= dy = self_.data.var[:speed] * Math.sin(self_.data.direction * Math::PI / 180.0)\\r\\n    self_.y += dy * 2 unless self_.check(obj).empty?\\r\\n\\r\\n    self_.anime_next if passed_tick % 10 == 0\\r\\n\\r\\n    bullets = self_.check(Bullet.list)\\r\\n    unless bullets.empty?\\r\\n      SE.play(:slime)\\r\\n      self_.calc_hp(bullets[0])\\r\\n      # Bullet.list.delete(bullets[0]) # TODO: Bullet ã®å‰Šé™¤ : bullet_data ã«ç§»å‹•\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def dead(self_)\\r\\n    if self_.data.var[:count].nil?\\r\\n      SE.play(:retro04)\\r\\n      # $se_retro04.set_volume(255 * $volume)\\r\\n      $score += self_.data.score\\r\\n      Play.player.exp += self_.data.exp\\r\\n      Play.player.level = Play.player.exp / 50 # TODO: ãƒ¬ãƒ™ãƒ«ã®ã‚ã’æ–¹\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:count] = 0\\r\\n      self_.x += 64\\r\\n      self_.y += 100\\r\\n      self_.image = Image.new(20, 20, C_WHITE)\\r\\n    else\\r\\n      self_.data.var[:count] += 1\\r\\n      count = self_.data.var[:count]\\r\\n      self_.image = Image.new(20 + count, 20 + count, C_WHITE)\\r\\n      self_.x -= 0.5\\r\\n      self_.y -= 0.5\\r\\n      self_.alpha -= 7\\r\\n      self_.vanish if self_.alpha <= 7\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nclass SlimeWater < Slime\\r\\n  def self.new\\r\\n    @images ||= Image.load_tiles(\\"#{$PATH}/assets/image/slime.png\\", 3, 1)\\r\\n    super(\'æ°´ã‚¹ãƒ©ã‚¤ãƒ \', :water, @images[0], anime: @images)\\r\\n  end\\r\\nend\\r\\n\\r\\nclass SlimeWind < Slime\\r\\n  def self.new\\r\\n    @images ||= Image.load_tiles(\\"#{$PATH}/assets/image/slime2.png\\", 3, 1)\\r\\n    super(\'é¢¨ã‚¹ãƒ©ã‚¤ãƒ \', :wind, @images[0], anime: @images)\\r\\n  end\\r\\nend\\r\\n\\r\\n# ã‚´ãƒ¼ãƒ¬ãƒ \\r\\nclass Golem < IEnemyData\\r\\n  def self.new\\r\\n    @images ||= Image.load_tiles(\\"#{$PATH}/assets/image/Golem_stone.png\\", 6, 4)\\r\\n    golem_img = [@images[0], @images[1], @images[2]]\\r\\n    super(\'ã‚´ãƒ¼ãƒ¬ãƒ \', :dark, 500, 1000, 100, golem_img[0], anime: golem_img)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.add_hp_bar\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    self_.y += 2\\r\\n    self_.y = -200 if self_.y > Window.height\\r\\n\\r\\n    self_.anime_next if passed_tick % 10 == 0\\r\\n\\r\\n    bullets = self_.check(Bullet.list)\\r\\n    unless bullets.empty?\\r\\n      SE.play(:slime)\\r\\n      self_.calc_hp(bullets[0])\\r\\n      # Bullet.list.delete(bullets[0]) # TODO: Bullet ã®å‰Šé™¤ : bullet_data ã«ç§»å‹•\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def dead(self_)\\r\\n    SE.play(:retro04)\\r\\n    # $se_retro04.set_volume(255 * $volume)\\r\\n    $score += self_.data.score\\r\\n    Play.player.exp += self_.data.exp\\r\\n    Play.player.level = Play.player.exp / 50 # TODO: ãƒ¬ãƒ™ãƒ«ã®ã‚ã’æ–¹\\r\\n\\r\\n    self_.vanish\\r\\n  end\\r\\nend\\r\\n"],"sprite_data.rb":["txt","class ISpriteData\\r\\n  attr_accessor :spell, :var\\r\\n  attr_reader :image, :anime\\r\\n\\r\\n  def initialize(spell, image, anime)\\r\\n    @spell = spell.to_sym\\r\\n    @image = image\\r\\n    @anime = anime\\r\\n    @var = {}\\r\\n  end\\r\\n\\r\\n  def spawned\\r\\n  end\\r\\n\\r\\n  def lived\\r\\n  end\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :images\\r\\n  end\\r\\nend\\r\\n"],"stage_data.rb":["txt","class IWaveData\\r\\n  attr_reader :proc_begin, :proc_update, :proc_end\\r\\n  attr_accessor :field_image, :bg_image, :field_objects, :judge_flag, :spawn_tick\\r\\n\\r\\n  def initialize(bg_image, field_objects, use_judge_flag: false)\\r\\n    @bg_image = bg_image\\r\\n    @field_objects = field_objects\\r\\n    @proc_begin = proc {}\\r\\n    @proc_update = proc {}\\r\\n    @proc_end = proc {}\\r\\n    @judge_flag = use_judge_flag ? false : nil\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def when_begin(&block)\\r\\n    @spawn_tick = Play.tick\\r\\n    @proc_begin = block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def when_update(&block)\\r\\n    @proc_update = block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def when_end(&block)\\r\\n    @proc_end = block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def passed_tick\\r\\n    Play.tick - @spawn_tick\\r\\n  end\\r\\nend\\r\\n\\r\\nclass StageData\\r\\n  class << self\\r\\n    attr_accessor :list\\r\\n  end\\r\\n\\r\\n  def self.load(stage_name)\\r\\n    if /(?<chapter>\\\\d)-(?<section>\\\\d)/ =~ stage_name\\r\\n      send(:\\"load_#{chapter}_#{section}\\")\\r\\n    else\\r\\n      raise ArgumentError, \\"wrong stage_name (#{stage_name})\\"\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.load_1_1\\r\\n    bg = Image.new(Window.width, Window.height, [142, 199, 95])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, [\\r\\n      Sprite.new(200, 600, Image.new(50, 50, [70, 70, 70])),\\r\\n      Sprite.new(600, 200, Image.new(50, 50, [70, 70, 70])),\\r\\n    ]).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 100, 100)\\r\\n      end.\\r\\n      when_update do |wave|\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, [\\r\\n      Sprite.new(800, 400, Image.new(50, 50, [70, 70, 70])),\\r\\n    ]).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 100, 100)\\r\\n        Enemy.new(SlimeWind.new, 700, 100)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 100, 100)\\r\\n        Enemy.new(SlimeWind.new, 700, 100)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_2\\r\\n    bg = Image.new(Window.width, Window.height, [142, 199, 95])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 110)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 110)\\r\\n        Enemy.new(SlimeWater.new, 900, 350)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_3\\r\\n    bg = Image.new(Window.width, Window.height, [142, 199, 95])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWind.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 350)\\r\\n        Enemy.new(SlimeWater.new, 500, 70)\\r\\n        Enemy.new(SlimeWater.new, 700, 350)\\r\\n        Enemy.new(SlimeWater.new, 900, 70)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWater.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_4\\r\\n    bg = Image.new(Window.width, Window.height, [183, 212, 116])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n      end\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_5\\r\\n    bg = Image.new(Window.width, Window.height, [183, 212, 116])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWind.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 350)\\r\\n        Enemy.new(SlimeWater.new, 500, 70)\\r\\n        Enemy.new(SlimeWater.new, 700, 350)\\r\\n        Enemy.new(SlimeWater.new, 900, 70)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWater.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_6\\r\\n    bg = Image.new(Window.width, Window.height, [193, 201, 115])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, [], use_judge_flag: true).\\r\\n      when_update do |wave|\\r\\n        passed_tick = Play.tick - wave.spawn_tick\\r\\n\\r\\n        if passed_tick < 600 && passed_tick % 200 == 1\\r\\n          case passed_tick / 100\\r\\n          when 0\\r\\n            Enemy.new(Golem.new, Window.width * 0.5, -200)\\r\\n          when 2\\r\\n            Enemy.new(Golem.new, Window.width * 0.3, -200)\\r\\n          when 4\\r\\n            Enemy.new(Golem.new, Window.width * 0.7, -200)\\r\\n          end\\r\\n        end\\r\\n\\r\\n        if passed_tick % 300 == 299\\r\\n          Enemy.new(SlimeWind.new, 100 + rand(Window.width - 200), -100)\\r\\n        end\\r\\n\\r\\n        if passed_tick >= 600\\r\\n          exist_golelm = Enemy.list.map {|e| true if e.data.name == \'ã‚´ãƒ¼ãƒ¬ãƒ \' }\\r\\n          if exist_golelm.compact.empty?\\r\\n            wave.judge_flag = true\\r\\n          end\\r\\n        end\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\nend\\r\\n"]},"enemy.rb":["txt","class Enemy < Sprite\\r\\n  attr_reader :data, :spawn_tick\\r\\n  attr_accessor :hp_bar, :hp_bar_base\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :list\\r\\n    attr_reader :_spell_match, :_spell_miss\\r\\n  end\\r\\n\\r\\n  def self.reset\\r\\n    @list = []\\r\\n  end\\r\\n\\r\\n  def initialize(data, x, y)\\r\\n    @data = data.clone\\r\\n    @data.var = JSON.parse(data.var.to_json)\\r\\n    super(x, y, @data.image)\\r\\n    @anime = @data.anime\\r\\n    @_anime_count = 0\\r\\n    # @data.remove_instance_variable(:@image)\\r\\n    # @data.remove_instance_variable(:@anime)\\r\\n    @spawn_tick = Play.tick\\r\\n\\r\\n    # @data.proc_spawned.call(self)\\r\\n    @data.spawned(self)\\r\\n\\r\\n    self.class.list << self\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    # @data.proc_lived.call(self)\\r\\n    # @data.proc_dead.call(self) if data.hp <= 0\\r\\n    if @data.hp > 0\\r\\n      @data.lived(self)\\r\\n    else\\r\\n      @data.dead(self)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  # utils\\r\\n\\r\\n  def calc_hp(bullet)\\r\\n    boost = if spell_matching?(bullet)\\r\\n              2.0\\r\\n            elsif spell_missing?(bullet)\\r\\n              0.5\\r\\n            else\\r\\n              1.0\\r\\n            end\\r\\n    @data.hp = [0, @data.hp - bullet.attack * boost].max\\r\\n  end\\r\\n\\r\\n  def spell_matching?(bullet)\\r\\n    self.class._spell_match.each do |to, from|\\r\\n      if bullet.spell == to && @data.spell == from\\r\\n        return true\\r\\n      end\\r\\n    end\\r\\n    false\\r\\n  end\\r\\n\\r\\n  def spell_missing?(bullet)\\r\\n    self.class._spell_miss.each do |to, from|\\r\\n      if bullet.spell == to && @data.spell == from\\r\\n        return true\\r\\n      end\\r\\n    end\\r\\n    false\\r\\n  end\\r\\n\\r\\n  # TODO\\r\\n  def hit_check_field_objects()\\r\\n  end\\r\\n\\r\\n  def anime_next\\r\\n    @_anime_count = (@_anime_count + 1) % @anime.length\\r\\n    @image = @anime[@_anime_count]\\r\\n    self.image = @image\\r\\n  end\\r\\n\\r\\n  def add_hp_bar(x: 1, y: 1)\\r\\n    HPBar.enemy_hp_bar << {\\r\\n      enemy: self,\\r\\n      base: Image.new(x * (image.width * 0.9),    y * (image.height * 0.15), [240, 240, 240]),\\r\\n      bar: Image.new(x * (image.width * 0.9 - 4), y * (image.height * 0.15 - 4), [124, 224, 43]),\\r\\n    }\\r\\n  end\\r\\n\\r\\n  def add_boss_bar\\r\\n    HPBar.boss_hp_bar << {\\r\\n      enemy: self,\\r\\n      base: Image.new(image.width * 0.9, image.height * 0.1, [240, 240, 240]),\\r\\n      bar: Image.new(image.width * 0.9 - 4, image.height * 0.1 - 4, [124, 224, 43]),\\r\\n    }\\r\\n  end\\r\\n\\r\\n  # class method & variable\\r\\n\\r\\n  @list = []\\r\\n  @_spell_match = [\\r\\n    # [to, from] (bullet -> enemy)\\r\\n    [:fire, :wind],\\r\\n    [:wind, :water],\\r\\n    [:water, :fire],\\r\\n    [:holy, :dark],\\r\\n    [:dark, :holy],\\r\\n  ]\\r\\n  @_spell_miss = @_spell_match.map.with_index {|spells, i| spells.reverse if i < 3 }\\r\\n  @_spell_miss.compact!\\r\\nend\\r\\n"],"player.rb":["txt","class Player < Sprite\\r\\n  attr_accessor :spell, :max_life, :life, :images, :direction, :level, :exp\\r\\n  attr_reader :is_changed_spell, :speed\\r\\n\\r\\n  def initialize(spell, x, y, images)\\r\\n    super\\r\\n    self.x = x\\r\\n    self.y = y\\r\\n    @images = images\\r\\n    self.image = @images[0][0]\\r\\n    self.collision = [8, 36, 70, 112]\\r\\n\\r\\n    @spell = spell.to_sym\\r\\n    @spell_list = [:fire, :water, :wind, :holy, :dark]\\r\\n    @spell_num = @spell_list.index(@spell)\\r\\n    @max_life = 250\\r\\n    @life = 250\\r\\n    @level = 1\\r\\n    @exp = 0\\r\\n    @speed = 4\\r\\n    @direction = -90 # ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å‘ã„ã¦ã„ã‚‹æ–¹å‘ (ç”»åƒã®è§’åº¦ã§ã¯ãªã„)\\r\\n    @cool_time = 0\\r\\n    @is_changed_spell = false\\r\\n\\r\\n    @bullet_count = 0 # ãƒãƒ¬ãƒƒãƒˆ è‡ªå‹•ç™ºå°„ç”¨ã®ã‚«ã‚¦ãƒ³ãƒˆå¤‰æ•°\\r\\n    @anime_count = 0\\r\\n    @_mouse_down_count = 0\\r\\n    @_old_spell_num = @spell_num\\r\\n    @hit_tick = 0\\r\\n    @is_hit = false\\r\\n    @charge_percent = 0.0\\r\\n    @charge_circle_img = []\\r\\n    9.times do |i|\\r\\n      @charge_circle_img << Image.load(\\"#{$PATH}/assets/image/circle#{i}.png\\").\\r\\n        set_color_key(C_BLACK).\\r\\n        flush([200, 255, 255, 255]) # è‰²ã‚’å¤‰æ›´\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    # player controll\\r\\n    mx = Mouse.x\\r\\n    my = Mouse.y\\r\\n    ox = x + (image.width / 2)\\r\\n    oy = y + (image.height / 2)\\r\\n\\r\\n    # [å³ â†’ ã‹ã‚‰æ™‚è¨ˆå›ã‚Š][ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³]\\r\\n    @anime_count += 1 if Play.tick % 10 == 0\\r\\n    if (0..10).include?((ox - mx).abs) && (0..10).include?((oy - my).abs)\\r\\n      animation(1)\\r\\n    else\\r\\n      animation(@anime_count)\\r\\n      angle = Math.atan2(my - oy, mx - ox) * 180.0 / Math::PI\\r\\n      angle = 360 + angle if angle < 0\\r\\n      @direction = angle\\r\\n\\r\\n      obj = Play.stage.objects\\r\\n      self.x += dx = @speed * Math.cos(@direction * Math::PI / 180.0)\\r\\n      self.x -= dx unless check(obj).empty?\\r\\n\\r\\n      self.y += dy = @speed * Math.sin(@direction * Math::PI / 180.0)\\r\\n      self.y -= dy unless check(obj).empty?\\r\\n    end\\r\\n\\r\\n    self.x = [[0, self.x].max, Window.width - image.width].min\\r\\n    self.y = [[0, self.y].max, Window.height - image.height].min\\r\\n    # self.x = (Window.width - self.image.width) / 2\\r\\n    # self.y = (Window.height - self.image.height) / 2\\r\\n\\r\\n\\r\\n    # hit enemy\\r\\n    enemies = check(Enemy.list) # unless Enemy.list.empty?\\r\\n    if !enemies.empty? && !@is_hit\\r\\n      @life -= 50\\r\\n      @hit_tick = Play.tick\\r\\n      @is_hit = true\\r\\n      Enemy.list.delete(enemies[0]) if enemies[0].data.name != \'ã‚´ãƒ¼ãƒ¬ãƒ \'\\r\\n    end\\r\\n\\r\\n    if @hit_tick != 0 && Play.tick - @hit_tick < 180\\r\\n      self.alpha += 30\\r\\n    else\\r\\n      self.alpha = 255\\r\\n      @is_hit = false\\r\\n    end\\r\\n\\r\\n    # Input\\r\\n    # spell change\\r\\n    @is_changed_spell = !(@_old_spell_num == @spell_num)\\r\\n    @_old_spell_num = @spell_num\\r\\n    @spell_num -= Input.mouse_wheel_pos / 120\\r\\n    Input.mouse_wheel_pos = 0\\r\\n    @spell_num -= 1 if Input.key_push?(K_Z)\\r\\n    @spell_num += 1 if Input.key_push?(K_X)\\r\\n    @spell = @spell_list[@spell_num % @spell_list.length]\\r\\n\\r\\n    @charge_percent = 0.0 if @_old_spell_num != @spell_num\\r\\n    @cool_time -= 1\\r\\n\\r\\n    if @cool_time <= 0\\r\\n      if !Input.mouse_down?(1)\\r\\n        @bullet_count += 1\\r\\n        _fire_bullet if @bullet_count % 14 == 0\\r\\n      end\\r\\n\\r\\n      if @charge_percent >= 1.0 && Input.mouse_release?(1)\\r\\n        _fire_bullet(level: 2)\\r\\n        @_mouse_down_count = 0\\r\\n      end\\r\\n\\r\\n      if Input.mouse_down?(1)\\r\\n        @_mouse_down_count += 1\\r\\n        @_mouse_down_count = [@_mouse_down_count, BulletData.charge_tick[@spell]].min\\r\\n      else\\r\\n        @_mouse_down_count = 0\\r\\n      end\\r\\n\\r\\n      @charge_percent = @_mouse_down_count.to_f / BulletData.charge_tick[@spell]\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    super\\r\\n\\r\\n    # ãŸã‚æ”»æ’ƒã®ã‚²ãƒ¼ã‚¸\\r\\n    Window.draw(self.x - 20, self.y + 10,\\r\\n                @charge_circle_img[(@charge_percent * 8).to_i])\\r\\n  end\\r\\n\\r\\n  def animation(frame)\\r\\n    self.image = @images[((@direction + 23) % 360) / 45][frame % 3]\\r\\n  end\\r\\n\\r\\n  private def _fire_bullet(level: 1)\\r\\n    if level == 1\\r\\n      _x = self.x + (image.width * 0.5)  + image.width  * 0.4 * Math.cos(@direction * Math::PI / 180.0)\\r\\n      _y = self.y + (image.height * 0.6) + image.height * 0.4 * Math.sin(@direction * Math::PI / 180.0)\\r\\n      Bullet.new(BulletData.list[:\\"level1_#{@spell}\\"], _x, _y)\\r\\n    elsif level == 2\\r\\n      case @spell\\r\\n      when :holy\\r\\n        Bullet.new(BulletData.list[:level2_holy], self.x, self.y)\\r\\n      else\\r\\n        bullet_name = :\\"level2_#{@spell}\\"\\r\\n        unless BulletData.list.keys.include?(bullet_name)\\r\\n          raise NameError, \\"BulletData.list undefined :#{bullet_name}\\"\\r\\n        end\\r\\n        Bullet.new(BulletData.list[bullet_name], nil, nil)\\r\\n      end\\r\\n      @cool_time = 100\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"scenes":{"game_over.rb":["txt","# Scene - GameOver\\r\\n\\r\\nclass GameOver < Scene\\r\\n  def self.new(symbol)\\r\\n    @font_big   = Font.new(140, \'Poco\')\\r\\n    @font_nomal = Font.new(90, \'Poco\')\\r\\n    @font_mini  = Font.new(50, \'Poco\')\\r\\n\\r\\n    @title_width = @font_big.get_width(\'Game Over\')\\r\\n    @score_is    = @font_nomal.get_width(\'score : \')\\r\\n    @tb = TextBox.new(Window.width * 0.3, Window.height * 0.7, Window.width * 0.4, 100,\\r\\n                      font_name: \'Poco\', font_size: 90, font_oy: - 16, cursor_scale: 0.9)\\r\\n\\r\\n    @alerts = []\\r\\n    @alerts_stay_cnt = []\\r\\n    @alerts_alpha = []\\r\\n    @symbol = symbol\\r\\n    Debugger._str = \'\'\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @tb.update\\r\\n    if Input.key_push?(K_RETURN)\\r\\n      # åå‰ã®é•·ã•ã¯8æ–‡å­—ä»¥ä¸‹\\r\\n      # user name ã®æœ«å°¾ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’æ¶ˆã™\\r\\n      # 2ã¤ä»¥ä¸Šã®ä¸¦ã‚“ã ã‚¹ãƒšãƒ¼ã‚¹ã‚’1ã¤ã®ã‚¹ãƒšãƒ¼ã‚¹ã«å¤‰æ›\\r\\n      if /^\\\\s+/ =~ @tb.string || @tb.string.length == 0\\r\\n        _call_alert(\'PLZ ENTER YOUR NAME!\')\\r\\n        @tb.string = \'\'\\r\\n      elsif @tb.string.length > 8\\r\\n        _call_alert(\'PLZ ENTER A NAME NO MORE THAN 8 CHAR!\')\\r\\n      else\\r\\n        SceneManager.next(:ranking, @tb.string, $score)\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    if @symbol == :game_clear\\r\\n      @title_width = @font_big.get_width(\'Game Clear\')\\r\\n      Window.draw_font(\\r\\n        (Window.width - @title_width) / 2,\\r\\n        (Window.height - @font_big.size) * 0.3,\\r\\n        \'Game Clear\',\\r\\n        @font_big\\r\\n      )\\r\\n    else\\r\\n      Window.draw_font(\\r\\n        (Window.width - @title_width) / 2,\\r\\n        (Window.height - @font_big.size) * 0.3,\\r\\n        \'Game Over\',\\r\\n        @font_big\\r\\n      )\\r\\n    end\\r\\n    score_width = @score_is + @font_nomal.get_width(\'0\') * $score.to_s.length\\r\\n    Window.draw_font(\\r\\n      (Window.width - score_width) / 2,\\r\\n      (Window.height - @font_nomal.size) * 0.4,\\r\\n      \\"score : #{$score}\\",\\r\\n      @font_nomal\\r\\n    )\\r\\n    @tb.draw\\r\\n\\r\\n    # draw alerts\\r\\n    i = 1\\r\\n    @alerts.reverse_each do |a|\\r\\n      Window.draw_alpha(0, (@alerts.length - i) * a.height, a, @alerts_alpha[-i])\\r\\n      if @alerts_stay_cnt[-i] > 0\\r\\n        @alerts_stay_cnt[-i] -= 1\\r\\n      else\\r\\n        @alerts_alpha[-i] -= 4\\r\\n      end\\r\\n      if @alerts_alpha[-i] <= 80\\r\\n        @alerts.delete_at(-i)\\r\\n        @alerts_alpha.delete_at(-i)\\r\\n        @alerts_stay_cnt.delete_at(-i)\\r\\n      end\\r\\n      i += 1\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self._call_alert(str)\\r\\n    str = str.to_s\\r\\n    @alerts << Image.new(@font_mini.get_width(str) + 20, @font_mini.size).\\r\\n      draw_font(10, 0, str, @font_mini, [230, 230, 230])\\r\\n    @alerts_stay_cnt << 160 # tick\\r\\n    @alerts_alpha << 255\\r\\n  end\\r\\n  private_class_method :_call_alert\\r\\nend\\r\\n"],"loading.rb":["txt","# Scene - Loading\\r\\n# specially scene\\r\\n# imported \'scene-manager.rb\'\\r\\nclass Loading < Scene\\r\\n  @font = Font.new(32)\\r\\n\\r\\n  def self.draw\\r\\n    Window.draw_font(0, 0, \'Loading\', @font)\\r\\n  end\\r\\nend\\r\\n"],"menu.rb":["txt","class Menu < Scene\\r\\n  def self.new\\r\\n    @cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    @cover.alpha = 100\\r\\n    @font_big = Font.new(160, \'Poco\')\\r\\n    @font     = Font.new(80, \'Poco\')\\r\\n    @font_jp  = Font.new(40, \'ç¾å’²ã‚´ã‚·ãƒƒã‚¯\')\\r\\n    @cursor = 0\\r\\n    @button_on_x = Window.width * 0.6\\r\\n    @button_off_x = Window.width * 0.7\\r\\n    @button_y = 270\\r\\n    @button_on = Sprite.new(@button_on_x, @button_y, Image.new(@font.get_width(\'ON\'), @font.size))\\r\\n    @button_off = Sprite.new(@button_off_x, @button_y, Image.new(@font.get_width(\'OFF\'), @font.size))\\r\\n    w = 400\\r\\n    h = 10\\r\\n    _bar = Image.new(w, h).\\r\\n      box_fill(h / 2, 0, w - h / 2, h, [180, 255, 255, 255]).\\r\\n      circle_fill(h / 2, h / 2, h / 2, [180, 255, 255, 255]).\\r\\n      circle_fill(w - h / 2, h / 2, h / 2, [180, 255, 255, 255])\\r\\n    _toggle = Image.new(30, 30).circle_fill(15, 15, 15, C_WHITE)\\r\\n    @bgm_seek_bar = SeekBar.new((Window.width - _bar.width) * 0.5, 300,\\r\\n                                _bar, _toggle, percent: BGM.volume)\\r\\n    @se_seek_bar = SeekBar.new((Window.width - _bar.width) * 0.5, 360,\\r\\n                               _bar, _toggle, percent: SE.volume)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    Input.mouse_enable = true\\r\\n    SceneManager.next(:play, is_init: false) if Input.key_release?(K_TAB)\\r\\n    @bgm_seek_bar.update\\r\\n    @se_seek_bar.update\\r\\n    BGM.volume = @bgm_seek_bar.percent\\r\\n    SE.volume = @se_seek_bar.percent\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Play.draw # ãƒ—ãƒ¬ã‚¤ç”»é¢ã®è¡¨ç¤º\\r\\n    @cover.draw\\r\\n    @bgm_seek_bar.draw\\r\\n    @se_seek_bar.draw\\r\\n\\r\\n    menu_x = (Window.width - @font_big.get_width(\'MENU\')) / 2\\r\\n    setting_x = (Window.width - @font_jp.get_width(\'è¨­å®š\')) / 2\\r\\n    how_to_x = (Window.width - @font_jp.get_width(\'æ“ä½œæ–¹æ³•\')) / 2\\r\\n    ex = [220, 255, 255, 255]\\r\\n\\r\\n    Window.draw_font(menu_x,          0, \'MENU\', @font_big).\\r\\n      draw_font(setting_x,          220, \'è¨­å®š\', @font_jp).\\r\\n      # draw_font(Window.width * 0.2, 200, \'éŸ³é‡\', @font_jp).\\r\\n      draw_font(Window.width * 0.2, 255, \'BGM\', @font).\\r\\n      draw_font(Window.width * 0.7, 255, \\"#{(BGM.volume * 100).floor}\\", @font).\\r\\n      draw_font(Window.width * 0.2, 316, \'SE\', @font).\\r\\n      draw_font(Window.width * 0.7, 316, \\"#{(SE.volume * 100).floor}\\", @font).\\r\\n      draw_font(how_to_x,           480, \'æ“ä½œæ–¹æ³•\', @font_jp).\\r\\n      draw_font(Window.width * 0.2, 560, \'ç§»å‹•\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.5, 560, \'ãƒã‚¦ã‚¹ã®ä½ç½®\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.2, 620, \'ãƒãƒ£ãƒ¼ã‚¸æ”»æ’ƒ\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.5, 620, \'å³ã‚¯ãƒªãƒƒã‚¯\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.2, 680, \'ã‚¹ãƒšãƒ«ã®å¤‰æ›´\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.5, 680, \'Z, X or ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«\', @font_jp, color: ex)\\r\\n  end\\r\\nend\\r\\n"],"play.rb":["txt","# Scene - Play\\r\\n\\r\\nclass Play < Scene\\r\\n  class << self\\r\\n    attr_reader :tick\\r\\n    attr_accessor :player, :stage\\r\\n  end\\r\\n\\r\\n  def self.new(stage_name)\\r\\n    Debugger.color = [240, 240, 240]\\r\\n    @tick = 0\\r\\n    @font_big = Font.new(100, \'Poco\')\\r\\n    @font = Font.new(80, \'Poco\')\\r\\n    @font_mid = Font.new(70, \'Poco\')\\r\\n    @font_mini = Font.new(50, \'Poco\')\\r\\n    @font_spell = Font.new(90, \'Poco\')\\r\\n    @font_clear = Font.new(200, \'Poco\')\\r\\n\\r\\n    _img = Image.load_tiles(\\"#{$PATH}/assets/image/wizard.png\\", 6, 4)\\r\\n    load_setting = [4, 3, 0, 1, 2, 7, 6, 5]\\r\\n    player_images = load_setting.map do |i|\\r\\n      s = i * 3\\r\\n      [_img[s], _img[s + 1], _img[s + 2]]\\r\\n    end\\r\\n    @player = Player.new(\\r\\n      :fire,\\r\\n      (Window.width - player_images[0][0].width) * 0.5, Window.height * 0.7,\\r\\n      player_images\\r\\n    )\\r\\n    _x = @player.x + @player.image.width / 2\\r\\n    _y = @player.y + @player.image.height / 2\\r\\n    Input.set_mouse_pos(_x * Window.scale, _y * Window.scale)\\r\\n    Bullet.reset\\r\\n    Enemy.reset\\r\\n    BulletData.load\\r\\n    @stage_name = stage_name.to_s\\r\\n    @stage = Stage.new(stage_name, StageData.load(@stage_name))\\r\\n\\r\\n    @book_anime = Image.load_tiles(\\"#{$PATH}/assets/image/book_anime.png\\", 16, 1)\\r\\n    @book = Sprite.new(10, 800, @book_anime[0])\\r\\n    @book_anime_count = 0\\r\\n\\r\\n    # sleep 1\\r\\n    SceneManager.next(:play_cut_in)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    Input.mouse_enable = true\\r\\n    $debug_mode = !$debug_mode if Input.key_release?(K_F5)\\r\\n    if @tick == 0\\r\\n      BGM.init\\r\\n      SE.init\\r\\n    end\\r\\n\\r\\n    SceneManager.next(:menu) if Input.key_release?(K_TAB)\\r\\n\\r\\n    @stage.update\\r\\n    if @stage.is_clear || Input.key_down?(K_F12)\\r\\n      _stage_clear\\r\\n      if @stage_name == \'1-6\'\\r\\n        SceneManager.next(:game_over, :game_clear, loading: true)\\r\\n      else\\r\\n        SceneManager.next(:stage_select, @stage_name, loading: true)\\r\\n      end\\r\\n    end\\r\\n\\r\\n    # update\\r\\n    @player.update\\r\\n\\r\\n    if @player.life <= 0\\r\\n      _game_over\\r\\n      SceneManager.next(:game_over, nil, skip_draw: false)\\r\\n    end\\r\\n\\r\\n    Bullet.update\\r\\n    i = -1\\r\\n    Enemy.list.length.times do\\r\\n      Enemy.list[i].update\\r\\n      i -= 1\\r\\n    end\\r\\n    Sprite.clean(Enemy.list)\\r\\n\\r\\n    if @book_anime_count != 0\\r\\n      @book_anime_count += 1\\r\\n      @book_anime_count = @book_anime_count % (@book_anime.length * 3)\\r\\n    end\\r\\n    @book_anime_count = 1 if @player.is_changed_spell\\r\\n\\r\\n    @book.image = @book_anime[@book_anime_count / 3]\\r\\n\\r\\n    @tick += 1\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Debugger.puts(\\"fps : #{Window.real_fps}\\")\\r\\n    Debugger.puts(\\"tick : #{@tick}\\")\\r\\n    Debugger.puts(\\"score : #{$score}\\")\\r\\n    Debugger.puts(\\"my life : #{@player.life}\\")\\r\\n    Debugger.puts(\\"player direction : #{@player.direction.to_i}Â°\\")\\r\\n    Debugger.puts(\\"bullet length : #{Bullet.list.length}\\")\\r\\n    Debugger.puts(\\"enemy length: #{Enemy.list.length}\\")\\r\\n\\r\\n    @stage.draw\\r\\n    Sprite.draw(Enemy.list)\\r\\n    Bullet.draw\\r\\n    @player.draw\\r\\n    Bullet.draw_after\\r\\n    HPBar.draw\\r\\n\\r\\n    _draw_book\\r\\n    _draw_ui\\r\\n\\r\\n    if $debug_mode\\r\\n      Debugger.draw_collision(\\r\\n        Enemy.list + [@player] + Bullet.list + @stage.objects\\r\\n      )\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self._draw_book\\r\\n    @book.draw\\r\\n    case @player.spell\\r\\n    when :wind\\r\\n      color = [20, 217, 105]\\r\\n    when :holy\\r\\n      color = C_BLACK\\r\\n    else\\r\\n      color = BulletData.spell_and_color[@player.spell]\\r\\n    end\\r\\n    str = \\"#{@player.spell}\\".upcase\\r\\n    Window.draw_font(115 - @font.get_width(str) / 2, 820, str, @font, color: color)\\r\\n  end\\r\\n  private_class_method :_draw_book\\r\\n\\r\\n  def self._draw_ui\\r\\n    case @player.life\\r\\n    when 0..100\\r\\n      color = [255, 0, 0]\\r\\n    when 101..150\\r\\n      color = [255, 210, 0]\\r\\n    else\\r\\n      color = [70, 130, 180]\\r\\n    end\\r\\n    Window.draw_font(10, -20, \\"LIFE : #{@player.life}\\", @font, color: color)\\r\\n    if @stage.now == @stage.waves.length\\r\\n      wave = \'CLEAR\'\\r\\n    else\\r\\n      wave = \\"#{@stage.now + 1} / #{@stage.waves.length}\\"\\r\\n    end\\r\\n    x = (Window.width - @font_mid.get_width(\\"STAGE : #{@stage_name}\\")) * 0.5\\r\\n    Window.draw_font(x, -15, \\"STAGE : #{@stage_name}\\", @font_mid)\\r\\n    x = (Window.width - @font_big.get_width(\\"WAVE : #{wave}\\")) * 0.5\\r\\n    Window.draw_font(x, 10, \\"WAVE : #{wave}\\", @font_big)\\r\\n    w = @font.get_width([\'SCORE : \', $score].join)\\r\\n    Window.draw_font(Window.width - w - 40, -20, \\"SCORE : #{$score}\\", @font)\\r\\n    Window.draw_font(230, Window.height - 60, \\"[TAB] MENU\\", @font_mini, color: [230, 230, 230])\\r\\n    Window.draw_font(Window.width - 200, Window.height - 60,\\r\\n                     \\"<FPS : #{Window.real_fps}>\\", @font_mini, color: [230, 230, 230])\\r\\n    # Window.draw_font(Window.width - w - 40, 20, \\"LEVEL : #{@player.level}\\", @font)\\r\\n  end\\r\\n  private_class_method :_draw_ui\\r\\n\\r\\n  def self._stage_clear\\r\\n    cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    cover.alpha = 0\\r\\n    @player.alpha = 255\\r\\n    i = 0\\r\\n    loop do\\r\\n      Play.draw\\r\\n\\r\\n      str = \\"STAGE CLEAR!\\"\\r\\n      x = (Window.width - @font_clear.get_width(str)) / 2\\r\\n      y = (Window.height - @font_clear.size) / 2\\r\\n      Window.draw_font(x, y, str, @font_clear)\\r\\n      if i > 400\\r\\n        cover.alpha += 15 if i % 30 == 0\\r\\n        break if cover.alpha > 255\\r\\n      end\\r\\n\\r\\n      cover.draw\\r\\n      i += 1\\r\\n      Window.update\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_stage_clear\\r\\n\\r\\n  def self._game_over\\r\\n    cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    cover.alpha = 0\\r\\n    @player.alpha = 255\\r\\n    i = 0\\r\\n    loop do\\r\\n      Window.update\\r\\n      Play.draw\\r\\n\\r\\n      cover.alpha += 15 if i % 30 == 0\\r\\n      break if cover.alpha > 255\\r\\n\\r\\n      cover.draw\\r\\n      i += 1\\r\\n    end\\r\\n\\r\\n    Play.draw\\r\\n  end\\r\\n  private_class_method :_game_over\\r\\nend\\r\\n"],"play_cut_in.rb":["txt","class PlayCutIn < Scene\\r\\n  def self.new\\r\\n    @player_x = Play.player.x\\r\\n    @player_y = Play.player.y\\r\\n    Play.player.y = Window.height\\r\\n    @cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    @cover.alpha = 200\\r\\n    @tick = 0\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    Play.player.y -= Play.player.speed\\r\\n    Play.player.animation(@tick / 10)\\r\\n    @cover.alpha = [0, @cover.alpha - 10].max\\r\\n    if Play.player.y < @player_y\\r\\n      Play.player.y = @player_y\\r\\n      Play.player.animation(1)\\r\\n      SceneManager.next(:play, is_init: false, skip_draw: false)\\r\\n    end\\r\\n\\r\\n    @tick += 1\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Play.stage.draw\\r\\n    Sprite.draw(Enemy.list)\\r\\n    Play.player.draw\\r\\n    @cover.draw\\r\\n  end\\r\\nend\\r\\n"],"ranking.rb":["txt","class Ranking < Scene\\r\\n  def self.new(user_name, score)\\r\\n    @font_title = Font.new(140, \'Poco\')\\r\\n    @font_big   = Font.new(120, \'Poco\')\\r\\n    @font_nomal = Font.new(100, \'Poco\')\\r\\n    @font_mini  = Font.new(48, \'Poco\')\\r\\n\\r\\n    begin\\r\\n      @user_db = open(\'user\') {|io| JSON.load(io) }\\r\\n    rescue StandardError\\r\\n      @user_db = {}\\r\\n    end\\r\\n\\r\\n    t = Time.now\\r\\n    @user_db[user_name] = {\\r\\n      \'score\' => score.to_i,\\r\\n      \'time\' => \\"#{t.year}/#{t.month}/#{t.day} #{t.hour}:#{t.min == 0 ? \'00\' : t.min}\\",\\r\\n    }\\r\\n\\r\\n    @user_db = @user_db.sort_by {|data| [-data[1][\'score\'], data[0].upcase] }\\r\\n    @user_db.pop(@user_db.length - 10) if @user_db.length > 10\\r\\n    @user_db = @user_db.to_h\\r\\n\\r\\n    str = JSON.pretty_generate(@user_db)\\r\\n    File.open(\'user\', \'w\') do |f|\\r\\n      f.write(str)\\r\\n      f.write(\\"\\\\n\\")\\r\\n    end\\r\\n\\r\\n    str = \'SCORE RANKING\'\\r\\n    w = @font_title.get_width(str)\\r\\n    img = Image.new(w + 20, @font_title.size * 0.8).draw_font(10, -36, str, @font_title)\\r\\n    @title = Sprite.new((Window.width - img.width) / 2, 60, img)\\r\\n\\r\\n    @table = []\\r\\n    @user_db.each_with_index do |item, i|\\r\\n      break if i >= 5\\r\\n\\r\\n      name = item[0]\\r\\n      score = item[1][\'score\']\\r\\n      time = item[1][\'time\']\\r\\n      w = [\\r\\n        @font_big.get_width(name.to_s) + 20,\\r\\n        @font_nomal.get_width(score.to_s) + 20,\\r\\n        @font_mini.get_width(time.to_s) + 20,\\r\\n      ]\\r\\n      name_s =  @font_big.get_width(\'AAAAAAAA\')\\r\\n      score_s = name_s + @font_big.get_width(\'1000\')\\r\\n      name_img =  Image.new(w[0], @font_big.size   * 0.8).draw_font(10, -30, name.to_s, @font_big)\\r\\n      score_img = Image.new(w[1], @font_nomal.size * 0.8).draw_font(10, -20, score.to_s, @font_nomal)\\r\\n      time_img =  Image.new(w[2], @font_mini.size).draw_font(10, -10, time.to_s, @font_mini, [240, 240, 240])\\r\\n      name_h = 220 + i * @font_big.size * 0.9\\r\\n      score_h = 220 + i * @font_big.size * 0.9 + name_img.height - score_img.height - 10\\r\\n      time_h = 220 + i * @font_big.size * 0.9 + name_img.height - time_img.height - 10\\r\\n      @table << Sprite.new(240,           name_h,  name_img)\\r\\n      @table << Sprite.new(260 + name_s,  score_h, score_img)\\r\\n      @table << Sprite.new(280 + score_s, time_h,  time_img)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    if Input.key_push?(K_RETURN) || Input.key_push?(K_SPACE)\\r\\n      SceneManager.next(:title)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @title.draw\\r\\n    Sprite.draw(@table)\\r\\n  end\\r\\nend\\r\\n"],"stage_select.rb":["txt","class StageSelect < Scene\\r\\n  def self.new(stage_name)\\r\\n    @font = Font.new(80, \'Poco\')\\r\\n    @stage_name = stage_name\\r\\n    if /(\\\\d)-(?<section>\\\\d)/ =~ @stage_name\\r\\n      $stage = [section.to_i, $stage].max\\r\\n    else\\r\\n      raise ArgumentError, \\"stage_name ( <chapter>-<section> )\\"\\r\\n    end\\r\\n    @stage_base = []\\r\\n    2.times do |y|\\r\\n      3.times do |x|\\r\\n        _x = (Window.width - 300 * 2 - 250) / 2\\r\\n        _y = (Window.height - 250 * 1 - 200) / 2\\r\\n        @stage_base << Sprite.new(_x + x * 300, _y + y * 250, Image.new(250, 200, [150, 255, 255, 255]))\\r\\n      end\\r\\n    end\\r\\n    @tick = 0\\r\\n  end\\r\\n\\r\\n  def self.set_music\\r\\n    BGM.list[:mist][0].play\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @tick += 1\\r\\n    Input.mouse_enable = true\\r\\n    @stage_base.length.times do |i|\\r\\n      sp = @stage_base[i]\\r\\n      if sp.on_mouse?\\r\\n        if Input.mouse_push?(0) && i <= $stage\\r\\n          SceneManager.next(:play, \\"1-#{i + 1}\\", loading: true)\\r\\n        end\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Sprite.draw(@stage_base)\\r\\n    Window.draw_font(10, -20, \'Stage Select\', @font)\\r\\n    Window.draw_font(10, 40, \\"CLEAR #{@stage_name}\\", @font)\\r\\n    @stage_base.length.times do |i|\\r\\n      sp = @stage_base[i]\\r\\n      Window.draw_font(sp.x + 8, sp.y + sp.image.height - @font.size, \\"1-#{i + 1}\\", @font, color: C_WHITE)\\r\\n      if $stage == i\\r\\n        Window.draw_font(sp.x + 120, sp.y - 20, \\"NEXT\\", @font, color: C_WHITE) if @tick % 20 > 10\\r\\n      elsif $stage < i\\r\\n        Window.draw_box_fill(sp.x, sp.y, sp.x + sp.image.width, sp.y + sp.image.height, [100, 0, 0, 0])\\r\\n      end\\r\\n      if sp.on_mouse?\\r\\n        Window.draw_box(sp.x, sp.y, sp.x + sp.image.width, sp.y + sp.image.height, C_WHITE)\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.last\\r\\n    BGM.list[:mist][0].stop\\r\\n  end\\r\\nend\\r\\n"],"title.rb":["txt","# Scene - Title\\r\\n\\r\\nclass Title < Scene\\r\\n  def self.new\\r\\n    @font_title = Font.new(300, \'Poco\')\\r\\n    @font = Font.new(160, \'Poco\')\\r\\n    @bgm = Sound.new(\\"#{$PATH}/assets/sound/38-5.wav\\") # 62.118 sec\\r\\n    @se_enter_play = Sound.new(\\"#{$PATH}/assets/sound/se_retro03.wav\\")\\r\\n    @se_cursor = Sound.new(\\"#{$PATH}/assets/sound/se_system27.wav\\")\\r\\n    play = @font.get_width(\'PLAY\')\\r\\n    credit = @font.get_width(\'CREDIT\')\\r\\n    exit_  = @font.get_width(\'EXIT\')\\r\\n    @section_play = Sprite.new(900, 500, Image.new(play + 10, 90, C_CYAN))\\r\\n    @section_credit = Sprite.new(850, 600, Image.new(credit + 10, 90, C_CYAN))\\r\\n    @section_exit   = Sprite.new(800, 700, Image.new(exit_ + 10,  90, C_CYAN))\\r\\n    @cursor = -99\\r\\n    @s_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    @blank = 60\\r\\n\\r\\n    @tick = 0\\r\\n    _img = Image.load_tiles(\\"#{$PATH}/assets/image/wizard.png\\", 6, 4)\\r\\n    load_setting = [4, 3, 0, 1, 2, 7, 6, 5]\\r\\n    @player_images = load_setting.map do |i|\\r\\n      s = i * 3\\r\\n      [_img[s], _img[s + 1], _img[s + 2]]\\r\\n    end\\r\\n    @mini_char = Sprite.new(60, Window.height - 100 - @player_images[0][0].height, @player_images[0][0])\\r\\n    @mini_char_anime = 0\\r\\n    @mini_field_top = Sprite.new(0, Window.height - 102, Image.new(Window.width, 22, [140, 255, 255, 255]))\\r\\n    @mini_field_img = Image.new(48, 80, [100, 255, 255, 255])\\r\\n    @bullets = []\\r\\n    @spell_count = 0\\r\\n    @hit_spell = nil\\r\\n    @_spell_color = {\\r\\n      fire: [255, 0, 0],\\r\\n      water: [55, 183, 230],\\r\\n      wind: [23, 255, 123],\\r\\n      holy: [249, 250, 212],\\r\\n      dark: [121, 73, 173],\\r\\n    }\\r\\n  end\\r\\n\\r\\n  def self.set_music\\r\\n    @bgm.set_volume(200)\\r\\n    @se_cursor.set_volume(224)\\r\\n    @bgm.play\\r\\n    @bgm.set_volume(226, 1000)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @tick += 1\\r\\n    # bgm loop\\r\\n    bgm_end = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    diff = (bgm_end - @s_time).floor(1)\\r\\n    if @blank <= 0 && diff % 61.5 == 0 # ãšã‚ŒãŒ0.6ç§’ãã‚‰ã„ï¼Ÿ\\r\\n      @bgm.play\\r\\n      @blank = 60\\r\\n    end\\r\\n    @blank = [0, @blank - 1].max\\r\\n\\r\\n    # cursor\\r\\n    if Input.key_push?(K_DOWN) || Input.key_push?(K_UP)\\r\\n      @se_cursor.play\\r\\n    end\\r\\n    @cursor += 1 if Input.key_push?(K_DOWN)\\r\\n    @cursor -= 1 if Input.key_push?(K_UP)\\r\\n    @cursor = [[0, @cursor].max, 2].min if @cursor != -99\\r\\n    if @section_play.on_mouse? || @section_credit.on_mouse? || @section_exit.on_mouse?\\r\\n      @cursor = -99\\r\\n    end\\r\\n\\r\\n    if Input.mouse_down?(0) || Input.key_down?(K_RETURN)\\r\\n      if @section_play.on_mouse? || @cursor == 0\\r\\n        @se_enter_play.play\\r\\n        if $stage == 1\\r\\n          SceneManager.next(:play, \'1-1\', loading: true)\\r\\n        else\\r\\n          SceneManager.next(:stage_select, \'1-6\', loading: true)\\r\\n        end\\r\\n        return\\r\\n      elsif @section_credit.on_mouse? || @cursor == 1\\r\\n        SceneManager.next(:play, \'1-1\', loading: true)\\r\\n        return\\r\\n      elsif @section_exit.on_mouse? || @cursor == 2\\r\\n        Window.close\\r\\n      end\\r\\n    end\\r\\n\\r\\n    # mini charactor\\r\\n    if @tick % 10 == 0\\r\\n      @mini_char_anime = (@mini_char_anime + 1) % 3\\r\\n      @mini_char.image = @player_images[0][@mini_char_anime]\\r\\n    end\\r\\n\\r\\n    if Input.key_push?(K_SPACE) || Input.mouse_push?(0)\\r\\n      x = @mini_char.x + @mini_char.image.width * 0.7\\r\\n      y = @mini_char.y + @mini_char.image.height * 0.6\\r\\n      spell = @_spell_color.keys[@spell_count]\\r\\n      img = Image.new(10, 10, @_spell_color.values[@spell_count])\\r\\n      @bullets << { :\\"#{spell}\\" => Sprite.new(x, y, img) }\\r\\n      @spell_count = (@spell_count + 1) % 5\\r\\n    end\\r\\n    @bullets.each do |b|\\r\\n      bullet = b.values[0]\\r\\n      spell = b.keys[0]\\r\\n      bullet.x += 10\\r\\n      @hit_spell = spell if bullet.x >= Window.width - 10\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    c = @hit_spell ? @_spell_color[@hit_spell] : C_WHITE\\r\\n    Window.draw_font(30, -100, \'Spell\', @font_title, color: c)\\r\\n    Window.draw_font(30,  100, \'Out\',   @font_title, color: c)\\r\\n    # @section_play.draw\\r\\n    # @section_credit.draw\\r\\n    # @section_exit.draw\\r\\n\\r\\n    _draw_section(@section_play,   0, \'PLAY\')\\r\\n    _draw_section(@section_credit, 1, \'CREDIT\')\\r\\n    _draw_section(@section_exit,   2, \'EXIT\')\\r\\n\\r\\n    @mini_char.draw\\r\\n    _draw_mini_char_field\\r\\n    @bullets.each do |b|\\r\\n      bullet = b.values[0]\\r\\n      # spell = b.keys[0]\\r\\n      bullet.draw\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.last\\r\\n    @bgm.stop\\r\\n    @bgm.dispose\\r\\n  end\\r\\n\\r\\n  def self._draw_section(sp, cursor, section_name)\\r\\n    args = sp.x + 10, sp.y - 60, section_name.upcase, @font\\r\\n    if sp.on_mouse? || @cursor == cursor\\r\\n      Window.draw_font(*args)\\r\\n      Window.draw_line(sp.x, sp.y + sp.image.height,\\r\\n                       sp.x + sp.image.width, sp.y + sp.image.height, C_WHITE)\\r\\n    else\\r\\n      Window.draw_font(*args, color: [200, 255, 255, 255])\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_draw_section\\r\\n\\r\\n  def self._draw_mini_char_field\\r\\n    @mini_field_top.draw\\r\\n\\r\\n    base_y = @mini_char.y + @mini_char.image.height + 20\\r\\n    17.times do |i|\\r\\n      x = i * 80 - @tick % 80\\r\\n      w = @mini_field_img.width\\r\\n      h = @mini_field_img.height\\r\\n      Window.draw_morph(x + 30, base_y, x, base_y + h, x + w, base_y + h, x + w + 30, base_y, @mini_field_img)\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_draw_mini_char_field\\r\\nend\\r\\n"]},"stage.rb":["txt","class Stage\\r\\n  attr_reader :is_clear, :name, :waves, :now, :wave\\r\\n\\r\\n  def initialize(name, waves)\\r\\n    @name = name\\r\\n    @waves = waves\\r\\n    @now = 0\\r\\n    @wave = @waves[@now]\\r\\n    @is_clear = false\\r\\n    @wave.proc_begin.call(@wave)\\r\\n    @wave.spawn_tick = Play.tick\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    # if (@now == @waves.length && Enemy.list.length == 0) || (@boss_flag && !exists_boss?)\\r\\n    #   @is_clear = true\\r\\n    # end\\r\\n    @wave.proc_update.call(@wave)\\r\\n\\r\\n    # wave clear\\r\\n    if (Enemy.list.length == 0 && @wave.judge_flag.nil?) || @wave.judge_flag == true\\r\\n      @wave.proc_end.call(@wave)\\r\\n      @now += 1\\r\\n      if @now > @waves.length - 1\\r\\n        @is_clear = true\\r\\n      else\\r\\n        @wave = @waves[@now]\\r\\n        @wave.proc_begin.call(@wave)\\r\\n        @wave.spawn_tick = Play.tick\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    Window.draw(0, 0, @wave.bg_image)\\r\\n    Sprite.draw(@wave.field_objects)\\r\\n  end\\r\\n\\r\\n  def objects\\r\\n    @wave.field_objects\\r\\n  end\\r\\n\\r\\n  def objects=(item)\\r\\n    @wave.field_objects = item\\r\\n  end\\r\\n\\r\\n  def exists_boss?\\r\\n    @boss.each do |b|\\r\\n      return true if Enemy.list.include?(b)\\r\\n    end\\r\\n    false\\r\\n  end\\r\\nend\\r\\n"],"utils":{"bgm.rb":["txt","class BGM\\r\\n  @list = {\\r\\n    # name: [sound, lenth(sec), base_volume]\\r\\n    chill: [Sound.new(\\"#{$PATH}/assets/sound/32-2.wav\\"), 78.0, 240],\\r\\n    mist: [Sound.new(\\"#{$PATH}/assets/sound/38-5.wav\\"), 62.1, 240],\\r\\n  }\\r\\n  @play_scene = [:play, :menu, :game_over, :ranking]\\r\\n  @now = :chill\\r\\n  @start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n  @blank = 60\\r\\n  @volume = 1\\r\\n\\r\\n  class << self\\r\\n    attr_reader :list, :start_time, :volume\\r\\n    attr_accessor :now\\r\\n  end\\r\\n\\r\\n  def self.init\\r\\n    @list[@now][0].stop\\r\\n    @start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    @list[@now][0].set_volume(96 + (@list[@now][2] - 96) * @volume)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @list[@now][0].stop unless @play_scene.include?(SceneManager.now)\\r\\n    # bgm loop\\r\\n    bgm_end = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    diff = (bgm_end - @start_time).floor(1)\\r\\n    if @blank <= 0 && (diff % (@list[@now][1] - 0.5)) == 0\\r\\n      @list[@now][0].play\\r\\n      @blank = 60\\r\\n    end\\r\\n    @blank = [0, @blank - 1].max\\r\\n  end\\r\\n\\r\\n  def self.volume=(volume)\\r\\n    @volume = volume\\r\\n    @list.each do |k, v|\\r\\n      v[0].set_volume(96 + (v[2] - 96) * @volume)\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nBGM.new\\r\\n"],"debugger.rb":["txt","# Tools - Debegger\\r\\n\\r\\nclass Debugger\\r\\n  @font = Font.new(24)\\r\\n  @color = C_WHITE\\r\\n  @ox = 0\\r\\n  @oy = 0\\r\\n  @_str = \'\'\\r\\n  @_list = []\\r\\n\\r\\n  def self.new(font_size: 24, font_name: \'\', option: {},\\r\\n               color: C_WHITE, ox: 10, oy: 10)\\r\\n    @font = Font.new(font_size, font_name, option)\\r\\n    @color = color\\r\\n    @ox = ox\\r\\n    @oy = oy\\r\\n    @_str = \'\'\\r\\n    @_list = []\\r\\n  end\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :font, :color, :ox, :oy, :_str, :_list\\r\\n  end\\r\\n\\r\\n  def self.print(str)\\r\\n    @_str << str.to_s\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def self.puts(str)\\r\\n    @_str << [str.to_s.chomp, \\"\\\\n\\"].join\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def self.draw_msg\\r\\n    @_str.split(/\\\\R/).each_with_index do |msg, i|\\r\\n      Window.draw_font(@ox, @oy + @font.size * i, msg, @font, color: @color)\\r\\n    end\\r\\n    @_str = \'\'\\r\\n  end\\r\\n\\r\\n  def self.add_block(&block)\\r\\n    @_list << block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def self.block_call\\r\\n    @_list.each {|l| l.call }\\r\\n    @_list = []\\r\\n  end\\r\\n\\r\\n  # arg: sprites : Sprite Object | [ Sprite Object ]\\r\\n  def self.draw_collision(sprites)\\r\\n    if sprites.class < Sprite\\r\\n      sprites = [sprites]\\r\\n    elsif sprites.class == Array\\r\\n    else\\r\\n      raise ArgumentError, \\"sprites please : (Sprite | Array[Sprite])\\"\\r\\n    end\\r\\n    sprites.each do |sp|\\r\\n      next unless sp.collision_enable\\r\\n      col = sp.collision\\r\\n\\r\\n      # ã‚¹ã‚±ãƒ¼ãƒ«ã‚„ã‚¢ãƒ³ã‚°ãƒ«ãŒå¤‰ã‚ã£ã¦ã„ã‚‹å ´åˆ\\r\\n      if sp.angle != 0 || sp.scale_x != 1 || sp.scale_y != 1\\r\\n        img = Image.new(sp.image.width, sp.image.height)\\r\\n        if col.nil? # box\\r\\n          img.box(0, 0, sp.image.width, sp.image.height, @color)\\r\\n        elsif col.length == 2 # dot\\r\\n          img.pixel(*col, @color)\\r\\n        elsif col.length == 3 # circle\\r\\n          img.circle(*col, @color)\\r\\n        elsif col.length == 4 # box\\r\\n          img.box(*col, @color)\\r\\n        elsif col.length == 6 # triangle\\r\\n          img.triangle(*col, @color)\\r\\n        end\\r\\n        Window.draw_ex(sp.x, sp.y, img,\\r\\n                       scale_x: sp.scale_x,\\r\\n                       scale_y: sp.scale_y,\\r\\n                       center_x: sp.center_x,\\r\\n                       center_y: sp.center_y,\\r\\n                       angle: sp.angle)\\r\\n      else\\r\\n        if col.nil? # box\\r\\n          Window.draw_box(sp.x, sp.y, sp.x + sp.image.width, sp.y + sp.image.height, @color)\\r\\n          next\\r\\n        else\\r\\n          new_col = col.map.with_index do |_col, index|\\r\\n            if index % 2 == 0\\r\\n              sp.x + _col\\r\\n            else\\r\\n              sp.y + _col\\r\\n            end\\r\\n          end\\r\\n        end\\r\\n\\r\\n        if col.length == 2 # dot\\r\\n          Window.draw_pixel(*new_col, @color)\\r\\n        elsif col.length == 3 # circle\\r\\n          Window.draw_circle(sp.x + col[0], sp.y + col[1], col[2], @color)\\r\\n        elsif col.length == 4 # box\\r\\n          Window.draw_box(*new_col, @color)\\r\\n        elsif col.length == 6 # triangle\\r\\n          Window.draw_triangle(*new_col, @color)\\r\\n        end\\r\\n      end\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"easing.rb":["txt","# Easing Referrence\\r\\n# https://easings.net/\\r\\n# http://gizma.com/easing/\\r\\n\\r\\n\\r\\nclass Easing\\r\\n  # 0.0 <= t < 1.0\\r\\n\\r\\n  @_tick = 0\\r\\n  @_processor = {}\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :_tick, :time, :_processor\\r\\n\\r\\n    def _update\\r\\n      @_tick += 1\\r\\n      @time = @_tick / 60.0\\r\\n\\r\\n      @_processor.each { |key, process| process.call }\\r\\n    end\\r\\n\\r\\n    # return [t, b, c, d]\\r\\n    private def _ease_fanc_init(start_value, change_value, duration: 1.0, _passed_tick: nil)\\r\\n      if _passed_tick.nil?\\r\\n        t = @time\\r\\n      else\\r\\n        t = (@_tick - _passed_tick) / 60.0\\r\\n      end\\r\\n      b = start_value.to_f\\r\\n      c = change_value.to_f\\r\\n      d = duration.to_f\\r\\n      [t, b, c, d]\\r\\n    end\\r\\n  end\\r\\n\\r\\n  Window.before_call[:easing_update] = method(:_update)\\r\\n\\r\\n  def initialize(obj, target_attr, ease_sym, start_val, end_val)\\r\\n    @obj = obj\\r\\n    @target_attr = target_attr.to_sym\\r\\n    @ease_sym = ease_sym\\r\\n\\r\\n    t = self.class._tick\\r\\n    case @obj\\r\\n    when Array\\r\\n      self.class._processor[:\\"#{obj.object_id}_#{@target_attr}\\"] = proc {\\r\\n        obj.each do |o|\\r\\n          o.method(\\"#{@target_attr}=\\").call(\\r\\n            self.class.method(ease_sym).call(start_val, end_val, _passed_tick: t)\\r\\n          )\\r\\n        end\\r\\n      }\\r\\n    else\\r\\n      self.class._processor[:\\"#{obj.object_id}_#{@target_attr}\\"] = proc {\\r\\n        obj.method(\\"#{@target_attr}=\\").call(\\r\\n          self.class.method(ease_sym).call(start_val, end_val, _passed_tick: t)\\r\\n        )\\r\\n      }\\r\\n    end\\r\\n  end\\r\\n\\r\\n\\r\\n  # === sine ===\\r\\n  def self.ease_in_sine(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    -c * Math.cos(t / d * (Math::PI / 2)) + c + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_sine(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    c * Math.sin(t / d * (Math::PI / 2)) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_sine(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    -c / 2 * (Math.cos(Math::PI * t / d) - 1) + b\\r\\n  end\\r\\n\\r\\n  # === quad ===\\r\\n  def self.ease_in_quad(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n\\t  c * t * t + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_quad(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n\\t  -c * t * (t - 2) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_quad(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d/2\\r\\n    return c / 2 * t * t + b if t < 1\\r\\n    t -= 1\\r\\n    -c / 2 * (t * (t - 2) - 1) + b\\r\\n  end\\r\\n\\r\\n  # === cubic ===\\r\\n  def self.ease_in_cubic(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n    c * t * t * t + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_cubic(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n    t -= 1\\r\\n    c * (t * t * t + 1) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_cubic(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d / 2.0\\r\\n    if t < 1\\r\\n      c / 2.0 * t * t * t + b\\r\\n    else\\r\\n      t -= 2\\r\\n      c / 2.0 * (t * t * t + 2) + b\\r\\n    end\\r\\n  end\\r\\n\\r\\n  # === quart ===\\r\\n  def self.ease_in_quart(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n\\t  c * t * t * t * t + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_quart(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n    t -= 1\\r\\n    -c * (t * t * t * t - 1) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_quart(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d / 2\\r\\n    return c / 2 * t * t * t * t + b if t < 1\\r\\n    t -= 2\\r\\n    -c / 2 * (t * t * t * t - 2) + b\\r\\n  end\\r\\nend\\r\\n"],"hp_bar.rb":["txt","class HPBar\\r\\n  class << self\\r\\n    attr_reader :enemy_hp_bar, :boss_hp_bar\\r\\n  end\\r\\n\\r\\n  def self.new\\r\\n    @enemy_hp_bar = []\\r\\n    @boss_hp_bar = []\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @enemy_hp_bar.each do |me|\\r\\n      if !Enemy.list.include?(me[:enemy]) || me[:enemy].vanished? || !me[:enemy].collision_enable\\r\\n        @enemy_hp_bar.delete(me)\\r\\n      end\\r\\n      next if me[:enemy].data.hp == me[:enemy].data.max_hp\\r\\n\\r\\n      me[:bar] = Image.new(1 + me[:base].width * (me[:enemy].data.hp / me[:enemy].data.max_hp.to_f),\\r\\n                           me[:base].height - 4,\\r\\n                           C_GREEN)\\r\\n      x = me[:enemy].x + (me[:enemy].image.width - me[:base].width) / 2\\r\\n      y = me[:enemy].y #- me[:base].height\\r\\n      Window.draw(x, y, me[:base])\\r\\n      Window.draw(x + 2, y + 2, me[:bar])\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nHPBar.new\\r\\n"],"scene_manager.rb":["txt","class Scene\\r\\n  def self.set_music\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n  end\\r\\n\\r\\n  def self.last\\r\\n  end\\r\\nend\\r\\n\\r\\n# Class for managing scene transitions\\r\\nclass SceneManager\\r\\n  class << self\\r\\n    attr_reader :now, :scenes\\r\\n  end\\r\\n\\r\\n  # Enumerate scenes by Hash,\\r\\n  # (setting start scene, and first scene set whether to use loading)\\r\\n  def self.new(scenes, start: nil, loading: false)\\r\\n    # check type\\r\\n    raise ArgumentError, \'Please hash! #Arg:scenes\' if scenes.class != Hash\\r\\n\\r\\n    scenes.each do |ary|\\r\\n      if ary[0].class != Symbol\\r\\n        raise ArgumentError, \\"Please symbol! (#{ary[0]}) #Arg:scenes {symbol: SceneClass}\\"\\r\\n      elsif !(ary[1] < Scene)\\r\\n        raise ArgumentError, \\"Please inheritance Scene class! (#{ary[1]}) #Arg:scenes {symbol: SceneClass}\\"\\r\\n      end\\r\\n    end\\r\\n\\r\\n    @scenes = scenes\\r\\n    if start.nil?\\r\\n      @now = @scenes.first[0] # first symbol\\r\\n    elsif @scenes.key?(start)\\r\\n      @now = start\\r\\n    else\\r\\n      raise ArgumentError, \\"SceneManager haven\'t key \'#{start}\' Arg:start\\"\\r\\n    end\\r\\n\\r\\n    Loading.new\\r\\n    if loading\\r\\n      _do_loading\\r\\n    else\\r\\n      @scenes[@now].new # now scene init!\\r\\n    end\\r\\n\\r\\n    @_set_music = true\\r\\n    @_skip_draw = false\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    if @_set_music\\r\\n      @scenes[@now].set_music\\r\\n      @_set_music = false\\r\\n    end\\r\\n\\r\\n    @_skip_draw = false\\r\\n    @scenes[@now].update\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @scenes[@now].draw unless @_skip_draw\\r\\n  end\\r\\n\\r\\n  def self.next(scene_symbol, *args, loading: false, is_init: true, skip_draw: true)\\r\\n    unless @scenes.key?(scene_symbol)\\r\\n      raise ArgumentError, \\"SceneManager haven\'t key \'#{scene_symbol}\' Arg:scene_symbol\\"\\r\\n    end\\r\\n    raise ArgumentError, \\"\'#{scene_symbol}\' is now scene\\" if scene_symbol == @now\\r\\n\\r\\n    @_set_music = is_init\\r\\n    @_skip_draw = skip_draw\\r\\n    @scenes[@now].last\\r\\n    @now = scene_symbol\\r\\n\\r\\n    if is_init\\r\\n      if loading\\r\\n        _do_loading(*args)\\r\\n      else\\r\\n        @scenes[@now].new(*args)\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self._do_loading(*args)\\r\\n    thr = Thread.new do\\r\\n      @scenes[@now].new(*args) # load\\r\\n    end\\r\\n\\r\\n    loop do\\r\\n      if Input.key_push?(K_ESCAPE) && Input.key_push?(K_DELETE)\\r\\n        break\\r\\n      end\\r\\n\\r\\n      Window.update\\r\\n      Loading.update\\r\\n      Loading.draw\\r\\n      unless thr.alive?\\r\\n        Loading.last\\r\\n        break\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_do_loading\\r\\nend\\r\\n"],"scrollable_page.rb":["txt","class ScrollablePage < RenderTarget\\r\\n  attr_reader :pos\\r\\n\\r\\n  def initialize(width, height, bgcolor: [0, 0, 0, 0],\\r\\n                 page_width: nil, page_height: nil,\\r\\n                 scrollbar: nil, scrollbar_base: nil,\\r\\n                 bar_w: 16, bar_color: [200, 200, 200], bar_base_color: C_WHITE)\\r\\n    super(width, height, bgcolor)\\r\\n    @page_width = page_width || self.width\\r\\n    @page_height = page_height || self.height\\r\\n\\r\\n    @bar_h_per = [self.height.to_f / @page_height, 1].min\\r\\n    @scrollbar = scrollbar || Image.new(bar_w, (self.height * @bar_h_per).to_i, bar_color)\\r\\n    @scrollbar_base = scrollbar_base || Image.new(bar_w, self.height, bar_base_color)\\r\\n\\r\\n    @pos = 0\\r\\n    @_before_mouse_wheel = Input.mouse_wheel_pos\\r\\n  end\\r\\n\\r\\n  def draw_scrollbar\\r\\n    draw(width - @scrollbar_base.width, @pos, @scrollbar_base)\\r\\n    draw(width - @scrollbar.width, @pos * @bar_h_per + @pos, @scrollbar)\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    scroll_volume = (@_before_mouse_wheel - Input.mouse_wheel_pos) / 120\\r\\n    scroll_volume *= 50\\r\\n    @_before_mouse_wheel = Input.mouse_wheel_pos\\r\\n\\r\\n    @pos += scroll_volume\\r\\n    @pos = [0, [@pos, @page_height - height].min].max\\r\\n  end\\r\\n\\r\\n  # wrapping methods\\r\\n  [\\r\\n    \'draw(x, y,image, z=0)\',\\r\\n    \'draw_scale(x, y, image, scale_x, scale_y, center_x=nil, center_y=nil, z=0)\',\\r\\n    \'draw_rot(x, y, image, angle, center_x=nil, center_y=nil, z=0)\',\\r\\n    \'draw_alpha(x, y, image, alpha, z=0)\',\\r\\n    \'draw_add(x, y, image, z=0)\',\\r\\n    \'draw_sub(x, y, image, z=0)\',\\r\\n    \'draw_shader(x, y, image, shader, z=0)\',\\r\\n    \'draw_ex(x, y, image, option={})\',\\r\\n    \'draw_font(x, y, text, font, option={})\',\\r\\n    \'draw_font_ex(x, y, text, font, option={})\',\\r\\n    \'draw_morph(x1, y1, x2, y2, x3, y3, x4, y4, image, option={})\',\\r\\n    \'draw_tile(base_x, base_y, map, image_array, start_x, start_y, size_x, size_y, z=0)\',\\r\\n    \'draw_pixel(x, y, color, z=0)\',\\r\\n    \'draw_line(x1, y1, x2, y2, color, z=0)\',\\r\\n    \'draw_box(x1, y1, x2, y2, color, z=0)\',\\r\\n    \'draw_box_fill(x1, y1, x2, y2, color, z=0)\',\\r\\n    \'draw_circle(x, y, r, color, z=0)\',\\r\\n    \'draw_circle_fill(x, y, r, color, z=0)\',\\r\\n  ].each do |method|\\r\\n    match = method.match(/^(\\\\w*)\\\\((.+)\\\\)$/)\\r\\n    name = match[1]\\r\\n    arg = match[2]\\r\\n    # puts \\"#{name}(#{arg})\\"\\r\\n    new_arg = arg.\\r\\n      gsub(/(\\\\w+)\\\\s*=.+?,/, \'\\\\\\\\1,\').\\r\\n      sub(/(\\\\w+)\\\\s*=.+?$/, \'\\\\\\\\1\').\\r\\n      gsub(/(x|x\\\\d), (y|y\\\\d),/, \'\\\\\\\\1, \\\\\\\\2 - @pos,\')\\r\\n    # puts \\"#{\' \' * (name.length - 2)}=> #{new_arg}\\"\\r\\n    eval \\"def #{name}(#{arg})\\r\\n            super(#{new_arg})\\r\\n          end\\"\\r\\n  end\\r\\nend\\r\\n"],"se.rb":["txt","class SE\\r\\n  @list = {\\r\\n    # key: [sound. base_volume(0 ~ 255)]\\r\\n    retro04: [Sound.new(\\"#{$PATH}/assets/sound/se_retro04.wav\\"), 230],\\r\\n    slime: [Sound.new(\\"#{$PATH}/assets/sound/slime1.wav\\"), 230],\\r\\n  }\\r\\n\\r\\n  @volume = 1\\r\\n\\r\\n  class << self\\r\\n    attr_reader :volume, :list\\r\\n  end\\r\\n\\r\\n  def self.init\\r\\n    @list.values.each do |sound|\\r\\n      sound[0].set_volume(96 + (sound[1] - 96) * @volume)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.play(symbol)\\r\\n    @list[symbol][0].play\\r\\n  end\\r\\n\\r\\n  def self.volume=(volume)\\r\\n    @volume = volume\\r\\n    @list.values.each do |sound|\\r\\n      sound[0].set_volume(96 + (sound[1] - 96) * @volume)\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"seek_bar.rb":["txt","class SeekBar < Sprite\\r\\n  attr_accessor :bar_image, :toggle_image, :percent, :pushed\\r\\n\\r\\n  def initialize(x, y, bar_image, toggle_image, percent: 1,\\r\\n                 enable_key_input: true,\\r\\n                 pushed_toggle_scale: 0.8)\\r\\n\\r\\n    super\\r\\n    self.x = x\\r\\n    self.y = y\\r\\n    @bar_image = bar_image\\r\\n    @toggle_image = toggle_image\\r\\n\\r\\n    @percent = percent\\r\\n    @enable_key_input = enable_key_input\\r\\n    @pushed_toggle_scale = pushed_toggle_scale\\r\\n\\r\\n    @pushed = false\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    @tog_x = x + @bar_image.width * @percent - @toggle_image.width * 0.5\\r\\n    @tog_y = y + (@bar_image.height - @toggle_image.height) * 0.5\\r\\n    if Input.mouse_push?(0) &&\\r\\n      (@tog_x..@tog_x + @toggle_image.width).include?(Mouse.x) &&\\r\\n      (@tog_y..@tog_y + @toggle_image.height).include?(Mouse.y)\\r\\n      @pushed = true\\r\\n    end\\r\\n    if Input.mouse_release?(0)\\r\\n      @pushed = false\\r\\n    end\\r\\n    if @pushed\\r\\n      per = (Mouse.x - x) / @bar_image.width.to_f\\r\\n      @percent = [[0, per].max, 1.0].min.floor(2)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    Window.draw(x, y, @bar_image)\\r\\n    Window.draw(@tog_x, @tog_y, @toggle_image)\\r\\n  end\\r\\nend\\r\\n"],"text_box.rb":["txt","class TextBox\\r\\n  attr_accessor :x, :y, :width, :height, :font_name, :font_size, :string, :frame_color, :font_color\\r\\n\\r\\n  def initialize(x, y, width, height,\\r\\n                 font_name: \'\', font_size: height * 0.8, font_color: C_WHITE, font_ox: 0, font_oy: 0,\\r\\n                 string: \'\', frame_color: C_WHITE, cursor_scale: 1)\\r\\n    @x = x\\r\\n    @y = y\\r\\n    @width = width\\r\\n    @height = height\\r\\n    @font_size = font_size\\r\\n    @string = string\\r\\n    @frame_color = frame_color\\r\\n    @font_color = font_color\\r\\n    @font = Font.new(@font_size, font_name)\\r\\n    @font_w = @font.get_width(@string)\\r\\n    @frame = Sprite.new(@x, @y, Image.new(@width, @height).box(0, 0, @width, @height, @frame_color))\\r\\n    @moji = Sprite.new(\\r\\n      @x + @width * 0.03 + font_ox,\\r\\n      @y + @height * 0.1 + font_oy,\\r\\n      Image.new(@width * 0.94, @height * 0.8).draw_font(0, 0, @string, @font, @font_color)\\r\\n    )\\r\\n    @cursor = Sprite.new(\\r\\n      @x + @width * 0.03,\\r\\n      @y + @height * 0.1,\\r\\n      Image.new(1, @font_size * cursor_scale, @frame_color)\\r\\n    )\\r\\n    @is_choose = true\\r\\n    @tick = 0\\r\\n    @alphabet = (\'a\'..\'z\').to_a\\r\\n    @flash_rate = 60\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    return nil unless @is_choose\\r\\n\\r\\n    @tick += 1\\r\\n    typing\\r\\n    @font_w = @font.get_width(@string)\\r\\n    if @font_w > @moji.image.width\\r\\n      @cursor.x = @moji.x + @moji.image.width + 1\\r\\n      diff = @font_w - @moji.image.width\\r\\n      @moji.image =  Image.new(@width * 0.94, @height * 0.8).draw_font(-diff, 0, @string, @font, @font_color)\\r\\n    else\\r\\n      @cursor.x = @frame.x + @width * 0.03 + @font_w\\r\\n      @moji.image = Image.new(@width * 0.94, @height * 0.8).draw_font(0, 0, @string, @font, @font_color)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    @frame.draw\\r\\n    @moji.draw\\r\\n    if @is_choose && (@tick % @flash_rate * 2 < @flash_rate)\\r\\n      @cursor.draw\\r\\n    end\\r\\n  end\\r\\n\\r\\n  private\\r\\n\\r\\n  def typing\\r\\n    26.times do |i|\\r\\n      next unless Input.key_push?(eval(\\"K_#{@alphabet[i].upcase}\\"))\\r\\n\\r\\n      @string << @alphabet[i].upcase\\r\\n\\r\\n      # choose upcase or down case cf. pushig shift key\\r\\n      # if Input.key_down?(K_LSHIFT) || Input.key_down?(K_RSHIFT)\\r\\n      #   @string += @alphabet[i].upcase\\r\\n      # else\\r\\n      #   @string += @alphabet[i]\\r\\n      # end\\r\\n    end\\r\\n    if Input.key_push?(K_SPACE) || Input.key_down?(K_SPACE) && @tick % 6 == 0\\r\\n      @string << \' \'\\r\\n    end\\r\\n    if @string.length > 0 && (Input.key_push?(K_BACK) || Input.key_down?(K_BACK) && @tick % 6 == 0)\\r\\n      @string.chop!\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"wrapper.rb":["txt","# Wrapping `Input.mouse_x`, `Input.mouse_y` and `Input.mouse_enable`\\r\\n# And Update the mouse display when the keyboard is pressed\\r\\nclass Mouse\\r\\n  @x = nil\\r\\n  @y = nil\\r\\n  @is_draw = true\\r\\n\\r\\n  class << self\\r\\n    attr_reader :x, :y, :is_draw\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @old_x = @x\\r\\n    @old_y = @y\\r\\n    @x = Input.mouse_x / Window.scale\\r\\n    @y = Input.mouse_y / Window.scale\\r\\n\\r\\n    @is_draw = false unless Input.keys.empty?\\r\\n    @is_draw = true if !(@old_x == @x && @old_y == @y)\\r\\n    Input.mouse_enable = @is_draw\\r\\n  end\\r\\nend\\r\\n\\r\\n# wrapping `DXRuby::Sprite\\r\\n# Adding `on_mosue?()`\\r\\nclass Sprite\\r\\n  def on_mouse?\\r\\n    Mouse.is_draw == true &&\\r\\n      (x..x + image.width).include?(Mouse.x) &&\\r\\n      (y..y + image.height).include?(Mouse.y)\\r\\n  end\\r\\n\\r\\n  def mouse_clicked?(mouse_button)\\r\\n    (Input.mouse_down?(mouse_button) &&\\r\\n    (x..x + image.width).include?(Mouse.x) &&\\r\\n    (y..y + image.height).include?(Mouse.y))\\r\\n  end\\r\\nend\\r\\n"]}},"main.rb":["txt","require \'dxruby\'\\r\\nrequire \'json\'\\r\\nrequire \'time\'\\r\\nrequire \'pp\'\\r\\n\\r\\n$PATH = File.dirname(__FILE__)\\r\\n\\r\\nWindow.width = 1280\\r\\nWindow.height = 960\\r\\nWindow.scale = 0.8\\r\\nWindow.caption = \'Spell Out\'\\r\\nWindow.bgcolor = [26, 26, 26]\\r\\n\\r\\nFont.install(\\"#{$PATH}/assets/font/Poco.ttf\\")\\r\\nFont.install(\\"#{$PATH}/assets/font/misaki_gothic.ttf\\")\\r\\n\\r\\n$debug_mode = ARGV.include?(\'debug\') || ARGV.include?(\'-d\')\\r\\n$score = 0\\r\\n$stage = 1\\r\\n\\r\\nrequire_relative \'lib/utils/wrapper\'\\r\\nrequire_relative \'lib/utils/scene_manager\'\\r\\nrequire_relative \'lib/utils/debugger\'\\r\\nrequire_relative \'lib/utils/bgm\'\\r\\nrequire_relative \'lib/utils/se\'\\r\\nrequire_relative \'lib/utils/hp_bar\'\\r\\nrequire_relative \'lib/utils/text_box\'\\r\\nrequire_relative \'lib/utils/seek_bar\'\\r\\nrequire_relative \'lib/player\'\\r\\nrequire_relative \'lib/bullet\'\\r\\nrequire_relative \'lib/enemy\'\\r\\nrequire_relative \'lib/stage\'\\r\\nrequire_relative \'lib/data/sprite_data\'\\r\\nrequire_relative \'lib/data/enemies_data\'\\r\\nrequire_relative \'lib/data/bullet_data\'\\r\\nrequire_relative \'lib/data/stage_data\'\\r\\nrequire_relative \'lib/scenes/loading\'\\r\\nrequire_relative \'lib/scenes/title\'\\r\\nrequire_relative \'lib/scenes/stage_select\'\\r\\nrequire_relative \'lib/scenes/play_cut_in\'\\r\\nrequire_relative \'lib/scenes/play\'\\r\\nrequire_relative \'lib/scenes/menu\'\\r\\nrequire_relative \'lib/scenes/game_over\'\\r\\nrequire_relative \'lib/scenes/ranking\'\\r\\n\\r\\nDebugger.new(font_size: 48)\\r\\n\\r\\nSceneManager.new({\\r\\n  title: Title,\\r\\n  stage_select: StageSelect,\\r\\n  play_cut_in: PlayCutIn,\\r\\n  play: Play,\\r\\n  menu: Menu,\\r\\n  game_over: GameOver,\\r\\n  ranking: Ranking,\\r\\n})\\r\\n\\r\\nWindow.loop do\\r\\n  Window.close if Input.key_down?(K_ESCAPE)\\r\\n\\r\\n  Mouse.update\\r\\n  SceneManager.update\\r\\n  SceneManager.draw\\r\\n  BGM.update\\r\\n  if $debug_mode\\r\\n    Debugger.block_call\\r\\n    Debugger.draw_msg\\r\\n  end\\r\\nend\\r\\n"],"playground":{"easing_sample.rb":["txt","require \'dxruby\'\\r\\nrequire_relative \'./../lib/utils/easing\'\\r\\n\\r\\nWindow.bgcolor = C_WHITE\\r\\n\\r\\nboxes = []\\r\\n6.times do |i|\\r\\n  boxes << Sprite.new(60, 40 + 45 * i, Image.new(40, 40, [120, 160, 240]))\\r\\nend\\r\\n\\r\\nsp = Sprite.new(60, 320, Image.new(40, 40, [210, 120, 160, 240]))\\r\\nboxes2 = []\\r\\n3.times do |y|\\r\\n  boxes2 << Sprite.new(60, 380 + y * 23, Image.new(20, 20, [170, 120, 160, 240]))\\r\\nend\\r\\n\\r\\n\\r\\nfont = Font.new(24, \\"Comic sans MS\\")\\r\\n\\r\\nWindow.loop do\\r\\n  break if Input.key_down?(K_ESCAPE)\\r\\n\\r\\n  if Input.key_push?(K_SPACE)\\r\\n    Easing.new(sp, :x, :ease_in_out_quad, 60, 260)\\r\\n    Easing.new(boxes2, :x, :ease_in_out_quad, 60, 260)\\r\\n  end\\r\\n\\r\\n  boxes[0].x = Easing.ease_in_quart(        60, 260)\\r\\n  boxes[1].x = Easing.ease_out_quart(       60, 260)\\r\\n  boxes[2].x = Easing.ease_in_out_quad(    60, 260)\\r\\n  boxes[3].x = Easing.ease_in_sine(    60, 260)\\r\\n  boxes[4].x = Easing.ease_out_sine(   60, 260)\\r\\n  boxes[5].x = Easing.ease_in_out_sine(60, 260)\\r\\n\\r\\n  boxes.length.times do |i|\\r\\n    Window.draw_font_ex(10, 50 + 45 * i, \\"#{((boxes[i].x - 60) * 100.0 / 260).round}%\\", font, color: C_BLACK)\\r\\n  end\\r\\n  Sprite.draw(boxes)\\r\\n  Sprite.draw(boxes2)\\r\\n  sp.draw\\r\\n\\r\\n  Window.draw_font_ex(0, 0, \\"fps: #{Window.real_fps}\\", font, color: C_BLACK)\\r\\nend\\r\\n"],"scrollable_page_test.rb":["txt","require \'dxruby\'\\r\\nrequire_relative \'../lib/utils/scrollable_page\'\\r\\n\\r\\nFont.install(\'MonospaceBold.ttf\')\\r\\n\\r\\npage = ScrollablePage.new(500, 400, bgcolor: [34, 34, 34], page_height: 800)\\r\\n\\r\\nfont = Font.new(24)\\r\\nfont_code = Font.new(21, \'Monospace\')\\r\\n\\r\\nusage = \\"\\r\\npage = ScrollablePage.new(\\r\\n  500, 400, bgcolor: [34, 34, 34], page_height: 800\\r\\n)\\r\\n\\r\\na = Sprite.new(100, 0, Image.new(50, 50, C_RED))\\r\\na.target = page\\r\\n\\r\\nWindow.loop do\\r\\n  break if Input.key_down? K_ESCAPE\\r\\n\\r\\n  page.update\\r\\n\\r\\n  page.draw_font(10, 550, \\\\\'Sample Text\\\\\', font)\\r\\n  a.y = 650 - page.pos\\r\\n  a.draw\\r\\n\\r\\n  page.draw_scrollbar\\r\\n  Window.draw(70, 40, page)\\r\\nend\\r\\n\\".split(/\\\\R/)\\r\\n\\r\\na = Sprite.new(100, 0, Image.new(50, 50, C_RED))\\r\\na.target = page\\r\\n\\r\\nWindow.loop do\\r\\n  break if Input.key_down? K_ESCAPE\\r\\n\\r\\n  page.update\\r\\n\\r\\n  page.draw_font(10, 10, \\"FPS : #{Window.real_fps}\\", font)\\r\\n  page.draw_font(10, 34, \'class ScrollablePage\', font)\\r\\n  page.draw_font(10, 60, \'ãƒã‚¦ã‚¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§å‹•ã‹ã›ã¾ã™\', font)\\r\\n  usage.length.times do |i|\\r\\n    page.draw_font(10, 100 + font_code.size * i, usage[i], font_code)\\r\\n  end\\r\\n  page.draw_font(10, 550, \'result ... \', font)\\r\\n  page.draw_font(10, 600, \'Sample Text\', font)\\r\\n  str = \'Â© stonesaw\'\\r\\n  page.draw_font((page.width - font.get_width(str)) / 2, 800 - 34, str, font)\\r\\n\\r\\n  a.y = 650 - page.pos\\r\\n  a.draw\\r\\n\\r\\n  page.draw_scrollbar\\r\\n  Window.draw(70, 40, page)\\r\\n\\r\\n  Window.draw_font(10, 10, page.pos.to_s, font)\\r\\nend\\r\\n"]},"repo.link":["link","https://github.com/stonesaw/Spell-Out"]}}}')},790:function(n){n.exports=JSON.parse('{"test":{"hello":"hello world","format":"Hi, {name}!","multiline":["multiline with array","line: {one}","line: {two}"]},"help":{"summary":{"cd":"change directory.","ls":"list segments.","cat":"show txt file content.","history":"command history.","lang":"change language.","open":"open link file.","share":"share sns."}},"messages":{"clear_history":"cleared history","no_history":"no history"},"errors":{"is_not_dir":"\\"{dir_name}\\" is not directory","is_not_link":"\\"{dir_name}\\" is not link","is_not_text":"\\"{dir_name}\\" is not text","no_such_dirs":"No such directory or file"}}')},8566:function(n){n.exports=JSON.parse('{"test":{"hello":"ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œ","format":"ã“ã‚“ã«ã¡ã¯ï¼{name}ï¼","multiline":["é…åˆ—ã‚’ä½¿ã†ã¨è¤‡æ•°è¡Œã®æ–‡å­—ã‚’è¡¨ç¤ºã§ãã¾ã™","{one}è¡Œç›®","{two}è¡Œç›®"]},"help":{"summary":{"cd":"ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ç§»å‹•ã—ã¾ã™ã€‚","ls":"ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªã‚¹ãƒˆè¡¨ç¤ºã—ã¾ã™ã€‚","cat":"ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚","history":"ã‚³ãƒãƒ³ãƒ‰ã®å±¥æ­´ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚","lang":"è¨€èªã‚’å¤‰æ›´ã—ã¾ã™ã€‚","open":"ãƒªãƒ³ã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãã¾ã™ã€‚","share":"SNSã§ã‚·ã‚§ã‚¢ã—ã¾ã™ã€‚"}},"messages":{"clear_history":"å±¥æ­´ã‚’å‰Šé™¤ã—ã¾ã—ãŸ","no_history":"å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“"},"errors":{"is_not_dir":"\\"{dir_name}\\" ã¯ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã¯ã‚ã‚Šã¾ã›ã‚“","is_not_link":"\\"{dir_name}\\" ã¯ ãƒªãƒ³ã‚¯ã§ã¯ã‚ã‚Šã¾ã›ã‚“","is_not_text":"\\"{dir_name}\\" ã¯ ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ã‚ã‚Šã¾ã›ã‚“","no_such_dirs":"ãã®ã‚ˆã†ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“"}}')}},e={};function r(t){var a=e[t];if(void 0!==a)return a.exports;var i=e[t]={exports:{}};return n[t](i,i.exports,r),i.exports}r.m=n,function(){var n=[];r.O=function(e,t,a,i){if(!t){var s=1/0;for(_=0;_<n.length;_++){t=n[_][0],a=n[_][1],i=n[_][2];for(var l=!0,o=0;o<t.length;o++)(!1&i||s>=i)&&Object.keys(r.O).every((function(n){return r.O[n](t[o])}))?t.splice(o--,1):(l=!1,i<s&&(s=i));if(l){n.splice(_--,1);var d=a();void 0!==d&&(e=d)}}return e}i=i||0;for(var _=n.length;_>0&&n[_-1][2]>i;_--)n[_]=n[_-1];n[_]=[t,a,i]}}(),function(){r.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return r.d(e,{a:e}),e}}(),function(){r.d=function(n,e){for(var t in e)r.o(e,t)&&!r.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})}}(),function(){r.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"===typeof window)return window}}()}(),function(){r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)}}(),function(){var n={143:0};r.O.j=function(e){return 0===n[e]};var e=function(e,t){var a,i,s=t[0],l=t[1],o=t[2],d=0;if(s.some((function(e){return 0!==n[e]}))){for(a in l)r.o(l,a)&&(r.m[a]=l[a]);if(o)var _=o(r)}for(e&&e(t);d<s.length;d++)i=s[d],r.o(n,i)&&n[i]&&n[i][0](),n[i]=0;return r.O(_)},t=self["webpackChunkcli"]=self["webpackChunkcli"]||[];t.forEach(e.bind(null,0)),t.push=e.bind(null,t.push.bind(t))}();var t=r.O(void 0,[998],(function(){return r(8785)}));t=r.O(t)})();
//# sourceMappingURL=app.f9cc12cb.js.map