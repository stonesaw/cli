(function(){"use strict";var n={8785:function(n,e,r){var t=r(9242),a=r(3396);const i={id:"app"};function s(n,e,r,t,s,l){const o=(0,a.up)("CLI");return(0,a.wg)(),(0,a.iD)("div",i,[(0,a.Wm)(o,{ref:"cli"},null,512)])}var l=r(7139);const o=n=>((0,a.dD)("data-v-7a0a4bcf"),n=n(),(0,a.Cn)(),n),d={class:"cli-main"},_=o((()=>(0,a._)("span",{class:"cli-head"},"stonesaw.github.io ",-1))),c={class:"cli-dir"},p=o((()=>(0,a._)("span",{class:"cli-head"}," $ ",-1))),m={class:"cli-input-history"},u=["innerHTML"],f=o((()=>(0,a._)("span",{class:"cli-head"},"stonesaw.github.io ",-1))),h={class:"cli-dir"},g=o((()=>(0,a._)("span",{class:"cli-head"}," $ ",-1)));function w(n,e,r,t,i,s){const o=(0,a.up)("CLIStart"),w=(0,a.up)("CLIInput");return(0,a.wg)(),(0,a.iD)("div",d,[(0,a.Wm)(o),((0,a.wg)(!0),(0,a.iD)(a.HY,null,(0,a.Ko)(n.histories,((n,e)=>((0,a.wg)(),(0,a.iD)("div",{key:e,class:"cli-history"},[_,(0,a._)("span",c,(0,l.zw)(n.dir.join("/")),1),p,(0,a._)("span",m,(0,l.zw)(n.input),1),((0,a.wg)(!0),(0,a.iD)(a.HY,null,(0,a.Ko)(n.result_ary,((n,e)=>((0,a.wg)(),(0,a.iD)("div",{key:e},[(0,a._)("span",{class:"cli-result",innerHTML:n},null,8,u)])))),128))])))),128)),(0,a._)("div",null,[f,(0,a._)("span",h,(0,l.zw)(n.working_dir.join("/")),1),g,(0,a.Wm)(w,{ref:"input",onExecCmd:n.inputEnter,onComplementDir:n.inputTab},null,8,["onExecCmd","onComplementDir"])])])}r(7658);const b={class:"cli-start"},y=(0,a._)("div",null,[(0,a._)("div",null," _       __     __                             __           ________    ____   __"),(0,a._)("div",null,"| |     / /__  / /________  ____ ___  ___     / /_____     / ____/ /   /  _/  / /"),(0,a._)("div",null,"| | /| / / _ \\/ / ___/ __ \\/ __ `__ \\/ _ \\   / __/ __ \\   / /   / /    / /   / / "),(0,a._)("div",null,"| |/ |/ /  __/ / /__/ /_/ / / / / / /  __/  / /_/ /_/ /  / /___/ /____/ /   /_/  "),(0,a._)("div",null,"|__/|__/\\___/_/\\___/\\____/_/ /_/ /_/\\___/   \\__/\\____/   \\____/_____/___/  (_)   ")],-1),v=(0,a._)("div",null,"Welcome to cli",-1),x=[y,v];function k(n,e){return(0,a.wg)(),(0,a.iD)("div",b,x)}var S=r(89);const W={},I=(0,S.Z)(W,[["render",k]]);var E=I;function P(n,e,r,i,s,l){return(0,a.wg)(),(0,a.iD)("span",{class:"cli-input",onKeydown:[e[2]||(e[2]=(0,t.D2)(((...e)=>n.pressKeyUp&&n.pressKeyUp(...e)),["up"])),e[3]||(e[3]=(0,t.D2)(((...e)=>n.pressKeyDown&&n.pressKeyDown(...e)),["down"])),e[4]||(e[4]=(0,t.D2)(((...e)=>n.pressKeyTab&&n.pressKeyTab(...e)),["tab"]))]},[(0,a.wy)((0,a._)("input",{ref:"input","onUpdate:modelValue":e[0]||(e[0]=e=>n.inputText=e),type:"text",autofocus:"",maxlength:"50",onKeydown:e[1]||(e[1]=(0,t.D2)(((...e)=>n.pressKeyEnter&&n.pressKeyEnter(...e)),["enter"]))},null,544),[[t.nr,n.inputText]])],32)}var j=(0,a.aZ)({emits:["exec-cmd","complement-dir"],data(){return{inputText:"",history:[],historyIndex:null,inputCurrent:""}},mounted(){this.loadHistory()},methods:{refs(){return this.$refs},focus(){this.refs().input.focus()},loadHistory(){if(localStorage.getItem("history"))try{this.history=JSON.parse(localStorage.getItem("history"))}catch(n){localStorage.removeItem("history")}},saveHistory(){const n=JSON.stringify(this.history);localStorage.setItem("history",n)},clearHistory(){this.history=[]},pressKeyEnter(){this.$emit("exec-cmd",this.inputText),""!==this.inputText&&this.history[this.history.length-1]!==this.inputText&&(this.history.push(this.inputText),this.historyIndex=null,this.saveHistory()),this.inputText="",this.inputCurrent=""},pressKeyTab(n){n.preventDefault(),this.$emit("complement-dir",this.inputText)},pressKeyUp(n){n.preventDefault(),this.history.length>0&&(null===this.historyIndex&&(this.historyIndex=this.history.length,this.inputCurrent=this.inputText),this.historyIndex=Math.max(this.historyIndex-1,0),this.inputText=this.history[this.historyIndex])},pressKeyDown(n){n.preventDefault(),this.history.length>0&&null!==this.historyIndex&&(this.historyIndex===this.history.length-1?(this.historyIndex=null,this.inputText=this.inputCurrent):(this.historyIndex=Math.min(this.historyIndex+1,this.history.length-1),this.inputText=this.history[this.historyIndex]))}}});const C=(0,S.Z)(j,[["render",P],["__scopeId","data-v-38317d10"]]);var A=C;function D(n){return null!==n&&void 0!==n||Array.isArray(n)&&T(n)}function T(n){return!(n.length>0)}function M(n,e){const r=Object.prototype.toString.call(e).slice(8,-1);return void 0!==e&&null!==e&&r===n}function $(n){return M("Object",n)}var O=r(2482);const B=r(790),z=r(8566),H={en:B,ja:z};class L{static isAllowedLocale(n){return"en"===n||"ja"===n}static setLocale(n){if(!this.isAllowedLocale(n))throw new Error(`don't know locale '${n}'`);this.locale=n}static t(n,e){let r=this._searchMessage(n);Array.isArray(r)&&(r=r.join("\n"));for(const[t,a]of Object.entries(e||{})){if(!RegExp(`{${t}}`).test(r))throw new Error(`i18n.t() unknown format '${t}'\n  local: ${this.locale}`);r=r.replace(`{${t}}`,a||"")}return r}static _searchMessage(n){if(this.locale in H){const e=H[this.locale],r=n.split(".").filter((n=>""!==n));let t=e;for(let a=0;a<r.length;a++){const e=t[r[a]];if("string"===typeof e||Array.isArray(e)){if(a<r.length-1)throw new Error(`i18n.t() key '${n}' at '${r[a+1]}' is not found!.\n  local: ${this.locale}`);return e}t=e}throw new Error(`i18n.t() key '${n}' is not found!\n  local: ${this.locale}`)}throw new Error(`i18n.t() local '${this.locale}' is not found!`)}}(0,O.Z)(L,"locale","en");var K=L;const R=r(7832);function F(n){return void 0!==n.childDir}function q(n){return void 0!==n?.content}function N(n,e){for(const[r,t]of Object.entries(n))if(Array.isArray(t)){let n={path:`${e.path}/${r}`,name:r,type:t[0],content:t[1]||"",parentDir:e};e.childDir.push(n)}else{if(!$(t))throw`can't generate directory ( key:${r}, value:${t} )`;{let t={path:`${e.path}/${r}`,name:r,childDir:[],parentDir:e};e.childDir.push(t),N(n[`${r}`],t)}}}let G={path:"~",name:"~",childDir:[],parentDir:null};function U(n){let e="";for(let r=0;r<n.length;r++){const t=n[r];F(t)?e+=`${t.name}/   `:e+=`${t.name}    `}return e}function V(n,e=/.*/){return n.childDir.filter((n=>e.test(n.name)))}function J(n,e){const r=e.split("/").filter((n=>""!==n&&"."!==n));return"~"===r[0]?r:n.concat(r)}function Z(n,e="./"){const r=J(n,e);"~"===r[0]&&r.shift();let t=G;for(let a=0;a<r.length;a++){const n=r[a];if(q(t))return{error:K.t("errors.no_such_dirs"),info:t};if("."===n);else if(".."===n)null===t.parentDir||(t=t.parentDir);else{let e=!1;for(let r=0;r<t.childDir.length;r++)if(t.childDir[r].name===n){t=t.childDir[r],e=!0;break}if(!e)return{error:K.t("errors.no_such_dirs"),info:t}}}return t}function X(n,e="./"){const r=e.split("/").filter((n=>""!==n&&"."!==n)),t=Z(n,e);if(!q(t)){let n;switch(n=F(t)?t.childDir:F(t.info)?V(t.info,RegExp(`^${r[r.length-1]||""}.*`)):[],n.length){case 0:return null;case 1:let e;return F(t)?e=r.concat([n[0].name]).join("/"):(r[r.length-1]=n[0].name,e=r.join("/")),{dir:e+(F(n[0])?"/":"")};default:return U(n)}}return null}function Y(n,e){const r=Z(n,e[0]||"~");return q(r)?{error:K.t("errors.is_not_dir",{dir_name:e[0]})}:F(r)?{dir:r.path.split("/")}:{error:r.error}}function Q(n,e){const r=Z(n,e[0]);return q(r)?[K.t("errors.is_not_dir",{dir_name:e[0]}),null]:F(r)?[U(r.childDir),null]:[r.error,null]}function nn(n,e){if(!D(e[0])||"-h"===e[0]||"--help"===e[0])return["cat help",null];const r=Z(n,e[0]);return F(r)||q(r)?F(r)||"txt"!==r.type?[K.t("errors.is_not_text",{dir_name:e[0]}),null]:[r.content,null]:[r.error,null]}function en(n){if(n.includes("-clear"))return localStorage.removeItem("history"),[K.t("messages.clear_history"),null];let e=[];if(!localStorage.getItem("history"))return[K.t("messages.no_history"),null];try{e=JSON.parse(localStorage.getItem("history"))}catch(a){localStorage.removeItem("history")}const r=Math.log10(e.length)+1;let t="";return e.forEach(((n,e)=>{t+=` ${e.toString().padStart(r," ")}  ${n}\n`})),[t.replace(/\n$/,""),null]}function rn(n,e){if(!D(e[0])||"-h"===e[0]||"--help"===e[0])return{msg:"open help"};const r=Z(n,e[0]);return F(r)||q(r)?F(r)||"link"!==r.type?{error:K.t("errors.is_not_link",{dir_name:e[0]})}:{data:r.content}:{error:r.error}}N(R["~"],G);var tn=(0,a.aZ)({name:"CLI",components:{CLIStart:E,CLIInput:A},data(){return{working_dir:["~","cli"],histories:[],commands:[{name:"cd",args:"[dir]"},{name:"ls",args:"[dir]"},{name:"cat",args:"[file]"},{name:"history",args:"[-clear]"},{name:"lang",args:"[en|ja]"},{name:"open",args:"[link_file]"},{name:"share",args:"[-tw]"}],afterInputActions:[]}},methods:{refs(){return this.$refs},focus(){this.refs().input.focus()},inputEnter(n){const e=this.execCommand(n);var r;null===e[0]?r=[""]:"html"===e[1]?r=e[0].split("\n"):(r=this.textToHtml(e[0]).split("\n"),r=r.map((n=>""===n?"&nbsp;":n))),this.histories.push({input:n,dir:this.working_dir,result_ary:r}),this.afterInputActions.forEach((n=>{n(this)})),this.afterInputActions=[]},inputTab(n){const e=n.split(" ").filter((n=>""!==n));if(0===e.length||!["cd","ls","cat","open"].includes(e[0]))return null;const r=X(this.working_dir,e[1]);if("string"===typeof r){let e=this.textToHtml(r).split("\n");this.histories.push({input:n,dir:this.working_dir,result_ary:e})}else{if(!r?.dir)return null;this.refs().input.inputText=`${e[0]} ${r.dir}`}},execCommand(n){const e=n.split(" ").filter((n=>""!==n));if(0===e.length)return[null,null];switch(e[0]){case"help":{let n=0,e="Command list\n";return this.commands.forEach((e=>{n=Math.max(n,e.name.length+e.args.length)})),this.commands.forEach((r=>{let t=r.name.length+r.args.length;e+=` * ${r.name} ${r.args}${" ".repeat(n-t+4)}:${K.t(`help.summary.${r.name}`)}\n`})),[e.trim(),null]}case"cd":{let n=Y(this.working_dir,e.splice(1));return void 0==n.error&&this.afterInputActions.push((function(e){e.working_dir=n.dir})),[n.error||null,null]}case"ls":return Q(this.working_dir,e.splice(1));case"cat":return nn(this.working_dir,e.splice(1));case"history":return"-clear"===e[1]&&this.refs().input.clearHistory(),en(e.splice(1));case"lang":if(!e[1]||""===e[1])return[`current lang is ${K.locale}`,null];try{return K.setLocale(e[1]),[`lang: set language '${e[1]}'`,null]}catch(r){return[`lang: can't set language '${e[1]}'`,null]}case"open":{let n=rn(this.working_dir,e.splice(1));return n.error?[n.error,null]:n.msg?[n.msg,null]:(window.open(n.data),[`open: ${n.data}`,null])}case"share":return"-tw"===e[1]?(window.open("http://twitter.com/share?text=%F0%9F%AB%A1%20Hello,%20web-cli%0Acheck%20it%20...%20&url=https://stonesaw.github.io/cli/%0A&hashtags=indiedev,webdev,opensource&related=sou_0x0v"),['<a href="http://twitter.com/share?text=%F0%9F%AB%A1%20Hello,%20web-cli%0Acheck%20it%20...%20&url=https://stonesaw.github.io/cli/%0A&hashtags=indiedev,webdev,opensource&related=sou_0x0v" target="_blank">Share on Twitter</a>',"html"]):["<u>https://stonesaw.github.io/cli/</u>","html"];default:return[`Command '${e[0]}' is not found! Use 'help' to see the command list.`,null]}},textToHtml(n){return n.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll(" ","&nbsp;")}}});const an=(0,S.Z)(tn,[["render",w],["__scopeId","data-v-7a0a4bcf"]]);var sn=an,ln=(0,a.aZ)({components:{CLI:sn},mounted(){document.addEventListener("keydown",this.onKeyDown)},onUnmounted(){document.removeEventListener("keydown",this.onKeyDown)},methods:{refs(){return this.$refs},onKeyDown(){this.refs().cli.focus();let n=document.documentElement,e=n.scrollHeight-n.clientHeight;window.scroll(0,e)}}});const on=(0,S.Z)(ln,[["render",s]]);var dn=on;(0,t.ri)(dn).mount("#app")},7832:function(n){n.exports=JSON.parse('{"~":{"cli":{"README.md":["txt","# 🎈 [cli](https://stonesaw.github.io/cli)\\nhttps://stonesaw.github.io/cli  \\n[ 🔨 Building now ...]  \\nImplement the cli interface on the web  \\n\\n\\n## ✨ Features\\n```bash\\nstonesaaw.github.io> cd portfolio\\n                     # => Redirecting to portfolio/\\n\\nstonesaaw.github.io> ls\\n                     # => portfolio/\\n                     # => blog/\\n                     # => ...\\n```\\n"],"repo.link":["link","https://github.com/stonesaw/cli"],"src":{"assets":{"logo.png":["img"]}}},"portfolio":{".github":{"workflows":{"cd.yml":["txt","name: cd\\r\\n\\r\\non: [push, pull_request]\\r\\n\\r\\njobs:\\r\\n  cd:\\r\\n    runs-on: ${{ matrix.os }}\\r\\n\\r\\n    strategy:\\r\\n      matrix:\\r\\n        os: [ubuntu-latest]\\r\\n        node: [14]\\r\\n\\r\\n    steps:\\r\\n      - name: Checkout\\r\\n        uses: actions/checkout@master\\r\\n\\r\\n      - name: Setup node env\\r\\n        uses: actions/setup-node@v2.1.2\\r\\n        with:\\r\\n          node-version: ${{ matrix.node }}\\r\\n\\r\\n      - name: Install dependencies\\r\\n        run: yarn\\r\\n\\r\\n      - name: Generate\\r\\n        run: yarn run build\\r\\n\\r\\n      - name: Deploy\\r\\n        uses: peaceiris/actions-gh-pages@v3\\r\\n        with:\\r\\n          github_token: ${{ secrets.GITHUB_TOKEN }}\\r\\n          publish_dir: ./dist\\r\\n"]}},".gitignore":["txt",".DS_Store\\nnode_modules\\ndist/\\n\\n# local env files\\n.env.local\\n.env.*.local\\n\\n# Log files\\nnpm-debug.log*\\nyarn-debug.log*\\nyarn-error.log*\\npnpm-debug.log*\\n\\n# Editor directories and files\\n.idea\\n.vscode\\n*.suo\\n*.ntvs*\\n*.njsproj\\n*.sln\\n*.sw?\\n"],".rubocop.yml":["txt","inherit_from:\\r\\n  - .rubocop_todo.yml\\r\\n  - .rubocop_airbnb.yml\\r\\n\\r\\nRails:\\r\\n  Enabled: false\\r\\n\\r\\n# {} は 1 行で書くときに主に使われるので、スペースよりも\\r\\n# 横に長くならない方が嬉しさが多い。\\r\\n# そもそも {| のスタイルの方が一般的だったと認識している。\\r\\nLayout/SpaceInsideBlockBraces:\\r\\n  SpaceBeforeBlockParameters: false\\r\\n\\r\\n# 2行以上の空行を許可する\\r\\nLayout/EmptyLines:\\r\\n  Enabled: false\\r\\n\\r\\n# 行の長さの最大値を110に\\r\\nMetrics/LineLength:\\r\\n  Max: 110\\r\\n"],".rubocop_airbnb.yml":["txt","require:\\r\\n  - rubocop-airbnb\\r\\n"],".rubocop_todo.yml":["txt","# This configuration was generated by\\r\\n# `rubocop --auto-gen-config`\\r\\n# on 2021-02-25 07:49:09 +0900 using RuboCop version 0.76.0.\\r\\n# The point is for the user to remove these configuration records\\r\\n# one by one as the offenses are removed from the code base.\\r\\n# Note that changes in the inspected code, or installation of new\\r\\n# versions of RuboCop, may require this file to be generated again.\\r\\n\\r\\n# Offense count: 2\\r\\nSecurity/Eval:\\r\\n  Exclude:\\r\\n    - \'lib/utils/scrollable_page.rb\'\\r\\n    - \'lib/utils/text_box.rb\'\\r\\n"],"CODE_OF_CONDUCT.md":["txt","# Contributor Covenant Code of Conduct\\n\\n## Our Pledge\\n\\nIn the interest of fostering an open and welcoming environment, we as\\ncontributors and maintainers pledge to making participation in our project and\\nour community a harassment-free experience for everyone, regardless of age, body\\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\\nlevel of experience, education, socio-economic status, nationality, personal\\nappearance, race, religion, or sexual identity and orientation.\\n\\n## Our Standards\\n\\nExamples of behavior that contributes to creating a positive environment\\ninclude:\\n\\n* Using welcoming and inclusive language\\n* Being respectful of differing viewpoints and experiences\\n* Gracefully accepting constructive criticism\\n* Focusing on what is best for the community\\n* Showing empathy towards other community members\\n\\nExamples of unacceptable behavior by participants include:\\n\\n* The use of sexualized language or imagery and unwelcome sexual attention or\\n advances\\n* Trolling, insulting/derogatory comments, and personal or political attacks\\n* Public or private harassment\\n* Publishing others\' private information, such as a physical or electronic\\n address, without explicit permission\\n* Other conduct which could reasonably be considered inappropriate in a\\n professional setting\\n\\n## Our Responsibilities\\n\\nProject maintainers are responsible for clarifying the standards of acceptable\\nbehavior and are expected to take appropriate and fair corrective action in\\nresponse to any instances of unacceptable behavior.\\n\\nProject maintainers have the right and responsibility to remove, edit, or\\nreject comments, commits, code, wiki edits, issues, and other contributions\\nthat are not aligned to this Code of Conduct, or to ban temporarily or\\npermanently any contributor for other behaviors that they deem inappropriate,\\nthreatening, offensive, or harmful.\\n\\n## Scope\\n\\nThis Code of Conduct applies both within project spaces and in public spaces\\nwhen an individual is representing the project or its community. Examples of\\nrepresenting a project or community include using an official project e-mail\\naddress, posting via an official social media account, or acting as an appointed\\nrepresentative at an online or offline event. Representation of a project may be\\nfurther defined and clarified by project maintainers.\\n\\n## Enforcement\\n\\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\\nreported by contacting the project team at mail.sou.dev@gmail.com. All\\ncomplaints will be reviewed and investigated and will result in a response that\\nis deemed necessary and appropriate to the circumstances. The project team is\\nobligated to maintain confidentiality with regard to the reporter of an incident.\\nFurther details of specific enforcement policies may be posted separately.\\n\\nProject maintainers who do not follow or enforce the Code of Conduct in good\\nfaith may face temporary or permanent repercussions as determined by other\\nmembers of the project\'s leadership.\\n\\n## Attribution\\n\\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\\n\\n[homepage]: https://www.contributor-covenant.org\\n\\nFor answers to common questions about this code of conduct, see\\nhttps://www.contributor-covenant.org/faq\\n"],"README.md":["txt","<img src=\\"./logo.png\\" width=\\"30%\\" align=\\"right\\" />\\r\\n\\r\\n# Spell Out\\r\\n- マウス操作のアクションシューティング\\r\\n- 5つの属性(🔥💧🌬⚜💀)と属性ごとの攻撃・スキル\\r\\n- 属性の相性によってダメージ量が変化\\r\\n- 全6 ステージ\\r\\n- (みかわし) *todo*  \\r\\n詳しい操作方法などは、[how-to.md](how-to.md) を見てね  \\r\\n\\r\\n\\r\\n## GitHub\\r\\nhttps://github.com/stonesaw/Spell-Out\\r\\n\\r\\n## 使用アセット\\r\\n- ライブラリ : [DXRuby](http://dxruby.osdn.jp/)\\r\\n- 音源  \\r\\n    [魔王魂様](https://maoudamashii.jokersounds.com/)  \\r\\n    [Tallbeard Studios様](https://tallbeard.itch.io/music-loop-bundle)\\r\\n- 画像  \\r\\n    [ヌー様](http://damagedgold.wp.xdomain.jp/2016/03/25/link/)  \\r\\n    [尾羽の小屋様](http://obane.tuzikaze.com/)\\r\\n- フォント  \\r\\n    [jeti様](https://fontmeme.com/jfont/poco-font/)\\r\\n    \\r\\n\\r\\n## 開発ツール & リンク集\\r\\n- vscode ext  \\r\\n  Ruby Solargraph (https://marketplace.visualstudio.com/items?itemName=castwide.solargraph)  \\r\\n  endwise (https://marketplace.visualstudio.com/items?itemName=kaiwood.endwise)  \\r\\n- DXRuby API Reference (http://mirichi.github.io/dxruby-doc/api/index.html)  \\r\\n"],"babel.config.js":["txt","module.exports = {\\n  presets: [\\n    \\"@vue/cli-plugin-babel/preset\\"\\n  ]\\n}\\n"],"assets":{"font":{},"image":{},"sound":{}},"jsconfig.json":["txt","{\\n  \\"compilerOptions\\": {\\n    \\"target\\": \\"es5\\",\\n    \\"module\\": \\"esnext\\",\\n    \\"baseUrl\\": \\"./\\",\\n    \\"moduleResolution\\": \\"node\\",\\n    \\"paths\\": {\\n      \\"@/*\\": [\\n        \\"src/*\\"\\n      ]\\n    },\\n    \\"lib\\": [\\n      \\"esnext\\",\\n      \\"dom\\",\\n      \\"dom.iterable\\",\\n      \\"scripthost\\"\\n    ]\\n  }\\n}\\n"],"package-lock.json":["txt","too longer."],"package.json":["txt","{\\n  \\"name\\": \\"portfolio\\",\\n  \\"version\\": \\"0.1.0\\",\\n  \\"private\\": true,\\n  \\"scripts\\": {\\n    \\"serve\\": \\"vue-cli-service serve\\",\\n    \\"build\\": \\"vue-cli-service build\\",\\n    \\"lint\\": \\"vue-cli-service lint\\"\\n  },\\n  \\"dependencies\\": {\\n    \\"core-js\\": \\"^3.8.3\\",\\n    \\"vue\\": \\"^2.6.14\\",\\n    \\"vuetify\\": \\"^2.6.0\\"\\n  },\\n  \\"devDependencies\\": {\\n    \\"@babel/core\\": \\"^7.12.16\\",\\n    \\"@babel/eslint-parser\\": \\"^7.12.16\\",\\n    \\"@vue/cli-plugin-babel\\": \\"~5.0.0\\",\\n    \\"@vue/cli-plugin-eslint\\": \\"~5.0.0\\",\\n    \\"@vue/cli-service\\": \\"~5.0.0\\",\\n    \\"eslint\\": \\"^7.32.0\\",\\n    \\"eslint-plugin-vue\\": \\"^8.0.3\\",\\n    \\"sass\\": \\"~1.32.0\\",\\n    \\"sass-loader\\": \\"^10.0.0\\",\\n    \\"vue-cli-plugin-vuetify\\": \\"~2.5.2\\",\\n    \\"vue-template-compiler\\": \\"^2.6.14\\",\\n    \\"vuetify-loader\\": \\"^1.7.0\\"\\n  },\\n  \\"eslintConfig\\": {\\n    \\"root\\": true,\\n    \\"env\\": {\\n      \\"node\\": true\\n    },\\n    \\"extends\\": [\\n      \\"plugin:vue/essential\\",\\n      \\"eslint:recommended\\"\\n    ],\\n    \\"parserOptions\\": {\\n      \\"parser\\": \\"@babel/eslint-parser\\"\\n    },\\n    \\"rules\\": {}\\n  },\\n  \\"browserslist\\": [\\n    \\"> 1%\\",\\n    \\"last 2 versions\\",\\n    \\"not dead\\"\\n  ]\\n}\\n"],"public":{"index.html":["txt","<!DOCTYPE html>\\n<html lang=\\"ja\\">\\n  <head prefix=\\"og:http://ogp.me/ns#\\">\\n    <meta charset=\\"utf-8\\">\\n    <meta http-equiv=\\"X-UA-Compatible\\" content=\\"IE=edge\\">\\n    <meta name=\\"viewport\\" content=\\"width=device-width,initial-scale=1.0\\">\\n    <link rel=\\"icon\\" href=\\"./favicon.ico\\">\\n    <title>Sou\'s Portfolio on GitHub Pages</title>\\n    <meta name=\\"description\\" content=\\"Souのポートフォリオサイト。成果物やエンジニアとしてのスキルなどなど... Vue.jsとVuetifyを使用し開発しました。\\">\\n    <meta name=\\"keywords\\" content=\\"ポートフォリオ,プログラミング,デザイン,Vue.js,GitHub\\">\\n\\n    \x3c!-- OGP --\x3e\\n    <meta property=\\"og:title\\" content=\\"Sou\'s Portfolio\\">\\n    <meta property=\\"og:description\\" content=\\"Souのポートフォリオサイト。成果物やエンジニアとしてのスキルなどなど... Vue.jsとVuetifyを使用し開発しました。\\">\\n    <meta property=\\"og:url\\" content=\\"https://stonesaw.github.io/portfolio/\\">\\n    <meta property=\\"og:image\\" content=\\"https://stonesaw.github.io/portfolio/screen-shot.jpg\\">\\n    <meta property=\\"og:type\\" content=\\"website\\">\\n    <meta property=\\"og:site_name\\" content=\\"Portfolio on GitHub Pages\\">\\n    <meta name=\\"twitter:card\\" content=\\"summary_large_image\\" />\\n    <meta name=\\"twitter:site\\" content=\\"@sou_0x0v\\" />\\n\\n    \x3c!-- CSS --\x3e\\n    <link rel=\\"preload\\" href=\\"https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900\\" as=\\"style\\">\\n    <link rel=\\"stylesheet\\" href=\\"https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900\\" media=\\"print\\" onload=\\"this.media=\'all\'\\">\\n    <link rel=\\"preload\\" href=\\"https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css\\" as=\\"style\\">\\n    <link rel=\\"stylesheet\\" href=\\"https://cdn.jsdelivr.net/npm/@mdi/font@latest/css/materialdesignicons.min.css\\" media=\\"print\\" onload=\\"this.media=\'all\'\\">\\n  </head>\\n  <body>\\n    <noscript>\\n      <strong>We\'re sorry but Sou\'s Portfolio doesn\'t work properly without JavaScript enabled. Please enable it to continue.</strong>\\n    </noscript>\\n    <div id=\\"app\\"></div>\\n    \x3c!-- built files will be auto injected --\x3e\\n  </body>\\n</html>\\n"]},"src":{"App.vue":["txt","<template>\\n  <v-app id=\\"inspire\\">\\n    <v-navigation-drawer\\n      app\\n      expand-on-hover\\n      width=\\"56\\"\\n    >\\n      <v-list shaped>\\n        <v-list-item\\n          v-for=\\"item in items\\"\\n          :key=\\"item.title\\"\\n          @click=\\"$vuetify.goTo(item.link, {duration: 500})\\"\\n          link\\n        >\\n          <v-list-item-icon>\\n            <v-icon>{{ item.icon }}</v-icon>\\n          </v-list-item-icon>\\n          <v-list-item-content>\\n            <v-list-item-title>{{ item.title }}</v-list-item-title>\\n          </v-list-item-content>\\n        </v-list-item>\\n      </v-list>\\n    </v-navigation-drawer>\\n\\n    <v-main>\\n      <AppAbout/>\\n      <AppSkills/>\\n      <AppWorks/>\\n      <AppContests/>\\n      <AppFooter/>\\n    </v-main>\\n  </v-app>\\n</template>\\n\\n<script>\\nimport AppAbout from \\"./components/AppAbout\\";\\nimport AppSkills from \\"./components/AppSkills\\";\\nimport AppWorks from \\"./components/AppWorks\\";\\nimport AppContests from \\"./components/AppContests\\";\\nimport AppFooter from \\"./components/AppFooter\\";\\n\\nexport default {\\n  name: \\"App\\",\\n\\n  components: {\\n    AppAbout,\\n    AppSkills,\\n    AppWorks,\\n    AppContests,\\n    AppFooter\\n  },\\n\\n  data () {\\n    return {\\n      drawer: false,\\n      items: [\\n        { title: \\"About\\", icon: \\"mdi-console\\" },\\n        { title: \\"Skills\\", icon: \\"mdi-xml\\" },\\n        { title: \\"Works\\", icon: \\"mdi-hexagon-multiple\\" },\\n        { title: \\"Contests\\", icon: \\"mdi-medal-outline\\" },\\n      ],\\n    }\\n  },\\n\\n  created() {\\n    this.items.forEach(item => {\\n      item.link = `#${item.title.toLowerCase()}`;\\n    });\\n  },\\n}\\n<\/script>\\n"],"assets":{},"components":{"AppAbout.vue":["txt","<template>\\r\\n  <v-container id=\\"about\\">\\r\\n    <v-row class=\\"text-center\\">\\r\\n      <v-col cols=\\"12\\">\\r\\n        <v-img\\r\\n          :aspect-ratio=\\"1/1\\"\\r\\n          :src=\\"icon_image\\"\\r\\n          :lazy-src=\\"icon_image_lazy\\"\\r\\n          class=\\"rounded-circle\\"\\r\\n          width=\\"500px\\"\\r\\n          style=\\"display: block; margin: auto;\\"\\r\\n        />\\r\\n      </v-col>\\r\\n\\r\\n      <v-col class=\\"mb-3\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold mb-2\\">\\r\\n          Sou Ishihara\\r\\n        </h1>\\r\\n\\r\\n        <p class=\\"subheading font-weight-regular\\">\\r\\n          ゲームやWebアプリを作っています\\r\\n          <br>よく寝ます\\r\\n        </p>\\r\\n      </v-col>\\r\\n\\r\\n      \x3c!-- outlines --\x3e\\r\\n\\r\\n      \x3c!-- 最後の要素だけ last-item クラスを付ける  --\x3e\\r\\n      <v-col\\r\\n        cols=\\"12\\"\\r\\n        v-for=\\"(outline, index) in outlines\\"\\r\\n        :key=\\"outline.title\\"\\r\\n        :class=\\"{ \'last-item\': index == outlines.length - 1 }\\"\\r\\n      >\\r\\n        <h2 class=\\"headline font-weight-bold mb-3\\">\\r\\n          {{ outline.title }}\\r\\n        </h2>\\r\\n        <v-row justify=\\"center\\">\\r\\n          <p class=\\"subheading font-weight-regular\\">\\r\\n            <label\\r\\n              v-for=\\"item in outline.items\\"\\r\\n              :key=\\"item\\"\\r\\n              class=\\"mx-3\\"\\r\\n            >\\r\\n              {{ item }}\\r\\n            </label>\\r\\n          </p>\\r\\n        </v-row>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n    <v-divider></v-divider>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nimport isWebpSupported from \\"./isWebpSupported\\"\\r\\n\\r\\nexport default {\\r\\n  name: \\"AppAbout\\",\\r\\n\\r\\n  computed: {\\r\\n    format () {\\r\\n      return isWebpSupported ? \\"webp\\" : \\"jpg\\"\\r\\n    }\\r\\n  },\\r\\n\\r\\n  created() {\\r\\n    this.icon_image = require(`@/assets/icon-high.${this.format}`);\\r\\n    this.icon_image_lazy = require(`@/assets/icon.${this.format}`);\\r\\n  },\\r\\n\\r\\n  data: () => ({\\r\\n    icon_image: null,\\r\\n    icon_image_lazy: null,\\r\\n    outlines: [\\r\\n      { title: \\"School\\", items: [\\"松江工業高等専門学校 (休学中)\\"] },\\r\\n      { title: \\"Company\\", items: [\\"(株)ネットワーク応用通信研究所\\"] },\\r\\n      { title: \\"Editor\\", items: [\\"vscode\\"] },\\r\\n      { title: \\"Hobby / Likes\\", items: [\\"programming\\", \\"music (i/o)\\", \\"pixel art\\"] },\\r\\n    ]\\r\\n  }),\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n<style>\\r\\n  .last-item {\\r\\n    margin-bottom: 3rem;\\r\\n  }\\r\\n</style>"],"AppContests.vue":["txt","<template>\\r\\n  <v-container\\r\\n    id=\\"contests\\"\\r\\n    class=\\"text-center\\"\\r\\n  >\\r\\n    <v-row>\\r\\n      <v-col cols=\\"12\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold my-3\\">\\r\\n          <v-icon class=\\"display-2 pb-3\\">mdi-medal-outline</v-icon>\\r\\n          Contests\\r\\n        </h1>\\r\\n\\r\\n      </v-col>\\r\\n        <v-col\\r\\n          cols=\\"12\\"\\r\\n          v-for=\\"content in contents\\"\\r\\n          :key=\\"content.name\\"\\r\\n          class=\\"mb-3 \\"\\r\\n        >\\r\\n          <p\\r\\n            class=\\"text-subtitle-1 text-md-h6 text-lg-h6 text-xl-h4\\"\\r\\n            style=\\"margin: 0;\\"\\r\\n          >\\r\\n            {{ content.name }}\\r\\n          </p>\\r\\n          <p\\r\\n            v-if=\\"content.result\\"\\r\\n            class=\\"text-caption text-md-subtitle-1 text-lg-subtitle-1 text-xl-h6\\"\\r\\n            style=\\"margin-bottom: 0.5rem;\\"\\r\\n          >\\r\\n            {{ content.result }}\\r\\n          </p>\\r\\n          <p>\\r\\n            <a target=\\"_blank\\" :href=\\"content.link\\">\\r\\n              {{ content.link }}\\r\\n            </a>\\r\\n          </p>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nexport default {\\r\\n  name: \\"AppContests\\",\\r\\n\\r\\n  data() {\\r\\n    return {\\r\\n      contents: [\\r\\n        {\\r\\n          name: \\"第30回 高専プロコン (2019)\\",\\r\\n          result: \\"サブメンバーとして参加\\",\\r\\n          link: \\"https://www.procon.gr.jp/?cat=1661\\"\\r\\n        },\\r\\n        {\\r\\n          name: \\"中高生国際Rubyプログラミングコンテスト 2020\\",\\r\\n          result: \\"ゲーム部門 最優秀賞\\",\\r\\n          link: \\"https://www.ruby-procon.net/\\"\\r\\n        },\\r\\n        {\\r\\n          name: \\"第32回 高専プロコン (2020)\\",\\r\\n          result: \\"特別賞 / サブメンバーとして参加\\",\\r\\n          link: \\"https://www.procon.gr.jp/?cat=1680\\"\\r\\n        },\\r\\n        {\\r\\n          name: \\"技育展2021 登壇\\",\\r\\n          link: \\"https://talent.supporterz.jp/geekten/2021/\\"\\r\\n        },\\r\\n      ]\\r\\n    }\\r\\n  },\\r\\n}\\r\\n<\/script>\\r\\n"],"AppFooter.vue":["txt","<template>\\r\\n  <v-footer padless>\\r\\n    <v-card\\r\\n      width=\\"100%\\"\\r\\n      class=\\"text-center\\"\\r\\n      color=\\"blue-grey darken-1\\"\\r\\n      flat\\r\\n      tile\\r\\n    >\\r\\n      <v-card-text>\\r\\n        <v-btn\\r\\n          v-for=\\"account in accounts\\"\\r\\n          :key=\\"account.title\\"\\r\\n          :href=\\"account.link\\"\\r\\n          class=\\"mx-4\\"\\r\\n          icon\\r\\n        >\\r\\n          <v-icon\\r\\n            size=\\"36px\\"\\r\\n            color=\\"white\\"\\r\\n          >\\r\\n            {{ account.icon }}\\r\\n          </v-icon>\\r\\n        </v-btn>\\r\\n      </v-card-text>\\r\\n\\r\\n      <v-card-text>\\r\\n        <span class=\\"white--text\\">\\r\\n          Copyright &copy; 2022 Sou Ishihara\\r\\n        </span>\\r\\n      </v-card-text>\\r\\n    </v-card>\\r\\n  </v-footer>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nexport default {\\r\\n  name: \\"AppFooter\\",\\r\\n\\r\\n  data () {\\r\\n    return {\\r\\n      accounts: [\\r\\n        { title: \\"twitter\\", icon: \\"mdi-twitter\\", link: \\"https://twitter.com/sou_0x0v\\" },\\r\\n        { title: \\"github\\", icon: \\"mdi-github\\", link: \\"https://github.com/stonesaw\\" },\\r\\n        { title: \\"mail\\", icon: \\"mdi-email\\", link: \\"mailto:mail.sou.dev@gmail.com\\" },\\r\\n      ]\\r\\n    }\\r\\n  }\\r\\n}\\r\\n<\/script>"],"AppSkills.vue":["txt","<template>\\r\\n  <v-container id=\\"skills\\">\\r\\n    <v-row class=\\"text-center\\">\\r\\n      <v-col cols=\\"12\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold my-3\\">\\r\\n          <v-icon class=\\"display-2 pb-3\\">mdi-xml</v-icon>\\r\\n          Skills\\r\\n        </h1>\\r\\n\\r\\n        <v-container class=\\"mb-5\\">\\r\\n          <v-row>\\r\\n            <v-col\\r\\n              cols=\\"12\\" sm=\\"6\\" md=\\"6\\" lg=\\"4\\" xl=\\"4\\"\\r\\n              v-for=\\"language in languages\\"\\r\\n              :key=\\"language.name\\"\\r\\n            >\\r\\n              <SkillsCard\\r\\n                :name=\\"language.name\\"\\r\\n                :icon=\\"language.icon\\"\\r\\n                :color=\\"language.color\\"\\r\\n                :libs=\\"language.libs\\"\\r\\n              />\\r\\n            </v-col>\\r\\n          </v-row>\\r\\n        </v-container>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n    <v-divider></v-divider>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nimport SkillsCard from \\"./SkillsCard\\"\\r\\n\\r\\nexport default {\\r\\n  name: \\"AppSkills\\",\\r\\n\\r\\n  components: {\\r\\n    SkillsCard\\r\\n  },\\r\\n\\r\\n  data: () => ({\\r\\n    languages: [\\r\\n      {\\r\\n        name: \\"Ruby\\",\\r\\n        icon: \\"mdi-language-ruby\\",\\r\\n        // color usage\\r\\n        // ref https://vuetifyjs.com/ja/styles/colors/#section-30de30c630ea30a230eb30ab30e930fc\\r\\n        color: \\"red accent-1\\",\\r\\n        libs: [\\r\\n          \\"Rails\\", \\"RSpec\\", \\"Minitest\\", \\"DXRuby\\", \\"CLI\\", \\"RuboCop\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"HTML/CSS\\",\\r\\n        icon: \\"mdi-language-html5\\",\\r\\n        color: \\"orange darken-2\\",\\r\\n        libs: [\\r\\n          \\"HTML5\\", \\"CSS3\\", \\"Tailwind\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"JavaScript\\",\\r\\n        icon: \\"mdi-language-javascript\\",\\r\\n        color: \\"amber lighten-2\\",\\r\\n        libs: [\\r\\n          \\"Vue.js\\", \\"Vuetify\\", \\"npm\\", \\"yarn\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"TypeScript\\",\\r\\n        icon: \\"mdi-language-typescript\\",\\r\\n        color: \\"blue darken-2\\",\\r\\n        libs: [\\r\\n          \\"MIDI\\", \\"Next.js\\", \\"Chakra UI\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"Python\\",\\r\\n        color: \\"blue lighten-2\\",\\r\\n        icon: \\"mdi-language-python\\",\\r\\n        libs: [\\r\\n          \\"Pillow\\", \\"Discord.py\\", \\"Pygame\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"C++\\",\\r\\n        color: \\"indigo lighten-2\\",\\r\\n        icon: \\"mdi-language-cpp\\",\\r\\n        libs: [\\r\\n          \\"AtCoder\\", \\"DxLib\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"Git\\",\\r\\n        icon: \\"mdi-git\\",\\r\\n        color: \\"deep-orange accent-2\\",\\r\\n        libs: [\\r\\n          \\"Basic\\"\\r\\n        ]\\r\\n      },\\r\\n      {\\r\\n        name: \\"GitHub\\",\\r\\n        icon: \\"mdi-github\\",\\r\\n        color: \\"grey darken-4\\",\\r\\n        libs: [\\r\\n          \\"Actions\\"\\r\\n        ]\\r\\n      },\\r\\n    ]\\r\\n  }),\\r\\n}\\r\\n<\/script>\\r\\n"],"AppWorks.vue":["txt","<template>\\r\\n  <v-container id=\\"works\\">\\r\\n    <v-row>\\r\\n      <v-col cols=\\"12\\">\\r\\n        <h1 class=\\"display-2 font-weight-bold text-center my-3\\">\\r\\n          <v-icon class=\\"display-2 pb-3\\">mdi-hexagon-multiple</v-icon>\\r\\n          Works\\r\\n        </h1>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n\\r\\n    <v-row style=\\"padding: 0 7% 3rem 7%\\">\\r\\n      <v-col\\r\\n        cols=\\"12\\" xs=\\"12\\" sm=\\"6\\" md=\\"6\\" lg=\\"4\\" xl=\\"3\\"\\r\\n        v-for=\\"work in works\\"\\r\\n        :key=\\"work.title\\"\\r\\n      >\\r\\n        <v-hover v-slot=\\"{ hover }\\">\\r\\n          <v-card height=\\"100%\\">\\r\\n            <v-img\\r\\n              :src=\\"work.thumbnail || default_thumbnail\\"\\r\\n              :lazy-src=\\"work.thumbnail_lazy || default_thumbnail_lazy\\"\\r\\n              width=\\"100%\\"\\r\\n              :aspect-ratio=\\"16/9\\"\\r\\n            ></v-img>\\r\\n\\r\\n            <v-card-title class=\\"pt-3\\">\\r\\n              {{ work.title }}\\r\\n            </v-card-title>\\r\\n            <v-card-subtitle class=\\"pb-0\\">\\r\\n              {{ work.subtitle }}\\r\\n            </v-card-subtitle>\\r\\n\\r\\n            <v-chip-group column style=\\"padding: 3px 10px\\">\\r\\n              <v-chip\\r\\n                v-for=\\"lib in work.libs\\"\\r\\n                :key=\\"lib\\"\\r\\n                outlined\\r\\n                :ripple=\\"false\\"\\r\\n              >\\r\\n                {{ lib }}\\r\\n              </v-chip>\\r\\n            </v-chip-group>\\r\\n\\r\\n            <v-fade-transition>\\r\\n              <v-overlay v-if=\\"hover\\" absolute color=\\"#555\\">\\r\\n                <v-btn :href=\\"work.github\\" target=\\"_blank\\">\\r\\n                  <v-icon left>mdi-github</v-icon>\\r\\n                  github\\r\\n                </v-btn>\\r\\n              </v-overlay>\\r\\n            </v-fade-transition>\\r\\n          </v-card>\\r\\n        </v-hover>\\r\\n      </v-col>\\r\\n    </v-row>\\r\\n\\r\\n    <v-divider></v-divider>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nimport isWebpSupported from \\"./isWebpSupported\\"\\r\\n\\r\\nexport default {\\r\\n  name: \\"AppWorks\\",\\r\\n\\r\\n  computed: {\\r\\n    format () {\\r\\n      return isWebpSupported ? \\"webp\\" : \\"jpg\\"\\r\\n    }\\r\\n  },\\r\\n\\r\\n  methods: {\\r\\n    format_file_name (file_name) {\\r\\n      if (isWebpSupported) {\\r\\n        return file_name.replace(/\\\\.jpg$/, \\".webp\\");\\r\\n      } else {\\r\\n        return file_name;\\r\\n      }\\r\\n    }\\r\\n  },\\r\\n\\r\\n  created() {\\r\\n    this.default_thumbnail = require(`@/assets/icon-high.${this.format}`);\\r\\n    this.default_thumbnail_lazy = require(`@/assets/icon.${this.format}`);\\r\\n\\r\\n    this.works.forEach(work => {\\r\\n      if (work.thumbnail) {\\r\\n        work.thumbnail = require(\\"../assets/\\" + this.format_file_name(work.thumbnail));\\r\\n      }\\r\\n      if (work.thumbnail_lazy) {\\r\\n        work.thumbnail_lazy = require(\\"../assets/\\" + this.format_file_name(work.thumbnail_lazy));\\r\\n      }\\r\\n    });\\r\\n  },\\r\\n\\r\\n  data: () => ({\\r\\n    default_thumbnail: null,\\r\\n    default_thumbnail_lazy: null,\\r\\n\\r\\n    works: [\\r\\n      {\\r\\n        title: \\"Portfolio\\",\\r\\n        subtitle: \\"ポートフォリオサイト。Vue.js と Vuetify を使用\\",\\r\\n        thumbnail: \\"portfolio.jpg\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Vue.js\\", \\"Vuetify\\"],\\r\\n        github: \\"https://github.com/stonesaw/portfolio\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"Spell Out\\",\\r\\n        subtitle: \\"基本マウスのみの アクションシューティング。Rubyでゼロから開発\\",\\r\\n        thumbnail: \\"spell-out.jpg\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Ruby\\", \\"DXRuby\\", \\"RuboCop\\"],\\r\\n        github: \\"https://github.com/stonesaw/Spell-Out\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"cli\\",\\r\\n        subtitle: \\"コマンドライン風ポートフォリオ\\",\\r\\n        thumbnail: \\"cli.png\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Vue.js\\", \\"TypeScript\\", \\"Jest\\"],\\r\\n        github: \\"https://github.com/stonesaw/cli\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"Jumping Ichiyo\\",\\r\\n        subtitle: \\"ichiyoを数式で動かすボット from 限界開発鯖 (ネタ)\\",\\r\\n        thumbnail: \\"jump-resize.gif\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Python\\", \\"Discord.py\\", \\"Pillow\\"],\\r\\n        github: \\"https://github.com/stonesaw/jumping-ichiyo\\",\\r\\n      },\\r\\n      {\\r\\n        title: \\"Ruby CUI Game\\",\\r\\n        subtitle: \\"学校の春休み課題で作ったもの。CUI用のゲームライブラリから作った\\",\\r\\n        thumbnail: \\"cli-mario.png\\",\\r\\n        thumbnail_lazy: null,\\r\\n        libs: [\\"Ruby\\", \\"CLI\\"],\\r\\n        github: \\"https://github.com/stonesaw/Ruby-CUI-game\\",\\r\\n      },\\r\\n    ],\\r\\n  }),\\r\\n};\\r\\n<\/script>\\r\\n"],"SkillsCard.vue":["txt","<template>\\r\\n  <v-container>\\r\\n    <v-hover v-slot=\\"{ hover }\\">\\r\\n      <v-row>\\r\\n        <v-col cols=\\"5\\">\\r\\n          <div v-if=\\"hover\\">\\r\\n            <v-icon\\r\\n              :color=\\"color\\"\\r\\n              size=\\"64\\"\\r\\n            >{{ icon }}</v-icon>\\r\\n            <p\\r\\n              class=\\"text-overline\\"\\r\\n              :class=\\"color_text\\"\\r\\n              style=\\"margin: 0;\\"\\r\\n            >{{ name }}</p>\\r\\n          </div>\\r\\n          <div v-else>\\r\\n            <v-icon\\r\\n              size=\\"64\\"\\r\\n            >{{icon}}</v-icon>\\r\\n            <p\\r\\n              class=\\"text-overline\\"\\r\\n              style=\\"margin: 0;\\"\\r\\n            >{{ name }}</p>\\r\\n          </div>\\r\\n        </v-col>\\r\\n        <v-col cols=\\"7\\">\\r\\n          <v-chip-group column>\\r\\n            <v-chip\\r\\n              v-for=\\"lib in libs\\"\\r\\n              :key=\\"lib\\"\\r\\n              outlined\\r\\n              :ripple=\\"false\\"\\r\\n            >\\r\\n              {{ lib }}\\r\\n            </v-chip>\\r\\n          </v-chip-group>\\r\\n        </v-col>\\r\\n      </v-row>\\r\\n    </v-hover>\\r\\n  </v-container>\\r\\n</template>\\r\\n\\r\\n<script>\\r\\nexport default {\\r\\n  name: \\"SkillsCard\\",\\r\\n\\r\\n  props: {\\r\\n    name: String,\\r\\n    icon: String,\\r\\n    color: String,\\r\\n    libs: Array,\\r\\n  },\\r\\n\\r\\n  created() {\\r\\n    const ary = this.color.split(\\" \\");\\r\\n    if (ary.length >= 3) {\\r\\n      console.error(\\"wrong languages.color format!\\");\\r\\n      return;\\r\\n    }\\r\\n    if (ary[0]) { this.color_text = `${ary[0]}--text`; }\\r\\n    if (ary[1]) { this.color_text += ` text--${ary[1]}`; }\\r\\n  }\\r\\n}\\r\\n<\/script>\\r\\n"],"isWebpSupported.js":["txt","const canUseWebP = () => {\\r\\n    const elem = document.createElement(\\"canvas\\")\\r\\n    if (elem.getContext && elem.getContext(\\"2d\\")) {\\r\\n        // CanvasからWebPを出力して、結果がdata:image/webpで始まっているかチェック\\r\\n        return elem.toDataURL(\\"image/webp\\").indexOf(\\"data:image/webp\\") === 0\\r\\n    }\\r\\n    // Canvas自体が使えなければ非対応扱いにする\\r\\n    return false\\r\\n}\\r\\n\\r\\n// 最初に一度だけ判定して結果をexport\\r\\nexport default canUseWebP()\\r\\n"]},"main.js":["txt","import Vue from \\"vue\\"\\r\\nimport App from \\"./App.vue\\"\\r\\nimport vuetify from \\"./plugins/vuetify\\"\\r\\n\\r\\nVue.config.productionTip = false\\r\\n\\r\\nnew Vue({\\r\\n  vuetify,\\r\\n  render: h => h(App)\\r\\n}).$mount(\\"#app\\")\\r\\n"],"plugins":{"vuetify.js":["txt","import Vue from \'vue\';\\nimport Vuetify from \'vuetify/lib/framework\';\\n\\nVue.use(Vuetify);\\n\\nexport default new Vuetify({\\n});\\n"]}},"vue.config.js":["txt","const { defineConfig } = require(\\"@vue/cli-service\\")\\nmodule.exports = defineConfig({\\n  transpileDependencies: [\\n    \\"vuetify\\"\\n  ],\\n  publicPath: \\"./\\"\\n})\\n"],"repo.link":["link","https://github.com/stonesaw/portfolio"]},"Spell-Out":{"assets":{},"sound":{},"how-to.md":["txt","## 実行\\r\\n```\\r\\ngem install dxruby\\r\\nruby main.rb\\r\\n``` \\r\\n\\r\\n\\r\\n## タイトル画面\\r\\n- [Play] を クリック または 方向キーとエンターキー で選択するとプレイ画面に移動します\\r\\n- [Credit] は作っていません ( [Play]と同じ動作になります )\\r\\n- [Exit] を選択するとゲームが終了します\\r\\n\\r\\n\\r\\n## プレイ画面\\r\\n### 操作方法\\r\\n- マウスポインタの方向にキャラクターが移動します\\r\\n- 弾は自動で発射されます\\r\\n- [マウスホイール or Z/X] で Spell(属性) が変わります\\r\\n- [右クリック長押し] で、チャージ攻撃が出来ます\\r\\n- (チャージ時間は Spell によって異なります)\\r\\n\\r\\n- [Tab] を押すと メニュー画面 に飛びます\\r\\n\\r\\n\\r\\n## メニュー画面\\r\\n- 操作方法の確認と音量調節ができます\\r\\n- 音量は BGM・SE ともにシークバーから変更できます\\r\\n- [Tab] を押すことで プレイ画面 に戻ります\\r\\n\\r\\n\\r\\n## ステージセレクト画面\\r\\n- 最初のステージ (1-1) をクリアするとステージセレクト画面に移動します \\r\\n- ステージセレクトでは、\\r\\n\\r\\n\\r\\n## リザルト画面\\r\\n- ステージを最後 (1-6) までクリアする or プレイヤーのライフが0になると リザルト画面へ移動します\\r\\n- リザルト画面では、名前を入力することでスコアを記録できます\\r\\n- (個人的には無効な名前を入力したときに出るエラーの感じがお気に入り)\\r\\n\\r\\n\\r\\n## ランキング\\r\\n- リザルト画面で入力した名前 スコア クリアした日付 が表示されます\\r\\n- [Enter] でタイトル画面 へ戻ります\\r\\n\\r\\n\\r\\n## おまけ\\r\\n- 開発用に プレイ画面で [F12] を押すと強制的にステージをクリア出来ます\\r\\n- プレイ画面で [F5] を押すと デバッグモードが ON になり、デバッグの出力を見れます\\r\\n- タイトル画面で [クリック or スペース] でタイトルの色が変わります\\r\\n\\r\\n## exe化\\r\\n```\\r\\ngem install ocra\\r\\nocra --windows main.rb assets\\r\\nren main.exe \\"Spell-Out.exe\\"\\r\\n```\\r\\n\\r\\nhttp://mirichi.github.io/dxruby-doc/tips/ocra.html\\r\\n"],"lib":{"bullet.rb":["txt","class Bullet < Sprite\\r\\n  attr_accessor :spell, :attack, :anime, :is_anime, :_anime_cnt, :direction\\r\\n  attr_reader :data, :spawn_tick\\r\\n\\r\\n  def initialize(data, x, y)\\r\\n    @data = data.clone\\r\\n    @data.var = JSON.parse(data.var.to_json)\\r\\n    super(x, y, @data.image)\\r\\n    @direction = Play.player.direction\\r\\n    @anime = @data.anime\\r\\n    @spell = @data.spell\\r\\n    @attack = @data.attack\\r\\n    @_anime_cnt = 0\\r\\n    @spawn_tick = Play.tick\\r\\n\\r\\n    @data.spawned(self)\\r\\n    self.class.list << self\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def _anime_next\\r\\n    @_anime_cnt = (@_anime_cnt + 1) % @anime.length\\r\\n    @image = @anime[@_anime_cnt]\\r\\n    self.image = @image\\r\\n  end\\r\\n\\r\\n\\r\\n  @list = []\\r\\n  class << self\\r\\n    attr_reader :list\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @list.each do |bullet|\\r\\n      bullet.data.lived(bullet)\\r\\n\\r\\n      if !((-500..Window.width + 500).include?(bullet.x) &&\\r\\n           (-500..Window.height + 500).include?(bullet.y))\\r\\n        bullet.vanish\\r\\n      end\\r\\n    end\\r\\n    Sprite.clean(@list)\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @list.each do |bullet|\\r\\n      bullet.draw unless bullet.data.is_draw_after\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw_after\\r\\n    @list.each do |bullet|\\r\\n      bullet.draw if bullet.data.is_draw_after\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.reset\\r\\n    @list = []\\r\\n  end\\r\\n\\r\\n  def self._spell_color\\r\\n    {\\r\\n      fire: [255, 0, 0],\\r\\n      water: [55, 183, 230],\\r\\n      wind: [23, 255, 123],\\r\\n      holy: [249, 250, 212],\\r\\n      dark: [121, 73, 173],\\r\\n    }\\r\\n  end\\r\\nend\\r\\n"],"data":{"bullet_data.rb":["txt","# BulletDataのインターフェース\\r\\nclass IBulletData < ISpriteData\\r\\n  attr_accessor :attack\\r\\n  attr_reader :is_draw_after\\r\\n\\r\\n  def initialize(spell, attack, image, anime: [], is_draw_after: false)\\r\\n    super(spell, image, anime)\\r\\n    @is_draw_after = is_draw_after\\r\\n    @attack = attack\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    super()\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    super()\\r\\n  end\\r\\nend\\r\\n\\r\\n# ため攻撃のデータ\\r\\nclass BulletData\\r\\n  @list = {}\\r\\n  @charge_tick = {\\r\\n    fire: 60,\\r\\n    water: 60,\\r\\n    wind: 200,\\r\\n    holy: 80,\\r\\n    dark: 80,\\r\\n  }\\r\\n\\r\\n  class << self\\r\\n    attr_reader :list, :charge_tick\\r\\n  end\\r\\n\\r\\n  def self.load\\r\\n    _list_add_level1_bullet\\r\\n    @list[:level2_fire] = BulletFileLevel2.new\\r\\n    @list[:level2_water] = BulletWaterLevel2.new\\r\\n    @list[:level2_wind] = BulletWindLevel2.new\\r\\n    @list[:level2_holy] = BulletHolyLevel2.new\\r\\n    @list[:level2_dark] = @list[:level1_dark]\\r\\n  end\\r\\n\\r\\n  def self.spell_and_color\\r\\n    {\\r\\n      fire: [255, 0, 0],\\r\\n      water: [55, 183, 230],\\r\\n      wind: [23, 255, 123],\\r\\n      holy: [249, 250, 212],\\r\\n      dark: [121, 73, 173],\\r\\n    }\\r\\n  end\\r\\n\\r\\n  def self._list_add_level1_bullet\\r\\n    spell_and_color.each_pair do |spell, color|\\r\\n      list[:\\"level1_#{spell}\\"] = BulletLevel1.new(spell, color)\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_list_add_level1_bullet\\r\\nend\\r\\n\\r\\n\\r\\n# レベル1 全属性\\r\\nclass BulletLevel1 < IBulletData\\r\\n  def self.new(spell, color)\\r\\n    super(spell, 10, Image.new(10, 10, color))\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.data.var[:speed] = 12\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    if self_.data.var[:next_vanish]\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:next_vanish] = false\\r\\n    end\\r\\n\\r\\n    if self_.data.var[:vanish_passed].nil?\\r\\n      self_.x += dx = self_.data.var[:speed] * Math.cos(self_.direction * Math::PI / 180.0)\\r\\n      self_.y += dy = self_.data.var[:speed] * Math.sin(self_.direction * Math::PI / 180.0)\\r\\n\\r\\n      is_hit_obj = (self_ === Play.stage.objects)\\r\\n      is_hit_enemies = (self_ === Enemy.list)\\r\\n      if is_hit_obj || is_hit_enemies\\r\\n        if is_hit_obj\\r\\n          self_.collision_enable = false\\r\\n        elsif is_hit_enemies\\r\\n          self_.data.var[:next_vanish] = true\\r\\n        end\\r\\n        self_.x -= dx * 0.5\\r\\n        self_.y -= dy * 0.5\\r\\n        self_.data.var[:vanish_passed] = 0\\r\\n        self_.image = Image.new(20, 20)\\r\\n      end\\r\\n    else\\r\\n      self_.data.var[:vanish_passed] += 1\\r\\n      count = self_.data.var[:vanish_passed]\\r\\n      self_.image = Image.new(10 + count, 10 + count, C_WHITE)\\r\\n      self_.x -= 0.5\\r\\n      self_.y -= 0.5\\r\\n      self_.alpha -= 15\\r\\n      self_.vanish if self_.alpha <= 15\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\n\\r\\n# レベル2 ファイア\\r\\nclass BulletFileLevel2 < IBulletData\\r\\n  def self.new\\r\\n    @images ||= (0..1).map do |i|\\r\\n      Image.load(\\"#{$PATH}/assets/image/fire#{i}.png\\").set_color_key(C_WHITE)\\r\\n    end\\r\\n    super(:fire, 50, @images[0], anime: @images)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.center_x = 64\\r\\n    self_.center_y = 128\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    player = Play.player\\r\\n    self_.x = player.x - 30 + player.image.width  * 0.4  * Math.cos(player.direction * Math::PI / 180.0)\\r\\n    self_.y = player.y - 50 + player.image.height * 0.35 * Math.sin(player.direction * Math::PI / 180.0)\\r\\n    self_.angle = player.direction + 90\\r\\n    self_.alpha -= 10 if passed_tick >= 80 - 25\\r\\n\\r\\n    self_._anime_next if passed_tick % 16 == 0\\r\\n\\r\\n    if self_.data.var[:hit_flag].nil?\\r\\n      unless self_.check(Enemy.list).empty?\\r\\n        self_.data.var[:hit_flag] = true\\r\\n      end\\r\\n    elsif self_.data.var[:hit_flag] == true\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:hit_flag] = false\\r\\n      self_.data.var[:cool_time] = 40\\r\\n    elsif self_.data.var[:hit_flag] == false\\r\\n      self_.data.var[:cool_time] -= 1\\r\\n      if self_.data.var[:cool_time] <= 0\\r\\n        self_.data.var[:hit_flag] = nil\\r\\n        self_.collision_enable = true\\r\\n      end\\r\\n    end\\r\\n\\r\\n    self_.vanish if passed_tick >= 80\\r\\n  end\\r\\nend\\r\\n\\r\\n# レベル2 水\\r\\nclass BulletWaterLevel2 < IBulletData\\r\\n  def self.new\\r\\n    super(:water, 30, Image.new(32, 64, C_CYAN))\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.x = Play.player.x\\r\\n    self_.y = Play.player.y\\r\\n    self_.angle = Play.player.direction - 90\\r\\n    self_.data.var[:speed] = 12\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    if self_.data.var[:next_vanish]\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:next_vanish] = false\\r\\n    end\\r\\n\\r\\n    if self_.data.var[:vanish_passed].nil?\\r\\n      self_.x += dx = self_.data.var[:speed] * Math.cos(self_.direction * Math::PI / 180.0)\\r\\n      self_.y += dy = self_.data.var[:speed] * Math.sin(self_.direction * Math::PI / 180.0)\\r\\n\\r\\n      is_hit_obj = (self_ === Play.stage.objects)\\r\\n      is_hit_enemies = (self_ === Enemy.list)\\r\\n      if is_hit_obj || is_hit_enemies\\r\\n        if is_hit_obj\\r\\n          self_.collision_enable = false\\r\\n        elsif is_hit_enemies\\r\\n          self_.data.var[:next_vanish] = true\\r\\n        end\\r\\n        self_.x -= dx * 0.5\\r\\n        self_.y -= dy * 0.5\\r\\n        self_.data.var[:vanish_passed] = 0\\r\\n        self_.image = Image.new(20, 20)\\r\\n      end\\r\\n    else\\r\\n      self_.data.var[:vanish_passed] += 1\\r\\n      count = self_.data.var[:vanish_passed]\\r\\n      self_.image = Image.new(10 + count, 10 + count, C_WHITE)\\r\\n      self_.x -= 0.5\\r\\n      self_.y -= 0.5\\r\\n      self_.alpha -= 15\\r\\n      self_.vanish if self_.alpha <= 15\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\n\\r\\n# レベル2 風\\r\\nclass BulletWindLevel2 < IBulletData\\r\\n  def self.new\\r\\n    @images ||= [0].map do |i|\\r\\n      Image.load(\\"#{$PATH}/assets/image/recovery#{i}.png\\").set_color_key(C_WHITE)\\r\\n    end\\r\\n    super(:wind, 0, @images[0], anime: @images, is_draw_after: true)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    Play.player.life = [Play.player.life + 10, Play.player.max_life].min\\r\\n    self_.collision_enable = false # 当たり判定をなくす\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    self_.x = Play.player.x + 10\\r\\n    self_.y = Play.player.y + 50\\r\\n\\r\\n    if (0..3).include?(passed_tick % 10)\\r\\n      self_.alpha = 0\\r\\n    else\\r\\n      self_.alpha = 200\\r\\n    end\\r\\n\\r\\n    self_._anime_next if passed_tick % 16 == 0\\r\\n\\r\\n    self_.vanish if passed_tick >= 80\\r\\n  end\\r\\nend\\r\\n\\r\\n\\r\\n# レベル2 光\\r\\nclass BulletHolyLevel2 < IBulletData\\r\\n  def self.new\\r\\n    super(:holy, 0, Image.new(1, 1))\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.collision_enable = false\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n    if passed_tick % 10 == 0 && (0..50).include?(passed_tick)\\r\\n      Bullet.new(BulletHolyLevel2Child.new, Play.player.x, Play.player.y)\\r\\n    elsif passed_tick > 50\\r\\n      self_.vanish\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nclass BulletHolyLevel2Child < IBulletData\\r\\n  def self.new\\r\\n    @images ||= [Image.load(\\"#{$PATH}/assets/image/_holy0.png\\")]\\r\\n    super(:holy, 10, @images[0])\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.data.var[:speed] = 14\\r\\n\\r\\n    # TODO スポーンする位置の調整\\r\\n    self_.angle = Play.player.direction + 90\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    self_.vanish if self_.data.var[:vanish]\\r\\n\\r\\n    self_.x += self_.data.var[:speed] * Math.cos(self_.direction * Math::PI / 180.0)\\r\\n    self_.y += self_.data.var[:speed] * Math.sin(self_.direction * Math::PI / 180.0)\\r\\n\\r\\n    if self_ === Enemy.list\\r\\n      self_.data.var[:vanish] = true\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"enemies_data.rb":["txt","class IEnemyData < ISpriteData\\r\\n  attr_accessor :name, :hp, :max_hp, :score, :direction, :exp\\r\\n\\r\\n  def initialize(name, spell, hp, score, exp, image, anime: [])\\r\\n    super(spell, image, anime)\\r\\n    @name   = name.to_s\\r\\n    @hp     = hp.to_i\\r\\n    @max_hp = hp.to_i\\r\\n    @score  = score.to_i\\r\\n    @exp    = exp.to_i\\r\\n    @direction = 0\\r\\n  end\\r\\n\\r\\n  def dead(self_)\\r\\n  end\\r\\nend\\r\\n\\r\\n# スライム\\r\\nclass Slime < IEnemyData\\r\\n  def initialize(name, spell, image, anime: [])\\r\\n    super(name, spell, 100, 10, 10, image, anime: anime)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.add_hp_bar(x: 0.7, y: 0.7)\\r\\n    self_.collision = [64, 100, 27]\\r\\n    self_.data.var[:speed] = 2\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    distance_x = self_.x - Play.player.x\\r\\n    distance_y = self_.y - Play.player.y\\r\\n    self_.data.direction = Math.atan2(distance_y, distance_x) * 180.0 / Math::PI\\r\\n    self_.data.direction = 360 + self_.data.direction if self_.data.direction < 0\\r\\n\\r\\n    obj = Play.stage.objects\\r\\n    self_.x -= dx = self_.data.var[:speed] * Math.cos(self_.data.direction * Math::PI / 180.0)\\r\\n    self_.x += dx * 2 unless self_.check(obj).empty?\\r\\n\\r\\n    self_.y -= dy = self_.data.var[:speed] * Math.sin(self_.data.direction * Math::PI / 180.0)\\r\\n    self_.y += dy * 2 unless self_.check(obj).empty?\\r\\n\\r\\n    self_.anime_next if passed_tick % 10 == 0\\r\\n\\r\\n    bullets = self_.check(Bullet.list)\\r\\n    unless bullets.empty?\\r\\n      SE.play(:slime)\\r\\n      self_.calc_hp(bullets[0])\\r\\n      # Bullet.list.delete(bullets[0]) # TODO: Bullet の削除 : bullet_data に移動\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def dead(self_)\\r\\n    if self_.data.var[:count].nil?\\r\\n      SE.play(:retro04)\\r\\n      # $se_retro04.set_volume(255 * $volume)\\r\\n      $score += self_.data.score\\r\\n      Play.player.exp += self_.data.exp\\r\\n      Play.player.level = Play.player.exp / 50 # TODO: レベルのあげ方\\r\\n      self_.collision_enable = false\\r\\n      self_.data.var[:count] = 0\\r\\n      self_.x += 64\\r\\n      self_.y += 100\\r\\n      self_.image = Image.new(20, 20, C_WHITE)\\r\\n    else\\r\\n      self_.data.var[:count] += 1\\r\\n      count = self_.data.var[:count]\\r\\n      self_.image = Image.new(20 + count, 20 + count, C_WHITE)\\r\\n      self_.x -= 0.5\\r\\n      self_.y -= 0.5\\r\\n      self_.alpha -= 7\\r\\n      self_.vanish if self_.alpha <= 7\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nclass SlimeWater < Slime\\r\\n  def self.new\\r\\n    @images ||= Image.load_tiles(\\"#{$PATH}/assets/image/slime.png\\", 3, 1)\\r\\n    super(\'水スライム\', :water, @images[0], anime: @images)\\r\\n  end\\r\\nend\\r\\n\\r\\nclass SlimeWind < Slime\\r\\n  def self.new\\r\\n    @images ||= Image.load_tiles(\\"#{$PATH}/assets/image/slime2.png\\", 3, 1)\\r\\n    super(\'風スライム\', :wind, @images[0], anime: @images)\\r\\n  end\\r\\nend\\r\\n\\r\\n# ゴーレム\\r\\nclass Golem < IEnemyData\\r\\n  def self.new\\r\\n    @images ||= Image.load_tiles(\\"#{$PATH}/assets/image/Golem_stone.png\\", 6, 4)\\r\\n    golem_img = [@images[0], @images[1], @images[2]]\\r\\n    super(\'ゴーレム\', :dark, 500, 1000, 100, golem_img[0], anime: golem_img)\\r\\n  end\\r\\n\\r\\n  def spawned(self_)\\r\\n    self_.add_hp_bar\\r\\n  end\\r\\n\\r\\n  def lived(self_)\\r\\n    passed_tick = Play.tick - self_.spawn_tick\\r\\n\\r\\n    self_.y += 2\\r\\n    self_.y = -200 if self_.y > Window.height\\r\\n\\r\\n    self_.anime_next if passed_tick % 10 == 0\\r\\n\\r\\n    bullets = self_.check(Bullet.list)\\r\\n    unless bullets.empty?\\r\\n      SE.play(:slime)\\r\\n      self_.calc_hp(bullets[0])\\r\\n      # Bullet.list.delete(bullets[0]) # TODO: Bullet の削除 : bullet_data に移動\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def dead(self_)\\r\\n    SE.play(:retro04)\\r\\n    # $se_retro04.set_volume(255 * $volume)\\r\\n    $score += self_.data.score\\r\\n    Play.player.exp += self_.data.exp\\r\\n    Play.player.level = Play.player.exp / 50 # TODO: レベルのあげ方\\r\\n\\r\\n    self_.vanish\\r\\n  end\\r\\nend\\r\\n"],"sprite_data.rb":["txt","class ISpriteData\\r\\n  attr_accessor :spell, :var\\r\\n  attr_reader :image, :anime\\r\\n\\r\\n  def initialize(spell, image, anime)\\r\\n    @spell = spell.to_sym\\r\\n    @image = image\\r\\n    @anime = anime\\r\\n    @var = {}\\r\\n  end\\r\\n\\r\\n  def spawned\\r\\n  end\\r\\n\\r\\n  def lived\\r\\n  end\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :images\\r\\n  end\\r\\nend\\r\\n"],"stage_data.rb":["txt","class IWaveData\\r\\n  attr_reader :proc_begin, :proc_update, :proc_end\\r\\n  attr_accessor :field_image, :bg_image, :field_objects, :judge_flag, :spawn_tick\\r\\n\\r\\n  def initialize(bg_image, field_objects, use_judge_flag: false)\\r\\n    @bg_image = bg_image\\r\\n    @field_objects = field_objects\\r\\n    @proc_begin = proc {}\\r\\n    @proc_update = proc {}\\r\\n    @proc_end = proc {}\\r\\n    @judge_flag = use_judge_flag ? false : nil\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def when_begin(&block)\\r\\n    @spawn_tick = Play.tick\\r\\n    @proc_begin = block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def when_update(&block)\\r\\n    @proc_update = block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def when_end(&block)\\r\\n    @proc_end = block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def passed_tick\\r\\n    Play.tick - @spawn_tick\\r\\n  end\\r\\nend\\r\\n\\r\\nclass StageData\\r\\n  class << self\\r\\n    attr_accessor :list\\r\\n  end\\r\\n\\r\\n  def self.load(stage_name)\\r\\n    if /(?<chapter>\\\\d)-(?<section>\\\\d)/ =~ stage_name\\r\\n      send(:\\"load_#{chapter}_#{section}\\")\\r\\n    else\\r\\n      raise ArgumentError, \\"wrong stage_name (#{stage_name})\\"\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.load_1_1\\r\\n    bg = Image.new(Window.width, Window.height, [142, 199, 95])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, [\\r\\n      Sprite.new(200, 600, Image.new(50, 50, [70, 70, 70])),\\r\\n      Sprite.new(600, 200, Image.new(50, 50, [70, 70, 70])),\\r\\n    ]).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 100, 100)\\r\\n      end.\\r\\n      when_update do |wave|\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, [\\r\\n      Sprite.new(800, 400, Image.new(50, 50, [70, 70, 70])),\\r\\n    ]).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 100, 100)\\r\\n        Enemy.new(SlimeWind.new, 700, 100)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 100, 100)\\r\\n        Enemy.new(SlimeWind.new, 700, 100)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_2\\r\\n    bg = Image.new(Window.width, Window.height, [142, 199, 95])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 110)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 110)\\r\\n        Enemy.new(SlimeWater.new, 900, 350)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_3\\r\\n    bg = Image.new(Window.width, Window.height, [142, 199, 95])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWind.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 350)\\r\\n        Enemy.new(SlimeWater.new, 500, 70)\\r\\n        Enemy.new(SlimeWater.new, 700, 350)\\r\\n        Enemy.new(SlimeWater.new, 900, 70)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWater.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_4\\r\\n    bg = Image.new(Window.width, Window.height, [183, 212, 116])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n      end\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_5\\r\\n    bg = Image.new(Window.width, Window.height, [183, 212, 116])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWind.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 350)\\r\\n        Enemy.new(SlimeWater.new, 500, 70)\\r\\n        Enemy.new(SlimeWater.new, 700, 350)\\r\\n        Enemy.new(SlimeWater.new, 900, 70)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWater.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n        Enemy.new(SlimeWater.new, 700, 70)\\r\\n        Enemy.new(SlimeWind.new, 900, 350)\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\n\\r\\n  def self.load_1_6\\r\\n    bg = Image.new(Window.width, Window.height, [193, 201, 115])\\r\\n    field_objects = []\\r\\n    2.times do |y|\\r\\n      2.times do |x|\\r\\n        w, h = Window.width - 100, Window.height - 100\\r\\n        _x = [w * 0.2, w * 0.8]\\r\\n        _y = [h * 0.2, h * 0.8]\\r\\n        field_objects << Sprite.new(_x[x], _y[y], Image.new(50, 50, [70, 70, 70]))\\r\\n      end\\r\\n    end\\r\\n\\r\\n    waves = []\\r\\n    waves << IWaveData.new(bg, field_objects).\\r\\n      when_begin do |wave|\\r\\n        Enemy.new(SlimeWind.new, 300, 70)\\r\\n        Enemy.new(SlimeWind.new, 500, 350)\\r\\n      end\\r\\n\\r\\n    waves << IWaveData.new(bg, [], use_judge_flag: true).\\r\\n      when_update do |wave|\\r\\n        passed_tick = Play.tick - wave.spawn_tick\\r\\n\\r\\n        if passed_tick < 600 && passed_tick % 200 == 1\\r\\n          case passed_tick / 100\\r\\n          when 0\\r\\n            Enemy.new(Golem.new, Window.width * 0.5, -200)\\r\\n          when 2\\r\\n            Enemy.new(Golem.new, Window.width * 0.3, -200)\\r\\n          when 4\\r\\n            Enemy.new(Golem.new, Window.width * 0.7, -200)\\r\\n          end\\r\\n        end\\r\\n\\r\\n        if passed_tick % 300 == 299\\r\\n          Enemy.new(SlimeWind.new, 100 + rand(Window.width - 200), -100)\\r\\n        end\\r\\n\\r\\n        if passed_tick >= 600\\r\\n          exist_golelm = Enemy.list.map {|e| true if e.data.name == \'ゴーレム\' }\\r\\n          if exist_golelm.compact.empty?\\r\\n            wave.judge_flag = true\\r\\n          end\\r\\n        end\\r\\n      end\\r\\n    waves\\r\\n  end\\r\\nend\\r\\n"]},"enemy.rb":["txt","class Enemy < Sprite\\r\\n  attr_reader :data, :spawn_tick\\r\\n  attr_accessor :hp_bar, :hp_bar_base\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :list\\r\\n    attr_reader :_spell_match, :_spell_miss\\r\\n  end\\r\\n\\r\\n  def self.reset\\r\\n    @list = []\\r\\n  end\\r\\n\\r\\n  def initialize(data, x, y)\\r\\n    @data = data.clone\\r\\n    @data.var = JSON.parse(data.var.to_json)\\r\\n    super(x, y, @data.image)\\r\\n    @anime = @data.anime\\r\\n    @_anime_count = 0\\r\\n    # @data.remove_instance_variable(:@image)\\r\\n    # @data.remove_instance_variable(:@anime)\\r\\n    @spawn_tick = Play.tick\\r\\n\\r\\n    # @data.proc_spawned.call(self)\\r\\n    @data.spawned(self)\\r\\n\\r\\n    self.class.list << self\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    # @data.proc_lived.call(self)\\r\\n    # @data.proc_dead.call(self) if data.hp <= 0\\r\\n    if @data.hp > 0\\r\\n      @data.lived(self)\\r\\n    else\\r\\n      @data.dead(self)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  # utils\\r\\n\\r\\n  def calc_hp(bullet)\\r\\n    boost = if spell_matching?(bullet)\\r\\n              2.0\\r\\n            elsif spell_missing?(bullet)\\r\\n              0.5\\r\\n            else\\r\\n              1.0\\r\\n            end\\r\\n    @data.hp = [0, @data.hp - bullet.attack * boost].max\\r\\n  end\\r\\n\\r\\n  def spell_matching?(bullet)\\r\\n    self.class._spell_match.each do |to, from|\\r\\n      if bullet.spell == to && @data.spell == from\\r\\n        return true\\r\\n      end\\r\\n    end\\r\\n    false\\r\\n  end\\r\\n\\r\\n  def spell_missing?(bullet)\\r\\n    self.class._spell_miss.each do |to, from|\\r\\n      if bullet.spell == to && @data.spell == from\\r\\n        return true\\r\\n      end\\r\\n    end\\r\\n    false\\r\\n  end\\r\\n\\r\\n  # TODO\\r\\n  def hit_check_field_objects()\\r\\n  end\\r\\n\\r\\n  def anime_next\\r\\n    @_anime_count = (@_anime_count + 1) % @anime.length\\r\\n    @image = @anime[@_anime_count]\\r\\n    self.image = @image\\r\\n  end\\r\\n\\r\\n  def add_hp_bar(x: 1, y: 1)\\r\\n    HPBar.enemy_hp_bar << {\\r\\n      enemy: self,\\r\\n      base: Image.new(x * (image.width * 0.9),    y * (image.height * 0.15), [240, 240, 240]),\\r\\n      bar: Image.new(x * (image.width * 0.9 - 4), y * (image.height * 0.15 - 4), [124, 224, 43]),\\r\\n    }\\r\\n  end\\r\\n\\r\\n  def add_boss_bar\\r\\n    HPBar.boss_hp_bar << {\\r\\n      enemy: self,\\r\\n      base: Image.new(image.width * 0.9, image.height * 0.1, [240, 240, 240]),\\r\\n      bar: Image.new(image.width * 0.9 - 4, image.height * 0.1 - 4, [124, 224, 43]),\\r\\n    }\\r\\n  end\\r\\n\\r\\n  # class method & variable\\r\\n\\r\\n  @list = []\\r\\n  @_spell_match = [\\r\\n    # [to, from] (bullet -> enemy)\\r\\n    [:fire, :wind],\\r\\n    [:wind, :water],\\r\\n    [:water, :fire],\\r\\n    [:holy, :dark],\\r\\n    [:dark, :holy],\\r\\n  ]\\r\\n  @_spell_miss = @_spell_match.map.with_index {|spells, i| spells.reverse if i < 3 }\\r\\n  @_spell_miss.compact!\\r\\nend\\r\\n"],"player.rb":["txt","class Player < Sprite\\r\\n  attr_accessor :spell, :max_life, :life, :images, :direction, :level, :exp\\r\\n  attr_reader :is_changed_spell, :speed\\r\\n\\r\\n  def initialize(spell, x, y, images)\\r\\n    super\\r\\n    self.x = x\\r\\n    self.y = y\\r\\n    @images = images\\r\\n    self.image = @images[0][0]\\r\\n    self.collision = [8, 36, 70, 112]\\r\\n\\r\\n    @spell = spell.to_sym\\r\\n    @spell_list = [:fire, :water, :wind, :holy, :dark]\\r\\n    @spell_num = @spell_list.index(@spell)\\r\\n    @max_life = 250\\r\\n    @life = 250\\r\\n    @level = 1\\r\\n    @exp = 0\\r\\n    @speed = 4\\r\\n    @direction = -90 # キャラクターの向いている方向 (画像の角度ではない)\\r\\n    @cool_time = 0\\r\\n    @is_changed_spell = false\\r\\n\\r\\n    @bullet_count = 0 # バレット 自動発射用のカウント変数\\r\\n    @anime_count = 0\\r\\n    @_mouse_down_count = 0\\r\\n    @_old_spell_num = @spell_num\\r\\n    @hit_tick = 0\\r\\n    @is_hit = false\\r\\n    @charge_percent = 0.0\\r\\n    @charge_circle_img = []\\r\\n    9.times do |i|\\r\\n      @charge_circle_img << Image.load(\\"#{$PATH}/assets/image/circle#{i}.png\\").\\r\\n        set_color_key(C_BLACK).\\r\\n        flush([200, 255, 255, 255]) # 色を変更\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    # player controll\\r\\n    mx = Mouse.x\\r\\n    my = Mouse.y\\r\\n    ox = x + (image.width / 2)\\r\\n    oy = y + (image.height / 2)\\r\\n\\r\\n    # [右 → から時計回り][アニメーション]\\r\\n    @anime_count += 1 if Play.tick % 10 == 0\\r\\n    if (0..10).include?((ox - mx).abs) && (0..10).include?((oy - my).abs)\\r\\n      animation(1)\\r\\n    else\\r\\n      animation(@anime_count)\\r\\n      angle = Math.atan2(my - oy, mx - ox) * 180.0 / Math::PI\\r\\n      angle = 360 + angle if angle < 0\\r\\n      @direction = angle\\r\\n\\r\\n      obj = Play.stage.objects\\r\\n      self.x += dx = @speed * Math.cos(@direction * Math::PI / 180.0)\\r\\n      self.x -= dx unless check(obj).empty?\\r\\n\\r\\n      self.y += dy = @speed * Math.sin(@direction * Math::PI / 180.0)\\r\\n      self.y -= dy unless check(obj).empty?\\r\\n    end\\r\\n\\r\\n    self.x = [[0, self.x].max, Window.width - image.width].min\\r\\n    self.y = [[0, self.y].max, Window.height - image.height].min\\r\\n    # self.x = (Window.width - self.image.width) / 2\\r\\n    # self.y = (Window.height - self.image.height) / 2\\r\\n\\r\\n\\r\\n    # hit enemy\\r\\n    enemies = check(Enemy.list) # unless Enemy.list.empty?\\r\\n    if !enemies.empty? && !@is_hit\\r\\n      @life -= 50\\r\\n      @hit_tick = Play.tick\\r\\n      @is_hit = true\\r\\n      Enemy.list.delete(enemies[0]) if enemies[0].data.name != \'ゴーレム\'\\r\\n    end\\r\\n\\r\\n    if @hit_tick != 0 && Play.tick - @hit_tick < 180\\r\\n      self.alpha += 30\\r\\n    else\\r\\n      self.alpha = 255\\r\\n      @is_hit = false\\r\\n    end\\r\\n\\r\\n    # Input\\r\\n    # spell change\\r\\n    @is_changed_spell = !(@_old_spell_num == @spell_num)\\r\\n    @_old_spell_num = @spell_num\\r\\n    @spell_num -= Input.mouse_wheel_pos / 120\\r\\n    Input.mouse_wheel_pos = 0\\r\\n    @spell_num -= 1 if Input.key_push?(K_Z)\\r\\n    @spell_num += 1 if Input.key_push?(K_X)\\r\\n    @spell = @spell_list[@spell_num % @spell_list.length]\\r\\n\\r\\n    @charge_percent = 0.0 if @_old_spell_num != @spell_num\\r\\n    @cool_time -= 1\\r\\n\\r\\n    if @cool_time <= 0\\r\\n      if !Input.mouse_down?(1)\\r\\n        @bullet_count += 1\\r\\n        _fire_bullet if @bullet_count % 14 == 0\\r\\n      end\\r\\n\\r\\n      if @charge_percent >= 1.0 && Input.mouse_release?(1)\\r\\n        _fire_bullet(level: 2)\\r\\n        @_mouse_down_count = 0\\r\\n      end\\r\\n\\r\\n      if Input.mouse_down?(1)\\r\\n        @_mouse_down_count += 1\\r\\n        @_mouse_down_count = [@_mouse_down_count, BulletData.charge_tick[@spell]].min\\r\\n      else\\r\\n        @_mouse_down_count = 0\\r\\n      end\\r\\n\\r\\n      @charge_percent = @_mouse_down_count.to_f / BulletData.charge_tick[@spell]\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    super\\r\\n\\r\\n    # ため攻撃のゲージ\\r\\n    Window.draw(self.x - 20, self.y + 10,\\r\\n                @charge_circle_img[(@charge_percent * 8).to_i])\\r\\n  end\\r\\n\\r\\n  def animation(frame)\\r\\n    self.image = @images[((@direction + 23) % 360) / 45][frame % 3]\\r\\n  end\\r\\n\\r\\n  private def _fire_bullet(level: 1)\\r\\n    if level == 1\\r\\n      _x = self.x + (image.width * 0.5)  + image.width  * 0.4 * Math.cos(@direction * Math::PI / 180.0)\\r\\n      _y = self.y + (image.height * 0.6) + image.height * 0.4 * Math.sin(@direction * Math::PI / 180.0)\\r\\n      Bullet.new(BulletData.list[:\\"level1_#{@spell}\\"], _x, _y)\\r\\n    elsif level == 2\\r\\n      case @spell\\r\\n      when :holy\\r\\n        Bullet.new(BulletData.list[:level2_holy], self.x, self.y)\\r\\n      else\\r\\n        bullet_name = :\\"level2_#{@spell}\\"\\r\\n        unless BulletData.list.keys.include?(bullet_name)\\r\\n          raise NameError, \\"BulletData.list undefined :#{bullet_name}\\"\\r\\n        end\\r\\n        Bullet.new(BulletData.list[bullet_name], nil, nil)\\r\\n      end\\r\\n      @cool_time = 100\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"scenes":{"game_over.rb":["txt","# Scene - GameOver\\r\\n\\r\\nclass GameOver < Scene\\r\\n  def self.new(symbol)\\r\\n    @font_big   = Font.new(140, \'Poco\')\\r\\n    @font_nomal = Font.new(90, \'Poco\')\\r\\n    @font_mini  = Font.new(50, \'Poco\')\\r\\n\\r\\n    @title_width = @font_big.get_width(\'Game Over\')\\r\\n    @score_is    = @font_nomal.get_width(\'score : \')\\r\\n    @tb = TextBox.new(Window.width * 0.3, Window.height * 0.7, Window.width * 0.4, 100,\\r\\n                      font_name: \'Poco\', font_size: 90, font_oy: - 16, cursor_scale: 0.9)\\r\\n\\r\\n    @alerts = []\\r\\n    @alerts_stay_cnt = []\\r\\n    @alerts_alpha = []\\r\\n    @symbol = symbol\\r\\n    Debugger._str = \'\'\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @tb.update\\r\\n    if Input.key_push?(K_RETURN)\\r\\n      # 名前の長さは8文字以下\\r\\n      # user name の末尾のスペースを消す\\r\\n      # 2つ以上の並んだスペースを1つのスペースに変換\\r\\n      if /^\\\\s+/ =~ @tb.string || @tb.string.length == 0\\r\\n        _call_alert(\'PLZ ENTER YOUR NAME!\')\\r\\n        @tb.string = \'\'\\r\\n      elsif @tb.string.length > 8\\r\\n        _call_alert(\'PLZ ENTER A NAME NO MORE THAN 8 CHAR!\')\\r\\n      else\\r\\n        SceneManager.next(:ranking, @tb.string, $score)\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    if @symbol == :game_clear\\r\\n      @title_width = @font_big.get_width(\'Game Clear\')\\r\\n      Window.draw_font(\\r\\n        (Window.width - @title_width) / 2,\\r\\n        (Window.height - @font_big.size) * 0.3,\\r\\n        \'Game Clear\',\\r\\n        @font_big\\r\\n      )\\r\\n    else\\r\\n      Window.draw_font(\\r\\n        (Window.width - @title_width) / 2,\\r\\n        (Window.height - @font_big.size) * 0.3,\\r\\n        \'Game Over\',\\r\\n        @font_big\\r\\n      )\\r\\n    end\\r\\n    score_width = @score_is + @font_nomal.get_width(\'0\') * $score.to_s.length\\r\\n    Window.draw_font(\\r\\n      (Window.width - score_width) / 2,\\r\\n      (Window.height - @font_nomal.size) * 0.4,\\r\\n      \\"score : #{$score}\\",\\r\\n      @font_nomal\\r\\n    )\\r\\n    @tb.draw\\r\\n\\r\\n    # draw alerts\\r\\n    i = 1\\r\\n    @alerts.reverse_each do |a|\\r\\n      Window.draw_alpha(0, (@alerts.length - i) * a.height, a, @alerts_alpha[-i])\\r\\n      if @alerts_stay_cnt[-i] > 0\\r\\n        @alerts_stay_cnt[-i] -= 1\\r\\n      else\\r\\n        @alerts_alpha[-i] -= 4\\r\\n      end\\r\\n      if @alerts_alpha[-i] <= 80\\r\\n        @alerts.delete_at(-i)\\r\\n        @alerts_alpha.delete_at(-i)\\r\\n        @alerts_stay_cnt.delete_at(-i)\\r\\n      end\\r\\n      i += 1\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self._call_alert(str)\\r\\n    str = str.to_s\\r\\n    @alerts << Image.new(@font_mini.get_width(str) + 20, @font_mini.size).\\r\\n      draw_font(10, 0, str, @font_mini, [230, 230, 230])\\r\\n    @alerts_stay_cnt << 160 # tick\\r\\n    @alerts_alpha << 255\\r\\n  end\\r\\n  private_class_method :_call_alert\\r\\nend\\r\\n"],"loading.rb":["txt","# Scene - Loading\\r\\n# specially scene\\r\\n# imported \'scene-manager.rb\'\\r\\nclass Loading < Scene\\r\\n  @font = Font.new(32)\\r\\n\\r\\n  def self.draw\\r\\n    Window.draw_font(0, 0, \'Loading\', @font)\\r\\n  end\\r\\nend\\r\\n"],"menu.rb":["txt","class Menu < Scene\\r\\n  def self.new\\r\\n    @cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    @cover.alpha = 100\\r\\n    @font_big = Font.new(160, \'Poco\')\\r\\n    @font     = Font.new(80, \'Poco\')\\r\\n    @font_jp  = Font.new(40, \'美咲ゴシック\')\\r\\n    @cursor = 0\\r\\n    @button_on_x = Window.width * 0.6\\r\\n    @button_off_x = Window.width * 0.7\\r\\n    @button_y = 270\\r\\n    @button_on = Sprite.new(@button_on_x, @button_y, Image.new(@font.get_width(\'ON\'), @font.size))\\r\\n    @button_off = Sprite.new(@button_off_x, @button_y, Image.new(@font.get_width(\'OFF\'), @font.size))\\r\\n    w = 400\\r\\n    h = 10\\r\\n    _bar = Image.new(w, h).\\r\\n      box_fill(h / 2, 0, w - h / 2, h, [180, 255, 255, 255]).\\r\\n      circle_fill(h / 2, h / 2, h / 2, [180, 255, 255, 255]).\\r\\n      circle_fill(w - h / 2, h / 2, h / 2, [180, 255, 255, 255])\\r\\n    _toggle = Image.new(30, 30).circle_fill(15, 15, 15, C_WHITE)\\r\\n    @bgm_seek_bar = SeekBar.new((Window.width - _bar.width) * 0.5, 300,\\r\\n                                _bar, _toggle, percent: BGM.volume)\\r\\n    @se_seek_bar = SeekBar.new((Window.width - _bar.width) * 0.5, 360,\\r\\n                               _bar, _toggle, percent: SE.volume)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    Input.mouse_enable = true\\r\\n    SceneManager.next(:play, is_init: false) if Input.key_release?(K_TAB)\\r\\n    @bgm_seek_bar.update\\r\\n    @se_seek_bar.update\\r\\n    BGM.volume = @bgm_seek_bar.percent\\r\\n    SE.volume = @se_seek_bar.percent\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Play.draw # プレイ画面の表示\\r\\n    @cover.draw\\r\\n    @bgm_seek_bar.draw\\r\\n    @se_seek_bar.draw\\r\\n\\r\\n    menu_x = (Window.width - @font_big.get_width(\'MENU\')) / 2\\r\\n    setting_x = (Window.width - @font_jp.get_width(\'設定\')) / 2\\r\\n    how_to_x = (Window.width - @font_jp.get_width(\'操作方法\')) / 2\\r\\n    ex = [220, 255, 255, 255]\\r\\n\\r\\n    Window.draw_font(menu_x,          0, \'MENU\', @font_big).\\r\\n      draw_font(setting_x,          220, \'設定\', @font_jp).\\r\\n      # draw_font(Window.width * 0.2, 200, \'音量\', @font_jp).\\r\\n      draw_font(Window.width * 0.2, 255, \'BGM\', @font).\\r\\n      draw_font(Window.width * 0.7, 255, \\"#{(BGM.volume * 100).floor}\\", @font).\\r\\n      draw_font(Window.width * 0.2, 316, \'SE\', @font).\\r\\n      draw_font(Window.width * 0.7, 316, \\"#{(SE.volume * 100).floor}\\", @font).\\r\\n      draw_font(how_to_x,           480, \'操作方法\', @font_jp).\\r\\n      draw_font(Window.width * 0.2, 560, \'移動\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.5, 560, \'マウスの位置\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.2, 620, \'チャージ攻撃\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.5, 620, \'右クリック\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.2, 680, \'スペルの変更\', @font_jp, color: ex).\\r\\n      draw_font(Window.width * 0.5, 680, \'Z, X or マウスホイール\', @font_jp, color: ex)\\r\\n  end\\r\\nend\\r\\n"],"play.rb":["txt","# Scene - Play\\r\\n\\r\\nclass Play < Scene\\r\\n  class << self\\r\\n    attr_reader :tick\\r\\n    attr_accessor :player, :stage\\r\\n  end\\r\\n\\r\\n  def self.new(stage_name)\\r\\n    Debugger.color = [240, 240, 240]\\r\\n    @tick = 0\\r\\n    @font_big = Font.new(100, \'Poco\')\\r\\n    @font = Font.new(80, \'Poco\')\\r\\n    @font_mid = Font.new(70, \'Poco\')\\r\\n    @font_mini = Font.new(50, \'Poco\')\\r\\n    @font_spell = Font.new(90, \'Poco\')\\r\\n    @font_clear = Font.new(200, \'Poco\')\\r\\n\\r\\n    _img = Image.load_tiles(\\"#{$PATH}/assets/image/wizard.png\\", 6, 4)\\r\\n    load_setting = [4, 3, 0, 1, 2, 7, 6, 5]\\r\\n    player_images = load_setting.map do |i|\\r\\n      s = i * 3\\r\\n      [_img[s], _img[s + 1], _img[s + 2]]\\r\\n    end\\r\\n    @player = Player.new(\\r\\n      :fire,\\r\\n      (Window.width - player_images[0][0].width) * 0.5, Window.height * 0.7,\\r\\n      player_images\\r\\n    )\\r\\n    _x = @player.x + @player.image.width / 2\\r\\n    _y = @player.y + @player.image.height / 2\\r\\n    Input.set_mouse_pos(_x * Window.scale, _y * Window.scale)\\r\\n    Bullet.reset\\r\\n    Enemy.reset\\r\\n    BulletData.load\\r\\n    @stage_name = stage_name.to_s\\r\\n    @stage = Stage.new(stage_name, StageData.load(@stage_name))\\r\\n\\r\\n    @book_anime = Image.load_tiles(\\"#{$PATH}/assets/image/book_anime.png\\", 16, 1)\\r\\n    @book = Sprite.new(10, 800, @book_anime[0])\\r\\n    @book_anime_count = 0\\r\\n\\r\\n    # sleep 1\\r\\n    SceneManager.next(:play_cut_in)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    Input.mouse_enable = true\\r\\n    $debug_mode = !$debug_mode if Input.key_release?(K_F5)\\r\\n    if @tick == 0\\r\\n      BGM.init\\r\\n      SE.init\\r\\n    end\\r\\n\\r\\n    SceneManager.next(:menu) if Input.key_release?(K_TAB)\\r\\n\\r\\n    @stage.update\\r\\n    if @stage.is_clear || Input.key_down?(K_F12)\\r\\n      _stage_clear\\r\\n      if @stage_name == \'1-6\'\\r\\n        SceneManager.next(:game_over, :game_clear, loading: true)\\r\\n      else\\r\\n        SceneManager.next(:stage_select, @stage_name, loading: true)\\r\\n      end\\r\\n    end\\r\\n\\r\\n    # update\\r\\n    @player.update\\r\\n\\r\\n    if @player.life <= 0\\r\\n      _game_over\\r\\n      SceneManager.next(:game_over, nil, skip_draw: false)\\r\\n    end\\r\\n\\r\\n    Bullet.update\\r\\n    i = -1\\r\\n    Enemy.list.length.times do\\r\\n      Enemy.list[i].update\\r\\n      i -= 1\\r\\n    end\\r\\n    Sprite.clean(Enemy.list)\\r\\n\\r\\n    if @book_anime_count != 0\\r\\n      @book_anime_count += 1\\r\\n      @book_anime_count = @book_anime_count % (@book_anime.length * 3)\\r\\n    end\\r\\n    @book_anime_count = 1 if @player.is_changed_spell\\r\\n\\r\\n    @book.image = @book_anime[@book_anime_count / 3]\\r\\n\\r\\n    @tick += 1\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Debugger.puts(\\"fps : #{Window.real_fps}\\")\\r\\n    Debugger.puts(\\"tick : #{@tick}\\")\\r\\n    Debugger.puts(\\"score : #{$score}\\")\\r\\n    Debugger.puts(\\"my life : #{@player.life}\\")\\r\\n    Debugger.puts(\\"player direction : #{@player.direction.to_i}°\\")\\r\\n    Debugger.puts(\\"bullet length : #{Bullet.list.length}\\")\\r\\n    Debugger.puts(\\"enemy length: #{Enemy.list.length}\\")\\r\\n\\r\\n    @stage.draw\\r\\n    Sprite.draw(Enemy.list)\\r\\n    Bullet.draw\\r\\n    @player.draw\\r\\n    Bullet.draw_after\\r\\n    HPBar.draw\\r\\n\\r\\n    _draw_book\\r\\n    _draw_ui\\r\\n\\r\\n    if $debug_mode\\r\\n      Debugger.draw_collision(\\r\\n        Enemy.list + [@player] + Bullet.list + @stage.objects\\r\\n      )\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self._draw_book\\r\\n    @book.draw\\r\\n    case @player.spell\\r\\n    when :wind\\r\\n      color = [20, 217, 105]\\r\\n    when :holy\\r\\n      color = C_BLACK\\r\\n    else\\r\\n      color = BulletData.spell_and_color[@player.spell]\\r\\n    end\\r\\n    str = \\"#{@player.spell}\\".upcase\\r\\n    Window.draw_font(115 - @font.get_width(str) / 2, 820, str, @font, color: color)\\r\\n  end\\r\\n  private_class_method :_draw_book\\r\\n\\r\\n  def self._draw_ui\\r\\n    case @player.life\\r\\n    when 0..100\\r\\n      color = [255, 0, 0]\\r\\n    when 101..150\\r\\n      color = [255, 210, 0]\\r\\n    else\\r\\n      color = [70, 130, 180]\\r\\n    end\\r\\n    Window.draw_font(10, -20, \\"LIFE : #{@player.life}\\", @font, color: color)\\r\\n    if @stage.now == @stage.waves.length\\r\\n      wave = \'CLEAR\'\\r\\n    else\\r\\n      wave = \\"#{@stage.now + 1} / #{@stage.waves.length}\\"\\r\\n    end\\r\\n    x = (Window.width - @font_mid.get_width(\\"STAGE : #{@stage_name}\\")) * 0.5\\r\\n    Window.draw_font(x, -15, \\"STAGE : #{@stage_name}\\", @font_mid)\\r\\n    x = (Window.width - @font_big.get_width(\\"WAVE : #{wave}\\")) * 0.5\\r\\n    Window.draw_font(x, 10, \\"WAVE : #{wave}\\", @font_big)\\r\\n    w = @font.get_width([\'SCORE : \', $score].join)\\r\\n    Window.draw_font(Window.width - w - 40, -20, \\"SCORE : #{$score}\\", @font)\\r\\n    Window.draw_font(230, Window.height - 60, \\"[TAB] MENU\\", @font_mini, color: [230, 230, 230])\\r\\n    Window.draw_font(Window.width - 200, Window.height - 60,\\r\\n                     \\"<FPS : #{Window.real_fps}>\\", @font_mini, color: [230, 230, 230])\\r\\n    # Window.draw_font(Window.width - w - 40, 20, \\"LEVEL : #{@player.level}\\", @font)\\r\\n  end\\r\\n  private_class_method :_draw_ui\\r\\n\\r\\n  def self._stage_clear\\r\\n    cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    cover.alpha = 0\\r\\n    @player.alpha = 255\\r\\n    i = 0\\r\\n    loop do\\r\\n      Play.draw\\r\\n\\r\\n      str = \\"STAGE CLEAR!\\"\\r\\n      x = (Window.width - @font_clear.get_width(str)) / 2\\r\\n      y = (Window.height - @font_clear.size) / 2\\r\\n      Window.draw_font(x, y, str, @font_clear)\\r\\n      if i > 400\\r\\n        cover.alpha += 15 if i % 30 == 0\\r\\n        break if cover.alpha > 255\\r\\n      end\\r\\n\\r\\n      cover.draw\\r\\n      i += 1\\r\\n      Window.update\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_stage_clear\\r\\n\\r\\n  def self._game_over\\r\\n    cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    cover.alpha = 0\\r\\n    @player.alpha = 255\\r\\n    i = 0\\r\\n    loop do\\r\\n      Window.update\\r\\n      Play.draw\\r\\n\\r\\n      cover.alpha += 15 if i % 30 == 0\\r\\n      break if cover.alpha > 255\\r\\n\\r\\n      cover.draw\\r\\n      i += 1\\r\\n    end\\r\\n\\r\\n    Play.draw\\r\\n  end\\r\\n  private_class_method :_game_over\\r\\nend\\r\\n"],"play_cut_in.rb":["txt","class PlayCutIn < Scene\\r\\n  def self.new\\r\\n    @player_x = Play.player.x\\r\\n    @player_y = Play.player.y\\r\\n    Play.player.y = Window.height\\r\\n    @cover = Sprite.new(0, 0, Image.new(Window.width, Window.height, C_BLACK))\\r\\n    @cover.alpha = 200\\r\\n    @tick = 0\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    Play.player.y -= Play.player.speed\\r\\n    Play.player.animation(@tick / 10)\\r\\n    @cover.alpha = [0, @cover.alpha - 10].max\\r\\n    if Play.player.y < @player_y\\r\\n      Play.player.y = @player_y\\r\\n      Play.player.animation(1)\\r\\n      SceneManager.next(:play, is_init: false, skip_draw: false)\\r\\n    end\\r\\n\\r\\n    @tick += 1\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Play.stage.draw\\r\\n    Sprite.draw(Enemy.list)\\r\\n    Play.player.draw\\r\\n    @cover.draw\\r\\n  end\\r\\nend\\r\\n"],"ranking.rb":["txt","class Ranking < Scene\\r\\n  def self.new(user_name, score)\\r\\n    @font_title = Font.new(140, \'Poco\')\\r\\n    @font_big   = Font.new(120, \'Poco\')\\r\\n    @font_nomal = Font.new(100, \'Poco\')\\r\\n    @font_mini  = Font.new(48, \'Poco\')\\r\\n\\r\\n    begin\\r\\n      @user_db = open(\'user\') {|io| JSON.load(io) }\\r\\n    rescue StandardError\\r\\n      @user_db = {}\\r\\n    end\\r\\n\\r\\n    t = Time.now\\r\\n    @user_db[user_name] = {\\r\\n      \'score\' => score.to_i,\\r\\n      \'time\' => \\"#{t.year}/#{t.month}/#{t.day} #{t.hour}:#{t.min == 0 ? \'00\' : t.min}\\",\\r\\n    }\\r\\n\\r\\n    @user_db = @user_db.sort_by {|data| [-data[1][\'score\'], data[0].upcase] }\\r\\n    @user_db.pop(@user_db.length - 10) if @user_db.length > 10\\r\\n    @user_db = @user_db.to_h\\r\\n\\r\\n    str = JSON.pretty_generate(@user_db)\\r\\n    File.open(\'user\', \'w\') do |f|\\r\\n      f.write(str)\\r\\n      f.write(\\"\\\\n\\")\\r\\n    end\\r\\n\\r\\n    str = \'SCORE RANKING\'\\r\\n    w = @font_title.get_width(str)\\r\\n    img = Image.new(w + 20, @font_title.size * 0.8).draw_font(10, -36, str, @font_title)\\r\\n    @title = Sprite.new((Window.width - img.width) / 2, 60, img)\\r\\n\\r\\n    @table = []\\r\\n    @user_db.each_with_index do |item, i|\\r\\n      break if i >= 5\\r\\n\\r\\n      name = item[0]\\r\\n      score = item[1][\'score\']\\r\\n      time = item[1][\'time\']\\r\\n      w = [\\r\\n        @font_big.get_width(name.to_s) + 20,\\r\\n        @font_nomal.get_width(score.to_s) + 20,\\r\\n        @font_mini.get_width(time.to_s) + 20,\\r\\n      ]\\r\\n      name_s =  @font_big.get_width(\'AAAAAAAA\')\\r\\n      score_s = name_s + @font_big.get_width(\'1000\')\\r\\n      name_img =  Image.new(w[0], @font_big.size   * 0.8).draw_font(10, -30, name.to_s, @font_big)\\r\\n      score_img = Image.new(w[1], @font_nomal.size * 0.8).draw_font(10, -20, score.to_s, @font_nomal)\\r\\n      time_img =  Image.new(w[2], @font_mini.size).draw_font(10, -10, time.to_s, @font_mini, [240, 240, 240])\\r\\n      name_h = 220 + i * @font_big.size * 0.9\\r\\n      score_h = 220 + i * @font_big.size * 0.9 + name_img.height - score_img.height - 10\\r\\n      time_h = 220 + i * @font_big.size * 0.9 + name_img.height - time_img.height - 10\\r\\n      @table << Sprite.new(240,           name_h,  name_img)\\r\\n      @table << Sprite.new(260 + name_s,  score_h, score_img)\\r\\n      @table << Sprite.new(280 + score_s, time_h,  time_img)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    if Input.key_push?(K_RETURN) || Input.key_push?(K_SPACE)\\r\\n      SceneManager.next(:title)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @title.draw\\r\\n    Sprite.draw(@table)\\r\\n  end\\r\\nend\\r\\n"],"stage_select.rb":["txt","class StageSelect < Scene\\r\\n  def self.new(stage_name)\\r\\n    @font = Font.new(80, \'Poco\')\\r\\n    @stage_name = stage_name\\r\\n    if /(\\\\d)-(?<section>\\\\d)/ =~ @stage_name\\r\\n      $stage = [section.to_i, $stage].max\\r\\n    else\\r\\n      raise ArgumentError, \\"stage_name ( <chapter>-<section> )\\"\\r\\n    end\\r\\n    @stage_base = []\\r\\n    2.times do |y|\\r\\n      3.times do |x|\\r\\n        _x = (Window.width - 300 * 2 - 250) / 2\\r\\n        _y = (Window.height - 250 * 1 - 200) / 2\\r\\n        @stage_base << Sprite.new(_x + x * 300, _y + y * 250, Image.new(250, 200, [150, 255, 255, 255]))\\r\\n      end\\r\\n    end\\r\\n    @tick = 0\\r\\n  end\\r\\n\\r\\n  def self.set_music\\r\\n    BGM.list[:mist][0].play\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @tick += 1\\r\\n    Input.mouse_enable = true\\r\\n    @stage_base.length.times do |i|\\r\\n      sp = @stage_base[i]\\r\\n      if sp.on_mouse?\\r\\n        if Input.mouse_push?(0) && i <= $stage\\r\\n          SceneManager.next(:play, \\"1-#{i + 1}\\", loading: true)\\r\\n        end\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    Sprite.draw(@stage_base)\\r\\n    Window.draw_font(10, -20, \'Stage Select\', @font)\\r\\n    Window.draw_font(10, 40, \\"CLEAR #{@stage_name}\\", @font)\\r\\n    @stage_base.length.times do |i|\\r\\n      sp = @stage_base[i]\\r\\n      Window.draw_font(sp.x + 8, sp.y + sp.image.height - @font.size, \\"1-#{i + 1}\\", @font, color: C_WHITE)\\r\\n      if $stage == i\\r\\n        Window.draw_font(sp.x + 120, sp.y - 20, \\"NEXT\\", @font, color: C_WHITE) if @tick % 20 > 10\\r\\n      elsif $stage < i\\r\\n        Window.draw_box_fill(sp.x, sp.y, sp.x + sp.image.width, sp.y + sp.image.height, [100, 0, 0, 0])\\r\\n      end\\r\\n      if sp.on_mouse?\\r\\n        Window.draw_box(sp.x, sp.y, sp.x + sp.image.width, sp.y + sp.image.height, C_WHITE)\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.last\\r\\n    BGM.list[:mist][0].stop\\r\\n  end\\r\\nend\\r\\n"],"title.rb":["txt","# Scene - Title\\r\\n\\r\\nclass Title < Scene\\r\\n  def self.new\\r\\n    @font_title = Font.new(300, \'Poco\')\\r\\n    @font = Font.new(160, \'Poco\')\\r\\n    @bgm = Sound.new(\\"#{$PATH}/assets/sound/38-5.wav\\") # 62.118 sec\\r\\n    @se_enter_play = Sound.new(\\"#{$PATH}/assets/sound/se_retro03.wav\\")\\r\\n    @se_cursor = Sound.new(\\"#{$PATH}/assets/sound/se_system27.wav\\")\\r\\n    play = @font.get_width(\'PLAY\')\\r\\n    credit = @font.get_width(\'CREDIT\')\\r\\n    exit_  = @font.get_width(\'EXIT\')\\r\\n    @section_play = Sprite.new(900, 500, Image.new(play + 10, 90, C_CYAN))\\r\\n    @section_credit = Sprite.new(850, 600, Image.new(credit + 10, 90, C_CYAN))\\r\\n    @section_exit   = Sprite.new(800, 700, Image.new(exit_ + 10,  90, C_CYAN))\\r\\n    @cursor = -99\\r\\n    @s_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    @blank = 60\\r\\n\\r\\n    @tick = 0\\r\\n    _img = Image.load_tiles(\\"#{$PATH}/assets/image/wizard.png\\", 6, 4)\\r\\n    load_setting = [4, 3, 0, 1, 2, 7, 6, 5]\\r\\n    @player_images = load_setting.map do |i|\\r\\n      s = i * 3\\r\\n      [_img[s], _img[s + 1], _img[s + 2]]\\r\\n    end\\r\\n    @mini_char = Sprite.new(60, Window.height - 100 - @player_images[0][0].height, @player_images[0][0])\\r\\n    @mini_char_anime = 0\\r\\n    @mini_field_top = Sprite.new(0, Window.height - 102, Image.new(Window.width, 22, [140, 255, 255, 255]))\\r\\n    @mini_field_img = Image.new(48, 80, [100, 255, 255, 255])\\r\\n    @bullets = []\\r\\n    @spell_count = 0\\r\\n    @hit_spell = nil\\r\\n    @_spell_color = {\\r\\n      fire: [255, 0, 0],\\r\\n      water: [55, 183, 230],\\r\\n      wind: [23, 255, 123],\\r\\n      holy: [249, 250, 212],\\r\\n      dark: [121, 73, 173],\\r\\n    }\\r\\n  end\\r\\n\\r\\n  def self.set_music\\r\\n    @bgm.set_volume(200)\\r\\n    @se_cursor.set_volume(224)\\r\\n    @bgm.play\\r\\n    @bgm.set_volume(226, 1000)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @tick += 1\\r\\n    # bgm loop\\r\\n    bgm_end = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    diff = (bgm_end - @s_time).floor(1)\\r\\n    if @blank <= 0 && diff % 61.5 == 0 # ずれが0.6秒くらい？\\r\\n      @bgm.play\\r\\n      @blank = 60\\r\\n    end\\r\\n    @blank = [0, @blank - 1].max\\r\\n\\r\\n    # cursor\\r\\n    if Input.key_push?(K_DOWN) || Input.key_push?(K_UP)\\r\\n      @se_cursor.play\\r\\n    end\\r\\n    @cursor += 1 if Input.key_push?(K_DOWN)\\r\\n    @cursor -= 1 if Input.key_push?(K_UP)\\r\\n    @cursor = [[0, @cursor].max, 2].min if @cursor != -99\\r\\n    if @section_play.on_mouse? || @section_credit.on_mouse? || @section_exit.on_mouse?\\r\\n      @cursor = -99\\r\\n    end\\r\\n\\r\\n    if Input.mouse_down?(0) || Input.key_down?(K_RETURN)\\r\\n      if @section_play.on_mouse? || @cursor == 0\\r\\n        @se_enter_play.play\\r\\n        if $stage == 1\\r\\n          SceneManager.next(:play, \'1-1\', loading: true)\\r\\n        else\\r\\n          SceneManager.next(:stage_select, \'1-6\', loading: true)\\r\\n        end\\r\\n        return\\r\\n      elsif @section_credit.on_mouse? || @cursor == 1\\r\\n        SceneManager.next(:play, \'1-1\', loading: true)\\r\\n        return\\r\\n      elsif @section_exit.on_mouse? || @cursor == 2\\r\\n        Window.close\\r\\n      end\\r\\n    end\\r\\n\\r\\n    # mini charactor\\r\\n    if @tick % 10 == 0\\r\\n      @mini_char_anime = (@mini_char_anime + 1) % 3\\r\\n      @mini_char.image = @player_images[0][@mini_char_anime]\\r\\n    end\\r\\n\\r\\n    if Input.key_push?(K_SPACE) || Input.mouse_push?(0)\\r\\n      x = @mini_char.x + @mini_char.image.width * 0.7\\r\\n      y = @mini_char.y + @mini_char.image.height * 0.6\\r\\n      spell = @_spell_color.keys[@spell_count]\\r\\n      img = Image.new(10, 10, @_spell_color.values[@spell_count])\\r\\n      @bullets << { :\\"#{spell}\\" => Sprite.new(x, y, img) }\\r\\n      @spell_count = (@spell_count + 1) % 5\\r\\n    end\\r\\n    @bullets.each do |b|\\r\\n      bullet = b.values[0]\\r\\n      spell = b.keys[0]\\r\\n      bullet.x += 10\\r\\n      @hit_spell = spell if bullet.x >= Window.width - 10\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    c = @hit_spell ? @_spell_color[@hit_spell] : C_WHITE\\r\\n    Window.draw_font(30, -100, \'Spell\', @font_title, color: c)\\r\\n    Window.draw_font(30,  100, \'Out\',   @font_title, color: c)\\r\\n    # @section_play.draw\\r\\n    # @section_credit.draw\\r\\n    # @section_exit.draw\\r\\n\\r\\n    _draw_section(@section_play,   0, \'PLAY\')\\r\\n    _draw_section(@section_credit, 1, \'CREDIT\')\\r\\n    _draw_section(@section_exit,   2, \'EXIT\')\\r\\n\\r\\n    @mini_char.draw\\r\\n    _draw_mini_char_field\\r\\n    @bullets.each do |b|\\r\\n      bullet = b.values[0]\\r\\n      # spell = b.keys[0]\\r\\n      bullet.draw\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.last\\r\\n    @bgm.stop\\r\\n    @bgm.dispose\\r\\n  end\\r\\n\\r\\n  def self._draw_section(sp, cursor, section_name)\\r\\n    args = sp.x + 10, sp.y - 60, section_name.upcase, @font\\r\\n    if sp.on_mouse? || @cursor == cursor\\r\\n      Window.draw_font(*args)\\r\\n      Window.draw_line(sp.x, sp.y + sp.image.height,\\r\\n                       sp.x + sp.image.width, sp.y + sp.image.height, C_WHITE)\\r\\n    else\\r\\n      Window.draw_font(*args, color: [200, 255, 255, 255])\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_draw_section\\r\\n\\r\\n  def self._draw_mini_char_field\\r\\n    @mini_field_top.draw\\r\\n\\r\\n    base_y = @mini_char.y + @mini_char.image.height + 20\\r\\n    17.times do |i|\\r\\n      x = i * 80 - @tick % 80\\r\\n      w = @mini_field_img.width\\r\\n      h = @mini_field_img.height\\r\\n      Window.draw_morph(x + 30, base_y, x, base_y + h, x + w, base_y + h, x + w + 30, base_y, @mini_field_img)\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_draw_mini_char_field\\r\\nend\\r\\n"]},"stage.rb":["txt","class Stage\\r\\n  attr_reader :is_clear, :name, :waves, :now, :wave\\r\\n\\r\\n  def initialize(name, waves)\\r\\n    @name = name\\r\\n    @waves = waves\\r\\n    @now = 0\\r\\n    @wave = @waves[@now]\\r\\n    @is_clear = false\\r\\n    @wave.proc_begin.call(@wave)\\r\\n    @wave.spawn_tick = Play.tick\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    # if (@now == @waves.length && Enemy.list.length == 0) || (@boss_flag && !exists_boss?)\\r\\n    #   @is_clear = true\\r\\n    # end\\r\\n    @wave.proc_update.call(@wave)\\r\\n\\r\\n    # wave clear\\r\\n    if (Enemy.list.length == 0 && @wave.judge_flag.nil?) || @wave.judge_flag == true\\r\\n      @wave.proc_end.call(@wave)\\r\\n      @now += 1\\r\\n      if @now > @waves.length - 1\\r\\n        @is_clear = true\\r\\n      else\\r\\n        @wave = @waves[@now]\\r\\n        @wave.proc_begin.call(@wave)\\r\\n        @wave.spawn_tick = Play.tick\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    Window.draw(0, 0, @wave.bg_image)\\r\\n    Sprite.draw(@wave.field_objects)\\r\\n  end\\r\\n\\r\\n  def objects\\r\\n    @wave.field_objects\\r\\n  end\\r\\n\\r\\n  def objects=(item)\\r\\n    @wave.field_objects = item\\r\\n  end\\r\\n\\r\\n  def exists_boss?\\r\\n    @boss.each do |b|\\r\\n      return true if Enemy.list.include?(b)\\r\\n    end\\r\\n    false\\r\\n  end\\r\\nend\\r\\n"],"utils":{"bgm.rb":["txt","class BGM\\r\\n  @list = {\\r\\n    # name: [sound, lenth(sec), base_volume]\\r\\n    chill: [Sound.new(\\"#{$PATH}/assets/sound/32-2.wav\\"), 78.0, 240],\\r\\n    mist: [Sound.new(\\"#{$PATH}/assets/sound/38-5.wav\\"), 62.1, 240],\\r\\n  }\\r\\n  @play_scene = [:play, :menu, :game_over, :ranking]\\r\\n  @now = :chill\\r\\n  @start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n  @blank = 60\\r\\n  @volume = 1\\r\\n\\r\\n  class << self\\r\\n    attr_reader :list, :start_time, :volume\\r\\n    attr_accessor :now\\r\\n  end\\r\\n\\r\\n  def self.init\\r\\n    @list[@now][0].stop\\r\\n    @start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    @list[@now][0].set_volume(96 + (@list[@now][2] - 96) * @volume)\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @list[@now][0].stop unless @play_scene.include?(SceneManager.now)\\r\\n    # bgm loop\\r\\n    bgm_end = Process.clock_gettime(Process::CLOCK_MONOTONIC)\\r\\n    diff = (bgm_end - @start_time).floor(1)\\r\\n    if @blank <= 0 && (diff % (@list[@now][1] - 0.5)) == 0\\r\\n      @list[@now][0].play\\r\\n      @blank = 60\\r\\n    end\\r\\n    @blank = [0, @blank - 1].max\\r\\n  end\\r\\n\\r\\n  def self.volume=(volume)\\r\\n    @volume = volume\\r\\n    @list.each do |k, v|\\r\\n      v[0].set_volume(96 + (v[2] - 96) * @volume)\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nBGM.new\\r\\n"],"debugger.rb":["txt","# Tools - Debegger\\r\\n\\r\\nclass Debugger\\r\\n  @font = Font.new(24)\\r\\n  @color = C_WHITE\\r\\n  @ox = 0\\r\\n  @oy = 0\\r\\n  @_str = \'\'\\r\\n  @_list = []\\r\\n\\r\\n  def self.new(font_size: 24, font_name: \'\', option: {},\\r\\n               color: C_WHITE, ox: 10, oy: 10)\\r\\n    @font = Font.new(font_size, font_name, option)\\r\\n    @color = color\\r\\n    @ox = ox\\r\\n    @oy = oy\\r\\n    @_str = \'\'\\r\\n    @_list = []\\r\\n  end\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :font, :color, :ox, :oy, :_str, :_list\\r\\n  end\\r\\n\\r\\n  def self.print(str)\\r\\n    @_str << str.to_s\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def self.puts(str)\\r\\n    @_str << [str.to_s.chomp, \\"\\\\n\\"].join\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def self.draw_msg\\r\\n    @_str.split(/\\\\R/).each_with_index do |msg, i|\\r\\n      Window.draw_font(@ox, @oy + @font.size * i, msg, @font, color: @color)\\r\\n    end\\r\\n    @_str = \'\'\\r\\n  end\\r\\n\\r\\n  def self.add_block(&block)\\r\\n    @_list << block\\r\\n    self\\r\\n  end\\r\\n\\r\\n  def self.block_call\\r\\n    @_list.each {|l| l.call }\\r\\n    @_list = []\\r\\n  end\\r\\n\\r\\n  # arg: sprites : Sprite Object | [ Sprite Object ]\\r\\n  def self.draw_collision(sprites)\\r\\n    if sprites.class < Sprite\\r\\n      sprites = [sprites]\\r\\n    elsif sprites.class == Array\\r\\n    else\\r\\n      raise ArgumentError, \\"sprites please : (Sprite | Array[Sprite])\\"\\r\\n    end\\r\\n    sprites.each do |sp|\\r\\n      next unless sp.collision_enable\\r\\n      col = sp.collision\\r\\n\\r\\n      # スケールやアングルが変わっている場合\\r\\n      if sp.angle != 0 || sp.scale_x != 1 || sp.scale_y != 1\\r\\n        img = Image.new(sp.image.width, sp.image.height)\\r\\n        if col.nil? # box\\r\\n          img.box(0, 0, sp.image.width, sp.image.height, @color)\\r\\n        elsif col.length == 2 # dot\\r\\n          img.pixel(*col, @color)\\r\\n        elsif col.length == 3 # circle\\r\\n          img.circle(*col, @color)\\r\\n        elsif col.length == 4 # box\\r\\n          img.box(*col, @color)\\r\\n        elsif col.length == 6 # triangle\\r\\n          img.triangle(*col, @color)\\r\\n        end\\r\\n        Window.draw_ex(sp.x, sp.y, img,\\r\\n                       scale_x: sp.scale_x,\\r\\n                       scale_y: sp.scale_y,\\r\\n                       center_x: sp.center_x,\\r\\n                       center_y: sp.center_y,\\r\\n                       angle: sp.angle)\\r\\n      else\\r\\n        if col.nil? # box\\r\\n          Window.draw_box(sp.x, sp.y, sp.x + sp.image.width, sp.y + sp.image.height, @color)\\r\\n          next\\r\\n        else\\r\\n          new_col = col.map.with_index do |_col, index|\\r\\n            if index % 2 == 0\\r\\n              sp.x + _col\\r\\n            else\\r\\n              sp.y + _col\\r\\n            end\\r\\n          end\\r\\n        end\\r\\n\\r\\n        if col.length == 2 # dot\\r\\n          Window.draw_pixel(*new_col, @color)\\r\\n        elsif col.length == 3 # circle\\r\\n          Window.draw_circle(sp.x + col[0], sp.y + col[1], col[2], @color)\\r\\n        elsif col.length == 4 # box\\r\\n          Window.draw_box(*new_col, @color)\\r\\n        elsif col.length == 6 # triangle\\r\\n          Window.draw_triangle(*new_col, @color)\\r\\n        end\\r\\n      end\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"easing.rb":["txt","# Easing Referrence\\r\\n# https://easings.net/\\r\\n# http://gizma.com/easing/\\r\\n\\r\\n\\r\\nclass Easing\\r\\n  # 0.0 <= t < 1.0\\r\\n\\r\\n  @_tick = 0\\r\\n  @_processor = {}\\r\\n\\r\\n  class << self\\r\\n    attr_accessor :_tick, :time, :_processor\\r\\n\\r\\n    def _update\\r\\n      @_tick += 1\\r\\n      @time = @_tick / 60.0\\r\\n\\r\\n      @_processor.each { |key, process| process.call }\\r\\n    end\\r\\n\\r\\n    # return [t, b, c, d]\\r\\n    private def _ease_fanc_init(start_value, change_value, duration: 1.0, _passed_tick: nil)\\r\\n      if _passed_tick.nil?\\r\\n        t = @time\\r\\n      else\\r\\n        t = (@_tick - _passed_tick) / 60.0\\r\\n      end\\r\\n      b = start_value.to_f\\r\\n      c = change_value.to_f\\r\\n      d = duration.to_f\\r\\n      [t, b, c, d]\\r\\n    end\\r\\n  end\\r\\n\\r\\n  Window.before_call[:easing_update] = method(:_update)\\r\\n\\r\\n  def initialize(obj, target_attr, ease_sym, start_val, end_val)\\r\\n    @obj = obj\\r\\n    @target_attr = target_attr.to_sym\\r\\n    @ease_sym = ease_sym\\r\\n\\r\\n    t = self.class._tick\\r\\n    case @obj\\r\\n    when Array\\r\\n      self.class._processor[:\\"#{obj.object_id}_#{@target_attr}\\"] = proc {\\r\\n        obj.each do |o|\\r\\n          o.method(\\"#{@target_attr}=\\").call(\\r\\n            self.class.method(ease_sym).call(start_val, end_val, _passed_tick: t)\\r\\n          )\\r\\n        end\\r\\n      }\\r\\n    else\\r\\n      self.class._processor[:\\"#{obj.object_id}_#{@target_attr}\\"] = proc {\\r\\n        obj.method(\\"#{@target_attr}=\\").call(\\r\\n          self.class.method(ease_sym).call(start_val, end_val, _passed_tick: t)\\r\\n        )\\r\\n      }\\r\\n    end\\r\\n  end\\r\\n\\r\\n\\r\\n  # === sine ===\\r\\n  def self.ease_in_sine(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    -c * Math.cos(t / d * (Math::PI / 2)) + c + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_sine(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    c * Math.sin(t / d * (Math::PI / 2)) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_sine(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    -c / 2 * (Math.cos(Math::PI * t / d) - 1) + b\\r\\n  end\\r\\n\\r\\n  # === quad ===\\r\\n  def self.ease_in_quad(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n\\t  c * t * t + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_quad(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n\\t  -c * t * (t - 2) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_quad(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d/2\\r\\n    return c / 2 * t * t + b if t < 1\\r\\n    t -= 1\\r\\n    -c / 2 * (t * (t - 2) - 1) + b\\r\\n  end\\r\\n\\r\\n  # === cubic ===\\r\\n  def self.ease_in_cubic(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n    c * t * t * t + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_cubic(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n    t -= 1\\r\\n    c * (t * t * t + 1) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_cubic(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d / 2.0\\r\\n    if t < 1\\r\\n      c / 2.0 * t * t * t + b\\r\\n    else\\r\\n      t -= 2\\r\\n      c / 2.0 * (t * t * t + 2) + b\\r\\n    end\\r\\n  end\\r\\n\\r\\n  # === quart ===\\r\\n  def self.ease_in_quart(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n\\t  c * t * t * t * t + b\\r\\n  end\\r\\n\\r\\n  def self.ease_out_quart(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d\\r\\n    t -= 1\\r\\n    -c * (t * t * t * t - 1) + b\\r\\n  end\\r\\n\\r\\n  def self.ease_in_out_quart(start_value, change_value, duration: 1.0, **args)\\r\\n    t, b, c, d = *_ease_fanc_init(start_value, change_value, duration: duration, **args)\\r\\n\\r\\n    t %= d # loop\\r\\n    t /= d / 2\\r\\n    return c / 2 * t * t * t * t + b if t < 1\\r\\n    t -= 2\\r\\n    -c / 2 * (t * t * t * t - 2) + b\\r\\n  end\\r\\nend\\r\\n"],"hp_bar.rb":["txt","class HPBar\\r\\n  class << self\\r\\n    attr_reader :enemy_hp_bar, :boss_hp_bar\\r\\n  end\\r\\n\\r\\n  def self.new\\r\\n    @enemy_hp_bar = []\\r\\n    @boss_hp_bar = []\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @enemy_hp_bar.each do |me|\\r\\n      if !Enemy.list.include?(me[:enemy]) || me[:enemy].vanished? || !me[:enemy].collision_enable\\r\\n        @enemy_hp_bar.delete(me)\\r\\n      end\\r\\n      next if me[:enemy].data.hp == me[:enemy].data.max_hp\\r\\n\\r\\n      me[:bar] = Image.new(1 + me[:base].width * (me[:enemy].data.hp / me[:enemy].data.max_hp.to_f),\\r\\n                           me[:base].height - 4,\\r\\n                           C_GREEN)\\r\\n      x = me[:enemy].x + (me[:enemy].image.width - me[:base].width) / 2\\r\\n      y = me[:enemy].y #- me[:base].height\\r\\n      Window.draw(x, y, me[:base])\\r\\n      Window.draw(x + 2, y + 2, me[:bar])\\r\\n    end\\r\\n  end\\r\\nend\\r\\n\\r\\nHPBar.new\\r\\n"],"scene_manager.rb":["txt","class Scene\\r\\n  def self.set_music\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n  end\\r\\n\\r\\n  def self.last\\r\\n  end\\r\\nend\\r\\n\\r\\n# Class for managing scene transitions\\r\\nclass SceneManager\\r\\n  class << self\\r\\n    attr_reader :now, :scenes\\r\\n  end\\r\\n\\r\\n  # Enumerate scenes by Hash,\\r\\n  # (setting start scene, and first scene set whether to use loading)\\r\\n  def self.new(scenes, start: nil, loading: false)\\r\\n    # check type\\r\\n    raise ArgumentError, \'Please hash! #Arg:scenes\' if scenes.class != Hash\\r\\n\\r\\n    scenes.each do |ary|\\r\\n      if ary[0].class != Symbol\\r\\n        raise ArgumentError, \\"Please symbol! (#{ary[0]}) #Arg:scenes {symbol: SceneClass}\\"\\r\\n      elsif !(ary[1] < Scene)\\r\\n        raise ArgumentError, \\"Please inheritance Scene class! (#{ary[1]}) #Arg:scenes {symbol: SceneClass}\\"\\r\\n      end\\r\\n    end\\r\\n\\r\\n    @scenes = scenes\\r\\n    if start.nil?\\r\\n      @now = @scenes.first[0] # first symbol\\r\\n    elsif @scenes.key?(start)\\r\\n      @now = start\\r\\n    else\\r\\n      raise ArgumentError, \\"SceneManager haven\'t key \'#{start}\' Arg:start\\"\\r\\n    end\\r\\n\\r\\n    Loading.new\\r\\n    if loading\\r\\n      _do_loading\\r\\n    else\\r\\n      @scenes[@now].new # now scene init!\\r\\n    end\\r\\n\\r\\n    @_set_music = true\\r\\n    @_skip_draw = false\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    if @_set_music\\r\\n      @scenes[@now].set_music\\r\\n      @_set_music = false\\r\\n    end\\r\\n\\r\\n    @_skip_draw = false\\r\\n    @scenes[@now].update\\r\\n  end\\r\\n\\r\\n  def self.draw\\r\\n    @scenes[@now].draw unless @_skip_draw\\r\\n  end\\r\\n\\r\\n  def self.next(scene_symbol, *args, loading: false, is_init: true, skip_draw: true)\\r\\n    unless @scenes.key?(scene_symbol)\\r\\n      raise ArgumentError, \\"SceneManager haven\'t key \'#{scene_symbol}\' Arg:scene_symbol\\"\\r\\n    end\\r\\n    raise ArgumentError, \\"\'#{scene_symbol}\' is now scene\\" if scene_symbol == @now\\r\\n\\r\\n    @_set_music = is_init\\r\\n    @_skip_draw = skip_draw\\r\\n    @scenes[@now].last\\r\\n    @now = scene_symbol\\r\\n\\r\\n    if is_init\\r\\n      if loading\\r\\n        _do_loading(*args)\\r\\n      else\\r\\n        @scenes[@now].new(*args)\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self._do_loading(*args)\\r\\n    thr = Thread.new do\\r\\n      @scenes[@now].new(*args) # load\\r\\n    end\\r\\n\\r\\n    loop do\\r\\n      if Input.key_push?(K_ESCAPE) && Input.key_push?(K_DELETE)\\r\\n        break\\r\\n      end\\r\\n\\r\\n      Window.update\\r\\n      Loading.update\\r\\n      Loading.draw\\r\\n      unless thr.alive?\\r\\n        Loading.last\\r\\n        break\\r\\n      end\\r\\n    end\\r\\n  end\\r\\n  private_class_method :_do_loading\\r\\nend\\r\\n"],"scrollable_page.rb":["txt","class ScrollablePage < RenderTarget\\r\\n  attr_reader :pos\\r\\n\\r\\n  def initialize(width, height, bgcolor: [0, 0, 0, 0],\\r\\n                 page_width: nil, page_height: nil,\\r\\n                 scrollbar: nil, scrollbar_base: nil,\\r\\n                 bar_w: 16, bar_color: [200, 200, 200], bar_base_color: C_WHITE)\\r\\n    super(width, height, bgcolor)\\r\\n    @page_width = page_width || self.width\\r\\n    @page_height = page_height || self.height\\r\\n\\r\\n    @bar_h_per = [self.height.to_f / @page_height, 1].min\\r\\n    @scrollbar = scrollbar || Image.new(bar_w, (self.height * @bar_h_per).to_i, bar_color)\\r\\n    @scrollbar_base = scrollbar_base || Image.new(bar_w, self.height, bar_base_color)\\r\\n\\r\\n    @pos = 0\\r\\n    @_before_mouse_wheel = Input.mouse_wheel_pos\\r\\n  end\\r\\n\\r\\n  def draw_scrollbar\\r\\n    draw(width - @scrollbar_base.width, @pos, @scrollbar_base)\\r\\n    draw(width - @scrollbar.width, @pos * @bar_h_per + @pos, @scrollbar)\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    scroll_volume = (@_before_mouse_wheel - Input.mouse_wheel_pos) / 120\\r\\n    scroll_volume *= 50\\r\\n    @_before_mouse_wheel = Input.mouse_wheel_pos\\r\\n\\r\\n    @pos += scroll_volume\\r\\n    @pos = [0, [@pos, @page_height - height].min].max\\r\\n  end\\r\\n\\r\\n  # wrapping methods\\r\\n  [\\r\\n    \'draw(x, y,image, z=0)\',\\r\\n    \'draw_scale(x, y, image, scale_x, scale_y, center_x=nil, center_y=nil, z=0)\',\\r\\n    \'draw_rot(x, y, image, angle, center_x=nil, center_y=nil, z=0)\',\\r\\n    \'draw_alpha(x, y, image, alpha, z=0)\',\\r\\n    \'draw_add(x, y, image, z=0)\',\\r\\n    \'draw_sub(x, y, image, z=0)\',\\r\\n    \'draw_shader(x, y, image, shader, z=0)\',\\r\\n    \'draw_ex(x, y, image, option={})\',\\r\\n    \'draw_font(x, y, text, font, option={})\',\\r\\n    \'draw_font_ex(x, y, text, font, option={})\',\\r\\n    \'draw_morph(x1, y1, x2, y2, x3, y3, x4, y4, image, option={})\',\\r\\n    \'draw_tile(base_x, base_y, map, image_array, start_x, start_y, size_x, size_y, z=0)\',\\r\\n    \'draw_pixel(x, y, color, z=0)\',\\r\\n    \'draw_line(x1, y1, x2, y2, color, z=0)\',\\r\\n    \'draw_box(x1, y1, x2, y2, color, z=0)\',\\r\\n    \'draw_box_fill(x1, y1, x2, y2, color, z=0)\',\\r\\n    \'draw_circle(x, y, r, color, z=0)\',\\r\\n    \'draw_circle_fill(x, y, r, color, z=0)\',\\r\\n  ].each do |method|\\r\\n    match = method.match(/^(\\\\w*)\\\\((.+)\\\\)$/)\\r\\n    name = match[1]\\r\\n    arg = match[2]\\r\\n    # puts \\"#{name}(#{arg})\\"\\r\\n    new_arg = arg.\\r\\n      gsub(/(\\\\w+)\\\\s*=.+?,/, \'\\\\\\\\1,\').\\r\\n      sub(/(\\\\w+)\\\\s*=.+?$/, \'\\\\\\\\1\').\\r\\n      gsub(/(x|x\\\\d), (y|y\\\\d),/, \'\\\\\\\\1, \\\\\\\\2 - @pos,\')\\r\\n    # puts \\"#{\' \' * (name.length - 2)}=> #{new_arg}\\"\\r\\n    eval \\"def #{name}(#{arg})\\r\\n            super(#{new_arg})\\r\\n          end\\"\\r\\n  end\\r\\nend\\r\\n"],"se.rb":["txt","class SE\\r\\n  @list = {\\r\\n    # key: [sound. base_volume(0 ~ 255)]\\r\\n    retro04: [Sound.new(\\"#{$PATH}/assets/sound/se_retro04.wav\\"), 230],\\r\\n    slime: [Sound.new(\\"#{$PATH}/assets/sound/slime1.wav\\"), 230],\\r\\n  }\\r\\n\\r\\n  @volume = 1\\r\\n\\r\\n  class << self\\r\\n    attr_reader :volume, :list\\r\\n  end\\r\\n\\r\\n  def self.init\\r\\n    @list.values.each do |sound|\\r\\n      sound[0].set_volume(96 + (sound[1] - 96) * @volume)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def self.play(symbol)\\r\\n    @list[symbol][0].play\\r\\n  end\\r\\n\\r\\n  def self.volume=(volume)\\r\\n    @volume = volume\\r\\n    @list.values.each do |sound|\\r\\n      sound[0].set_volume(96 + (sound[1] - 96) * @volume)\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"seek_bar.rb":["txt","class SeekBar < Sprite\\r\\n  attr_accessor :bar_image, :toggle_image, :percent, :pushed\\r\\n\\r\\n  def initialize(x, y, bar_image, toggle_image, percent: 1,\\r\\n                 enable_key_input: true,\\r\\n                 pushed_toggle_scale: 0.8)\\r\\n\\r\\n    super\\r\\n    self.x = x\\r\\n    self.y = y\\r\\n    @bar_image = bar_image\\r\\n    @toggle_image = toggle_image\\r\\n\\r\\n    @percent = percent\\r\\n    @enable_key_input = enable_key_input\\r\\n    @pushed_toggle_scale = pushed_toggle_scale\\r\\n\\r\\n    @pushed = false\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    @tog_x = x + @bar_image.width * @percent - @toggle_image.width * 0.5\\r\\n    @tog_y = y + (@bar_image.height - @toggle_image.height) * 0.5\\r\\n    if Input.mouse_push?(0) &&\\r\\n      (@tog_x..@tog_x + @toggle_image.width).include?(Mouse.x) &&\\r\\n      (@tog_y..@tog_y + @toggle_image.height).include?(Mouse.y)\\r\\n      @pushed = true\\r\\n    end\\r\\n    if Input.mouse_release?(0)\\r\\n      @pushed = false\\r\\n    end\\r\\n    if @pushed\\r\\n      per = (Mouse.x - x) / @bar_image.width.to_f\\r\\n      @percent = [[0, per].max, 1.0].min.floor(2)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    Window.draw(x, y, @bar_image)\\r\\n    Window.draw(@tog_x, @tog_y, @toggle_image)\\r\\n  end\\r\\nend\\r\\n"],"text_box.rb":["txt","class TextBox\\r\\n  attr_accessor :x, :y, :width, :height, :font_name, :font_size, :string, :frame_color, :font_color\\r\\n\\r\\n  def initialize(x, y, width, height,\\r\\n                 font_name: \'\', font_size: height * 0.8, font_color: C_WHITE, font_ox: 0, font_oy: 0,\\r\\n                 string: \'\', frame_color: C_WHITE, cursor_scale: 1)\\r\\n    @x = x\\r\\n    @y = y\\r\\n    @width = width\\r\\n    @height = height\\r\\n    @font_size = font_size\\r\\n    @string = string\\r\\n    @frame_color = frame_color\\r\\n    @font_color = font_color\\r\\n    @font = Font.new(@font_size, font_name)\\r\\n    @font_w = @font.get_width(@string)\\r\\n    @frame = Sprite.new(@x, @y, Image.new(@width, @height).box(0, 0, @width, @height, @frame_color))\\r\\n    @moji = Sprite.new(\\r\\n      @x + @width * 0.03 + font_ox,\\r\\n      @y + @height * 0.1 + font_oy,\\r\\n      Image.new(@width * 0.94, @height * 0.8).draw_font(0, 0, @string, @font, @font_color)\\r\\n    )\\r\\n    @cursor = Sprite.new(\\r\\n      @x + @width * 0.03,\\r\\n      @y + @height * 0.1,\\r\\n      Image.new(1, @font_size * cursor_scale, @frame_color)\\r\\n    )\\r\\n    @is_choose = true\\r\\n    @tick = 0\\r\\n    @alphabet = (\'a\'..\'z\').to_a\\r\\n    @flash_rate = 60\\r\\n  end\\r\\n\\r\\n  def update\\r\\n    return nil unless @is_choose\\r\\n\\r\\n    @tick += 1\\r\\n    typing\\r\\n    @font_w = @font.get_width(@string)\\r\\n    if @font_w > @moji.image.width\\r\\n      @cursor.x = @moji.x + @moji.image.width + 1\\r\\n      diff = @font_w - @moji.image.width\\r\\n      @moji.image =  Image.new(@width * 0.94, @height * 0.8).draw_font(-diff, 0, @string, @font, @font_color)\\r\\n    else\\r\\n      @cursor.x = @frame.x + @width * 0.03 + @font_w\\r\\n      @moji.image = Image.new(@width * 0.94, @height * 0.8).draw_font(0, 0, @string, @font, @font_color)\\r\\n    end\\r\\n  end\\r\\n\\r\\n  def draw\\r\\n    @frame.draw\\r\\n    @moji.draw\\r\\n    if @is_choose && (@tick % @flash_rate * 2 < @flash_rate)\\r\\n      @cursor.draw\\r\\n    end\\r\\n  end\\r\\n\\r\\n  private\\r\\n\\r\\n  def typing\\r\\n    26.times do |i|\\r\\n      next unless Input.key_push?(eval(\\"K_#{@alphabet[i].upcase}\\"))\\r\\n\\r\\n      @string << @alphabet[i].upcase\\r\\n\\r\\n      # choose upcase or down case cf. pushig shift key\\r\\n      # if Input.key_down?(K_LSHIFT) || Input.key_down?(K_RSHIFT)\\r\\n      #   @string += @alphabet[i].upcase\\r\\n      # else\\r\\n      #   @string += @alphabet[i]\\r\\n      # end\\r\\n    end\\r\\n    if Input.key_push?(K_SPACE) || Input.key_down?(K_SPACE) && @tick % 6 == 0\\r\\n      @string << \' \'\\r\\n    end\\r\\n    if @string.length > 0 && (Input.key_push?(K_BACK) || Input.key_down?(K_BACK) && @tick % 6 == 0)\\r\\n      @string.chop!\\r\\n    end\\r\\n  end\\r\\nend\\r\\n"],"wrapper.rb":["txt","# Wrapping `Input.mouse_x`, `Input.mouse_y` and `Input.mouse_enable`\\r\\n# And Update the mouse display when the keyboard is pressed\\r\\nclass Mouse\\r\\n  @x = nil\\r\\n  @y = nil\\r\\n  @is_draw = true\\r\\n\\r\\n  class << self\\r\\n    attr_reader :x, :y, :is_draw\\r\\n  end\\r\\n\\r\\n  def self.update\\r\\n    @old_x = @x\\r\\n    @old_y = @y\\r\\n    @x = Input.mouse_x / Window.scale\\r\\n    @y = Input.mouse_y / Window.scale\\r\\n\\r\\n    @is_draw = false unless Input.keys.empty?\\r\\n    @is_draw = true if !(@old_x == @x && @old_y == @y)\\r\\n    Input.mouse_enable = @is_draw\\r\\n  end\\r\\nend\\r\\n\\r\\n# wrapping `DXRuby::Sprite\\r\\n# Adding `on_mosue?()`\\r\\nclass Sprite\\r\\n  def on_mouse?\\r\\n    Mouse.is_draw == true &&\\r\\n      (x..x + image.width).include?(Mouse.x) &&\\r\\n      (y..y + image.height).include?(Mouse.y)\\r\\n  end\\r\\n\\r\\n  def mouse_clicked?(mouse_button)\\r\\n    (Input.mouse_down?(mouse_button) &&\\r\\n    (x..x + image.width).include?(Mouse.x) &&\\r\\n    (y..y + image.height).include?(Mouse.y))\\r\\n  end\\r\\nend\\r\\n"]}},"main.rb":["txt","require \'dxruby\'\\r\\nrequire \'json\'\\r\\nrequire \'time\'\\r\\nrequire \'pp\'\\r\\n\\r\\n$PATH = File.dirname(__FILE__)\\r\\n\\r\\nWindow.width = 1280\\r\\nWindow.height = 960\\r\\nWindow.scale = 0.8\\r\\nWindow.caption = \'Spell Out\'\\r\\nWindow.bgcolor = [26, 26, 26]\\r\\n\\r\\nFont.install(\\"#{$PATH}/assets/font/Poco.ttf\\")\\r\\nFont.install(\\"#{$PATH}/assets/font/misaki_gothic.ttf\\")\\r\\n\\r\\n$debug_mode = ARGV.include?(\'debug\') || ARGV.include?(\'-d\')\\r\\n$score = 0\\r\\n$stage = 1\\r\\n\\r\\nrequire_relative \'lib/utils/wrapper\'\\r\\nrequire_relative \'lib/utils/scene_manager\'\\r\\nrequire_relative \'lib/utils/debugger\'\\r\\nrequire_relative \'lib/utils/bgm\'\\r\\nrequire_relative \'lib/utils/se\'\\r\\nrequire_relative \'lib/utils/hp_bar\'\\r\\nrequire_relative \'lib/utils/text_box\'\\r\\nrequire_relative \'lib/utils/seek_bar\'\\r\\nrequire_relative \'lib/player\'\\r\\nrequire_relative \'lib/bullet\'\\r\\nrequire_relative \'lib/enemy\'\\r\\nrequire_relative \'lib/stage\'\\r\\nrequire_relative \'lib/data/sprite_data\'\\r\\nrequire_relative \'lib/data/enemies_data\'\\r\\nrequire_relative \'lib/data/bullet_data\'\\r\\nrequire_relative \'lib/data/stage_data\'\\r\\nrequire_relative \'lib/scenes/loading\'\\r\\nrequire_relative \'lib/scenes/title\'\\r\\nrequire_relative \'lib/scenes/stage_select\'\\r\\nrequire_relative \'lib/scenes/play_cut_in\'\\r\\nrequire_relative \'lib/scenes/play\'\\r\\nrequire_relative \'lib/scenes/menu\'\\r\\nrequire_relative \'lib/scenes/game_over\'\\r\\nrequire_relative \'lib/scenes/ranking\'\\r\\n\\r\\nDebugger.new(font_size: 48)\\r\\n\\r\\nSceneManager.new({\\r\\n  title: Title,\\r\\n  stage_select: StageSelect,\\r\\n  play_cut_in: PlayCutIn,\\r\\n  play: Play,\\r\\n  menu: Menu,\\r\\n  game_over: GameOver,\\r\\n  ranking: Ranking,\\r\\n})\\r\\n\\r\\nWindow.loop do\\r\\n  Window.close if Input.key_down?(K_ESCAPE)\\r\\n\\r\\n  Mouse.update\\r\\n  SceneManager.update\\r\\n  SceneManager.draw\\r\\n  BGM.update\\r\\n  if $debug_mode\\r\\n    Debugger.block_call\\r\\n    Debugger.draw_msg\\r\\n  end\\r\\nend\\r\\n"],"playground":{"easing_sample.rb":["txt","require \'dxruby\'\\r\\nrequire_relative \'./../lib/utils/easing\'\\r\\n\\r\\nWindow.bgcolor = C_WHITE\\r\\n\\r\\nboxes = []\\r\\n6.times do |i|\\r\\n  boxes << Sprite.new(60, 40 + 45 * i, Image.new(40, 40, [120, 160, 240]))\\r\\nend\\r\\n\\r\\nsp = Sprite.new(60, 320, Image.new(40, 40, [210, 120, 160, 240]))\\r\\nboxes2 = []\\r\\n3.times do |y|\\r\\n  boxes2 << Sprite.new(60, 380 + y * 23, Image.new(20, 20, [170, 120, 160, 240]))\\r\\nend\\r\\n\\r\\n\\r\\nfont = Font.new(24, \\"Comic sans MS\\")\\r\\n\\r\\nWindow.loop do\\r\\n  break if Input.key_down?(K_ESCAPE)\\r\\n\\r\\n  if Input.key_push?(K_SPACE)\\r\\n    Easing.new(sp, :x, :ease_in_out_quad, 60, 260)\\r\\n    Easing.new(boxes2, :x, :ease_in_out_quad, 60, 260)\\r\\n  end\\r\\n\\r\\n  boxes[0].x = Easing.ease_in_quart(        60, 260)\\r\\n  boxes[1].x = Easing.ease_out_quart(       60, 260)\\r\\n  boxes[2].x = Easing.ease_in_out_quad(    60, 260)\\r\\n  boxes[3].x = Easing.ease_in_sine(    60, 260)\\r\\n  boxes[4].x = Easing.ease_out_sine(   60, 260)\\r\\n  boxes[5].x = Easing.ease_in_out_sine(60, 260)\\r\\n\\r\\n  boxes.length.times do |i|\\r\\n    Window.draw_font_ex(10, 50 + 45 * i, \\"#{((boxes[i].x - 60) * 100.0 / 260).round}%\\", font, color: C_BLACK)\\r\\n  end\\r\\n  Sprite.draw(boxes)\\r\\n  Sprite.draw(boxes2)\\r\\n  sp.draw\\r\\n\\r\\n  Window.draw_font_ex(0, 0, \\"fps: #{Window.real_fps}\\", font, color: C_BLACK)\\r\\nend\\r\\n"],"scrollable_page_test.rb":["txt","require \'dxruby\'\\r\\nrequire_relative \'../lib/utils/scrollable_page\'\\r\\n\\r\\nFont.install(\'MonospaceBold.ttf\')\\r\\n\\r\\npage = ScrollablePage.new(500, 400, bgcolor: [34, 34, 34], page_height: 800)\\r\\n\\r\\nfont = Font.new(24)\\r\\nfont_code = Font.new(21, \'Monospace\')\\r\\n\\r\\nusage = \\"\\r\\npage = ScrollablePage.new(\\r\\n  500, 400, bgcolor: [34, 34, 34], page_height: 800\\r\\n)\\r\\n\\r\\na = Sprite.new(100, 0, Image.new(50, 50, C_RED))\\r\\na.target = page\\r\\n\\r\\nWindow.loop do\\r\\n  break if Input.key_down? K_ESCAPE\\r\\n\\r\\n  page.update\\r\\n\\r\\n  page.draw_font(10, 550, \\\\\'Sample Text\\\\\', font)\\r\\n  a.y = 650 - page.pos\\r\\n  a.draw\\r\\n\\r\\n  page.draw_scrollbar\\r\\n  Window.draw(70, 40, page)\\r\\nend\\r\\n\\".split(/\\\\R/)\\r\\n\\r\\na = Sprite.new(100, 0, Image.new(50, 50, C_RED))\\r\\na.target = page\\r\\n\\r\\nWindow.loop do\\r\\n  break if Input.key_down? K_ESCAPE\\r\\n\\r\\n  page.update\\r\\n\\r\\n  page.draw_font(10, 10, \\"FPS : #{Window.real_fps}\\", font)\\r\\n  page.draw_font(10, 34, \'class ScrollablePage\', font)\\r\\n  page.draw_font(10, 60, \'マウスのスクロールで動かせます\', font)\\r\\n  usage.length.times do |i|\\r\\n    page.draw_font(10, 100 + font_code.size * i, usage[i], font_code)\\r\\n  end\\r\\n  page.draw_font(10, 550, \'result ... \', font)\\r\\n  page.draw_font(10, 600, \'Sample Text\', font)\\r\\n  str = \'© stonesaw\'\\r\\n  page.draw_font((page.width - font.get_width(str)) / 2, 800 - 34, str, font)\\r\\n\\r\\n  a.y = 650 - page.pos\\r\\n  a.draw\\r\\n\\r\\n  page.draw_scrollbar\\r\\n  Window.draw(70, 40, page)\\r\\n\\r\\n  Window.draw_font(10, 10, page.pos.to_s, font)\\r\\nend\\r\\n"]},"repo.link":["link","https://github.com/stonesaw/Spell-Out"]}}}')},790:function(n){n.exports=JSON.parse('{"test":{"hello":"hello world","format":"Hi, {name}!","multiline":["multiline with array","line: {one}","line: {two}"]},"help":{"summary":{"cd":"change directory.","ls":"list segments.","cat":"show txt file content.","history":"command history.","lang":"change language.","open":"open link file.","share":"share sns."}},"messages":{"clear_history":"cleared history","no_history":"no history"},"errors":{"is_not_dir":"\\"{dir_name}\\" is not directory","is_not_link":"\\"{dir_name}\\" is not link","is_not_text":"\\"{dir_name}\\" is not text","no_such_dirs":"No such directory or file"}}')},8566:function(n){n.exports=JSON.parse('{"test":{"hello":"こんにちは、世界","format":"こんにちは！{name}！","multiline":["配列を使うと複数行の文字を表示できます","{one}行目","{two}行目"]},"help":{"summary":{"cd":"ディレクトリを移動します。","ls":"ファイルをリスト表示します。","cat":"テキストファイルの内容を表示します。","history":"コマンドの履歴を表示します。","lang":"言語を変更します。","open":"リンクファイルを開きます。","share":"SNSでシェアします。"}},"messages":{"clear_history":"履歴を削除しました","no_history":"履歴がありません"},"errors":{"is_not_dir":"\\"{dir_name}\\" は ディレクトリではありません","is_not_link":"\\"{dir_name}\\" は リンクではありません","is_not_text":"\\"{dir_name}\\" は テキストファイルではありません","no_such_dirs":"そのようなディレクトリやファイルはありません"}}')}},e={};function r(t){var a=e[t];if(void 0!==a)return a.exports;var i=e[t]={exports:{}};return n[t](i,i.exports,r),i.exports}r.m=n,function(){var n=[];r.O=function(e,t,a,i){if(!t){var s=1/0;for(_=0;_<n.length;_++){t=n[_][0],a=n[_][1],i=n[_][2];for(var l=!0,o=0;o<t.length;o++)(!1&i||s>=i)&&Object.keys(r.O).every((function(n){return r.O[n](t[o])}))?t.splice(o--,1):(l=!1,i<s&&(s=i));if(l){n.splice(_--,1);var d=a();void 0!==d&&(e=d)}}return e}i=i||0;for(var _=n.length;_>0&&n[_-1][2]>i;_--)n[_]=n[_-1];n[_]=[t,a,i]}}(),function(){r.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return r.d(e,{a:e}),e}}(),function(){r.d=function(n,e){for(var t in e)r.o(e,t)&&!r.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})}}(),function(){r.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"===typeof window)return window}}()}(),function(){r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)}}(),function(){var n={143:0};r.O.j=function(e){return 0===n[e]};var e=function(e,t){var a,i,s=t[0],l=t[1],o=t[2],d=0;if(s.some((function(e){return 0!==n[e]}))){for(a in l)r.o(l,a)&&(r.m[a]=l[a]);if(o)var _=o(r)}for(e&&e(t);d<s.length;d++)i=s[d],r.o(n,i)&&n[i]&&n[i][0](),n[i]=0;return r.O(_)},t=self["webpackChunkcli"]=self["webpackChunkcli"]||[];t.forEach(e.bind(null,0)),t.push=e.bind(null,t.push.bind(t))}();var t=r.O(void 0,[998],(function(){return r(8785)}));t=r.O(t)})();
//# sourceMappingURL=app.f9cc12cb.js.map